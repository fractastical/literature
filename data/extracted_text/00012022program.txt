Program Inference and Regeneration
via Active Learning
by
Jiasi Shen
B.S., Peking University (2013)
S.M., Massachusetts Institute of Technology (2015)
Submitted to the Department of Electrical Engineering and Computer
Science
in partial fulfillment of the requirements for the degree of
Doctor of Philosophy
at the
MASSACHUSETTS INSTITUTE OF TECHNOLOGY
September 2022
¬© Massachusetts Institute of Technology 2022. All rights reserved.
Author ................................................................
Department of Electrical Engineering and Computer Science
August 26, 2022
Certified by............................................................
Martin C. Rinard
Professor of Electrical Engineering and Computer Science
Thesis Supervisor
Accepted by...........................................................
Leslie A. Kolodziejski
Professor of Electrical Engineering and Computer Science
Chair, Department Committee on Graduate Students
2
Program Inference and Regeneration via Active Learning
by
Jiasi Shen
Submitted to the Department of Electrical Engineering and Computer Science
on August 26, 2022, in partial fulfillment of the
requirements for the degree of
Doctor of Philosophy
Abstract
Software now plays a central role in numerous aspects of human society. Current
software development practices involve significant developer effort in all phases of
the software life cycle, including the development of new software, detection and
elimination of defects and security vulnerabilities in existing software, maintenance
of legacy software, and integration of existing software into more contexts, with the
quality of the resulting software still leaving much to be desired. The goal of my
research is to improve software quality and reduce costs by automating tasks that
currently require substantial manual engineering effort.
I present a novel approach for program inference and regeneration, which takes
an existing program, learns its core functionality as a black box, builds a model that
captures this functionality, and uses the model to generate a new program. The
new program delivers the same core functionality but is potentially augmented or
transformed to eliminate defects, systematically introduce safety or security checks,
or operate successfully in different environments.
This research enables the rejuvenation and retargeting of existing software and
provides a powerful way for developers to express program functionality that adapts
flexibly to a variety of contexts. For instance, one benefit is enabling new develop-
ment methodologies that work with simple prototype implementations as specifica-
tions, then use regeneration to automatically obtain clean, efficient, and secure im-
plementations. Another benefit is automatically improving program comprehension
and producing cleaner code, making the code more transparent and the developers
more productive. A third benefit is automatically extracting the human knowledge
crystallized and encapsulated in legacy software systems and retargeting it to new lan-
guages and platforms, including languages and platforms that provide more powerful
features.
In this thesis, I present two systems that implement this approach for database-
backed programs.
Thesis Supervisor: Martin C. Rinard
Title: Professor of Electrical Engineering and Computer Science
3
4
Acknowledgments
I would like to thank my advisor, Martin Rinard. Being Martin‚Äôs student has been
a unique experience. He almost destroyed my research style and then rebuilt it. By
listening to Martin‚Äôs daily conversations, I realized that it might actually be fun to
make bold claims and convince others to agree. I came to realize that the great fun
of research was not in becoming incrementally better than prior work, but in being
the first to think of and prove a brand new idea. I wanted to do this kind of research
but did not know how to do it at the beginning of my Ph.D. Martin has taught
me how to do it. He has guided me to identify important unsolved problems in our
field. He has trained me to approach difficult problems by turning them into simpler
variants. He has demonstrated his vision and boldness by waiting years until the
initially unconventional ideas were gradually adopted by our community. Martin has
inspired us to pursue high-risk, high-reward research directions, providing us with
technical, financial, and social support to help us tolerate the risks. I am grateful to
Martin for providing such a precious research environment.
I would like to thank my thesis committee, Saman Amarasinghe and Armando
Solar-Lezama. Their thought-provoking comments have helped me think about how
my research fits in a greater context. I would also like to thank them and J√ºrgen Cito,
one of my collaborators, for helping me with my job applications. These professors as
well as Adam Chlipala, who served on my research qualification exam committee, and
Daniel Jackson, who served as my graduate counselor, challenged me with interesting
philosophical questions that prepared me for a broader audience.
I would like to thank my labmates and collaborators, including Sara Achour, Jos√©
Cambronero, Michael Carbin, J√ºrgen Cito, Thurston Dang, Austin Gadient, Michael
Gordon, Shivam Handa, Malavika Samak, Kai Jia, Charles Jin, Fereshte Khani, De-
okhwan Kim, Fan Long, Varun Mangalick, Sasa Misailovic, Christopher Musco, Jeff
Perkins, Zichao Qi, Julia Rubin, Stelios Sidiroglou-Douskos, Phillip Stanley-Marbell,
Felix Stutz, Nikos Vasilakis, Jerry Wu, Yichen Yang, Adam Yedidia, and Damien
Zufferey. They are creative and open-minded and have helped me build my research
5
tastes, technical insights, and social skills. My thesis won‚Äôt be possible without them.
Other members of the MIT PL/SE community have also inspired me in a variety of
ways. Ad-hoc hallway chats were sometimes more productive than official meetings.
I will miss the good times when I could simply run into these brilliant people on the
7th floor of Stata.
I would like to thank my fellow Ph.D. students, especially Cheng Peng and Tsui-
Wei (Lily) Weng, for sharing happiness and sorrow when we were trying to figure
things out along our journey.
Special thanks to my parents, my grandparents, and Yibo Gao for their support.
Their curiosity and perseverance have given me strength and inspiration over the
years.
6
Contents
1 Introduction 21
1.1 Konure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
1.2 Shear . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
1.3 Design Rationale . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
1.3.1 Observer Models . . . . . . . . . . . . . . . . . . . . . . . . . 31
1.4 Benefits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
2 Related Work 37
2.1 Active Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
2.2 Program Synthesis . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
2.3 Reverse Engineering . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
2.4 Code Translation, Refactoring, and Optimization . . . . . . . . . . . 46
3 Konure: Active Learning for Inference and Regeneration of Appli-
cations that Access Databases 49
3.1 Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
3.2 Design Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
3.3 Konure Domain-Specific Language . . . . . . . . . . . . . . . . . . . 62
3.3.1 DSL Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
3.3.2 Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
3.3.3 DSL Definition . . . . . . . . . . . . . . . . . . . . . . . . . . 64
3.3.4 Design Rationale . . . . . . . . . . . . . . . . . . . . . . . . . 65
3.3.5 Expressiveness and Limitations . . . . . . . . . . . . . . . . . 66
7
3.4 Konure Inference Algorithm . . . . . . . . . . . . . . . . . . . . . . 67
3.4.1 Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
3.4.2 Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
3.5 Path Constraint Solver . . . . . . . . . . . . . . . . . . . . . . . . . . 87
3.6 Origin Location Disambiguation . . . . . . . . . . . . . . . . . . . . . 87
4 Soundness Proof of Konure 95
4.1 Soundness Proof Overview . . . . . . . . . . . . . . . . . . . . . . . . 95
4.2 The Trim Transformation . . . . . . . . . . . . . . . . . . . . . . . . 102
4.2.1 Termination of Trim . . . . . . . . . . . . . . . . . . . . . . . 103
4.2.2 Soundness of Trim . . . . . . . . . . . . . . . . . . . . . . . . 109
4.3 Source Code Characteristics . . . . . . . . . . . . . . . . . . . . . . . 115
4.4 Soundness of DetectLoops . . . . . . . . . . . . . . . . . . . . . . 117
4.5 Soundness of GetTrace . . . . . . . . . . . . . . . . . . . . . . . . 123
4.5.1 Traversing the Program AST . . . . . . . . . . . . . . . . . . 123
4.5.2 Traversing the Loop Layout Tree . . . . . . . . . . . . . . . . 126
4.5.3 Consistency with Program AST, Path Constraint, and Loop
Layout Tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
4.6 Soundness of the Core Inference Algorithm . . . . . . . . . . . . . . . 134
4.6.1 Updating the Context while Traversing the Program AST . . 134
4.6.2 Soundness of InferProg . . . . . . . . . . . . . . . . . . . . 139
4.6.3 Soundness of Infer . . . . . . . . . . . . . . . . . . . . . . . 150
4.7 Complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
4.8 Remark on the Konure DSL . . . . . . . . . . . . . . . . . . . . . . 152
4.8.1 Programs in Konure DSL Grammar . . . . . . . . . . . . . . 152
4.8.2 Programs Expressible in Konure DSL . . . . . . . . . . . . . 157
5 Experimental Evaluation of Konure 159
5.1 RQ1: Ability to Infer and Regenerate Benchmark Programs . . . . . 160
5.1.1 Benchmark Applications . . . . . . . . . . . . . . . . . . . . . 160
5.1.2 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
8
5.1.3 Commands Not Expressible in Konure DSL . . . . . . . . . 167
5.2 RQ2: Scalability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
5.2.1 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
5.2.2 Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
5.3 RQ3: Active Learning Versus User Inputs . . . . . . . . . . . . . . . 176
5.4 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
6 Shear: Inferring Loop Structures in Database-Backed Applications
via Speculative Manipulation 179
6.1 Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
6.2 Problem Formulation . . . . . . . . . . . . . . . . . . . . . . . . . . . 189
6.2.1 DSL for Inferrable Programs . . . . . . . . . . . . . . . . . . . 189
6.2.2 Formalizing the Program Behavior . . . . . . . . . . . . . . . 191
6.3 Probe-and-Validate Cycle for Inferring Loop Structures . . . . . . . . 192
6.3.1 Speculative Manipulation of Database Interactions . . . . . . 193
6.3.2 Loop Inference Based on Fine-Grained Interactive Feedback . 196
6.3.3 Soundness of the Loop Inference Algorithm . . . . . . . . . . . 200
6.4 Modular Constructive Inference of Full Program Structure . . . . . . 203
6.4.1 Modular Inference of Program Constructs . . . . . . . . . . . 203
6.4.2 Soundness of the Full Program Inference Algorithm . . . . . . 207
7 Experimental Evaluation of Shear 209
7.1 RQ1: Ability to Infer and Regenerate Benchmark Programs . . . . . 210
7.1.1 Benchmark Applications . . . . . . . . . . . . . . . . . . . . . 210
7.1.2 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
7.1.3 Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
7.2 RQ2: Scalability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
7.2.1 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
7.2.2 Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
7.3 RQ3: Speculative Manipulation Versus Enumerative Search . . . . . . 221
7.3.1 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
9
7.3.2 Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
7.4 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226
8 Conclusion 227
A Code Regenerated byKonure 229
A.1 Regenerated Code for Fulcrum Task Manager . . . . . . . . . . . . . 229
A.1.1 Command get_home . . . . . . . . . . . . . . . . . . . . . . . 229
A.1.2 Command get_projects . . . . . . . . . . . . . . . . . . . . 230
A.1.3 Command get_projects_id . . . . . . . . . . . . . . . . . . 231
A.1.4 Command get_projects_id_stories . . . . . . . . . . . . . 233
A.1.5 Command get_projects_id_stories_id . . . . . . . . . . . 235
A.1.6 Command get_projects_id_stories_id_notes . . . . . . . 237
A.1.7 Command get_projects_id_stories_id_notes_id . . . . . 238
A.1.8 Command get_projects_id_users . . . . . . . . . . . . . . 240
A.2 Regenerated Code for Kandan Chat Room . . . . . . . . . . . . . . . 242
A.2.1 Command get_channels . . . . . . . . . . . . . . . . . . . . 242
A.2.2 Command get_channels_id_activities . . . . . . . . . . . 245
A.2.3 Command get_channels_id_activities_id . . . . . . . . . 248
A.2.4 Command get_me . . . . . . . . . . . . . . . . . . . . . . . . 250
A.2.5 Command get_users . . . . . . . . . . . . . . . . . . . . . . 252
A.2.6 Command get_users_id . . . . . . . . . . . . . . . . . . . . 255
A.3 Regenerated Code for Enki Blogging Application . . . . . . . . . . . 257
A.3.1 Command get_admin_comments_id . . . . . . . . . . . . . . 257
A.3.2 Command get_admin_pages . . . . . . . . . . . . . . . . . . 257
A.3.3 Command get_admin_pages_id . . . . . . . . . . . . . . . . 258
A.3.4 Command get_admin_posts . . . . . . . . . . . . . . . . . . 258
A.4 Regenerated Code for Blog Application . . . . . . . . . . . . . . . . . 259
A.4.1 Command get_articles . . . . . . . . . . . . . . . . . . . . 259
A.4.2 Command get_article_id . . . . . . . . . . . . . . . . . . . 259
A.5 Regenerated Code for Student Registration System . . . . . . . . . . 260
10
A.5.1 Command liststudentcourses . . . . . . . . . . . . . . . . 260
B Synthetic Commands for EvaluatingKonure 263
B.1 Simple Sequences (SS) . . . . . . . . . . . . . . . . . . . . . . . . . . 263
B.2 Nested Conditionals (NC) . . . . . . . . . . . . . . . . . . . . . . . . 267
B.3 Unambiguous Long Reference Chains (UL) . . . . . . . . . . . . . . . 271
B.4 Ambiguous Long Reference Chains (AL) . . . . . . . . . . . . . . . . 277
B.5 Ambiguous Short Reference Chains (AS) . . . . . . . . . . . . . . . . 284
C Synthetic Commands for EvaluatingShear 293
C.1 Repetitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
C.1.1 Command repeat_2 . . . . . . . . . . . . . . . . . . . . . . . 293
C.1.2 Command repeat_3 . . . . . . . . . . . . . . . . . . . . . . . 293
C.1.3 Command repeat_4 . . . . . . . . . . . . . . . . . . . . . . . 293
C.1.4 Command repeat_5 . . . . . . . . . . . . . . . . . . . . . . . 294
C.2 Nested Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
C.2.1 Command nest . . . . . . . . . . . . . . . . . . . . . . . . . . 294
C.3 Consecutive Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
C.3.1 Command after_2 . . . . . . . . . . . . . . . . . . . . . . . . 294
C.3.2 Command after_3 . . . . . . . . . . . . . . . . . . . . . . . . 295
C.3.3 Command after_4 . . . . . . . . . . . . . . . . . . . . . . . . 295
C.3.4 Command after_5 . . . . . . . . . . . . . . . . . . . . . . . . 296
C.4 Command example (Section 6.1) . . . . . . . . . . . . . . . . . . . . 296
D Code Regenerated byShear 299
D.1 Regenerated Code for RailsCollab Project Manager . . . . . . . . . . 299
D.1.1 Command get_projects_id_messages . . . . . . . . . . . . 299
D.1.2 Command get_projects_id_messages_id . . . . . . . . . . 307
D.1.3 Command get_projects_id_messages_display_list . . . . 312
D.1.4 Command get_projects_id_times . . . . . . . . . . . . . . 320
D.1.5 Command get_projects_id_times_id . . . . . . . . . . . . 330
11
D.1.6 Command get_projects_id_milestones_id . . . . . . . . . 343
D.1.7 Command get_projects . . . . . . . . . . . . . . . . . . . . 349
D.1.8 Command get_companies_id . . . . . . . . . . . . . . . . . . 351
D.1.9 Command get_users_id . . . . . . . . . . . . . . . . . . . . 352
D.2 Regenerated Code for Kanban Task Manager . . . . . . . . . . . . . . 355
D.2.1 Command get_api_lists . . . . . . . . . . . . . . . . . . . . 355
D.2.2 Command get_api_lists_id . . . . . . . . . . . . . . . . . . 358
D.2.3 Command get_api_cards . . . . . . . . . . . . . . . . . . . . 361
D.2.4 Command get_api_cards_id . . . . . . . . . . . . . . . . . . 363
D.2.5 Command get_api_boards_id . . . . . . . . . . . . . . . . . 365
D.2.6 Command get_api_users_current . . . . . . . . . . . . . . 369
D.2.7 Command get_api_users_id . . . . . . . . . . . . . . . . . . 369
D.3 Regenerated Code for Todo Task Manager . . . . . . . . . . . . . . . 369
D.3.1 Command get_home . . . . . . . . . . . . . . . . . . . . . . . 369
D.3.2 Command get_lists_id_tasks . . . . . . . . . . . . . . . . 370
D.3.3 Command get_lists_id_tasks . . . . . . . . . . . . . . . . 371
D.4 Regenerated Code for Fulcrum Task Manager . . . . . . . . . . . . . 372
D.4.1 Command get_home . . . . . . . . . . . . . . . . . . . . . . . 372
D.4.2 Command get_projects . . . . . . . . . . . . . . . . . . . . 373
D.4.3 Command get_projects_id . . . . . . . . . . . . . . . . . . 374
D.4.4 Command get_projects_id_stories . . . . . . . . . . . . . 376
D.4.5 Command get_projects_id_stories_id . . . . . . . . . . . 378
D.4.6 Command get_projects_id_stories_id_notes . . . . . . . 380
D.4.7 Command get_projects_id_stories_id_notes_id . . . . . 381
D.4.8 Command get_projects_id_users . . . . . . . . . . . . . . 383
D.5 Regenerated Code for Kandan Chat Room . . . . . . . . . . . . . . . 385
D.5.1 Command get_channels . . . . . . . . . . . . . . . . . . . . 385
D.5.2 Command get_channels_id_activities . . . . . . . . . . . 388
D.5.3 Command get_channels_id_activities_id . . . . . . . . . 391
D.5.4 Command get_me . . . . . . . . . . . . . . . . . . . . . . . . 392
12
D.5.5 Command get_users . . . . . . . . . . . . . . . . . . . . . . 394
D.5.6 Command get_users_id . . . . . . . . . . . . . . . . . . . . 397
D.6 Regenerated Code for Enki Blogging Application . . . . . . . . . . . 399
D.6.1 Command get_home . . . . . . . . . . . . . . . . . . . . . . . 399
D.6.2 Command get_archives . . . . . . . . . . . . . . . . . . . . 400
D.6.3 Command get_admin_comments_id . . . . . . . . . . . . . . 401
D.6.4 Command get_admin_pages . . . . . . . . . . . . . . . . . . 402
D.6.5 Command get_admin_pages_id . . . . . . . . . . . . . . . . 402
D.6.6 Command get_admin_posts . . . . . . . . . . . . . . . . . . 403
D.6.7 Command get_admin . . . . . . . . . . . . . . . . . . . . . . 403
D.7 Regenerated Code for Blog . . . . . . . . . . . . . . . . . . . . . . . . 405
D.7.1 Command get_articles . . . . . . . . . . . . . . . . . . . . 405
D.7.2 Command get_article_id . . . . . . . . . . . . . . . . . . . 405
D.8 Regenerated Code for Student Registration System . . . . . . . . . . 406
D.8.1 Command liststudentcourses . . . . . . . . . . . . . . . . 406
D.9 Regenerated Code for Synthetic . . . . . . . . . . . . . . . . . . . . . 407
D.9.1 Command repeat_2 . . . . . . . . . . . . . . . . . . . . . . . 407
D.9.2 Command repeat_3 . . . . . . . . . . . . . . . . . . . . . . . 407
D.9.3 Command repeat_4 . . . . . . . . . . . . . . . . . . . . . . . 407
D.9.4 Command repeat_5 . . . . . . . . . . . . . . . . . . . . . . . 408
D.9.5 Command nest . . . . . . . . . . . . . . . . . . . . . . . . . . 408
D.9.6 Command after_2 . . . . . . . . . . . . . . . . . . . . . . . . 409
D.9.7 Command after_3 . . . . . . . . . . . . . . . . . . . . . . . . 409
D.9.8 Command after_4 . . . . . . . . . . . . . . . . . . . . . . . . 410
D.9.9 Command after_5 . . . . . . . . . . . . . . . . . . . . . . . . 410
D.9.10 Commandexample (Section 6.1) . . . . . . . . . . . . . . . . 411
13
14
List of Figures
1-1 Program inference and regeneration via active learning . . . . . . . . 22
3-1 Example command in Java . . . . . . . . . . . . . . . . . . . . . . . . 51
3-2 Example command in Java (continued) . . . . . . . . . . . . . . . . . 52
3-3 The Konure architecture, including a transparent proxy interposed
between the application and the database to observe the generated
database traffic. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
3-4 The Konure activelearningalgorithmiterativelyrefinesitshypothesis
to infer the application. . . . . . . . . . . . . . . . . . . . . . . . . . . 53
3-5 First execution trace . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
3-6 Grammar for the Konure DSL . . . . . . . . . . . . . . . . . . . . . 54
3-7 Second execution trace . . . . . . . . . . . . . . . . . . . . . . . . . . 55
3-8 Hypothesis after resolving the topmost Prog nonterminal to an If state-
ment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
3-9 Third execution trace . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
3-10 Hypothesis after resolvingùëÉ1 (Figure 3-8). . . . . . . . . . . . . . . 57
3-11 Concrete trace from an execution to resolveùëÉ3 (Figure 3-10). The
third query retrieves two rows. The final four queries are generated by
a loop that iterates over the retrieved two rows. . . . . . . . . . . . . 59
3-12 Hypothesis after resolvingùëÉ3 (Figure 3-10). . . . . . . . . . . . . . . 59
3-13 Konure infers the example command and regenerates code in Python 88
3-14 Grammar for skeleton programs (S) . . . . . . . . . . . . . . . . . . . 89
3-15 Calculating the skeleton of a program . . . . . . . . . . . . . . . . . . 89
15
3-16 Grammars for concrete and abstract traces. . . . . . . . . . . . . . . 90
3-17 Semantics for executing a program using a context to obtain a concrete
trace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
3-18 Grammar for loop layout trees . . . . . . . . . . . . . . . . . . . . . . 91
3-19 Check if two expressions are identical except for equivalent variables
with respect to a path constraint . . . . . . . . . . . . . . . . . . . . 92
4-1 Check if two programs are identical except for equivalent variables . . 96
4-2 Semantics for executing a program using a context to directly obtain
a list of query-result pairs . . . . . . . . . . . . . . . . . . . . . . . . 97
4-3 Semantics for executing a program using a context to obtain a loop
layout tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
4-4 Traverse a program by following an annotated trace, to obtain a sub-
program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
4-5 Traverse a loop layout tree by following an annotated trace, to obtain
a subtree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
4-6 Traverse a program and a corresponding loop layout tree by following
an annotated trace, updating the context . . . . . . . . . . . . . . . . 138
5-1 Performance on synthetic commands . . . . . . . . . . . . . . . . . . 175
6-1 Example program in Python . . . . . . . . . . . . . . . . . . . . . . . 180
6-2 Example execution trace . . . . . . . . . . . . . . . . . . . . . . . . . 181
6-3 Plausible loop structures that may produce the example trace . . . . 182
6-4 Shear performsspeculativemanipulationtoinferandregeneratedatabase-
backed programs that may contain loop and repetitive structures . . . 183
6-5 Shear alters the database traffic during program execution to infer
loops structures from the example trace . . . . . . . . . . . . . . . . . 184
6-6 Shear alters the database traffic during program execution to infer
loops structures from the example trace (continued) . . . . . . . . . . 185
16
6-7 Shear validates the change-sets for the hypothesis L and concludes
that L is correct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
6-8 Shear validates the change-sets for the hypothesis Z and concludes
that Z is incorrect . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
6-9 Shear infers the example program and regenerates code in Python . 188
6-10 Program inference and regeneration . . . . . . . . . . . . . . . . . . . 189
6-11 Grammar for theShear DSL . . . . . . . . . . . . . . . . . . . . . . 190
6-12 Contexts for programs in the DSL . . . . . . . . . . . . . . . . . . . . 191
6-13 Illustration of Algorithm 11 when applied to a true loop that iterates
over theùëò-th query . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
6-14 Illustration of Alg. 12 . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
6-15 Infer the boundaries of the only iteration . . . . . . . . . . . . . . . . 206
7-1 Programs for testing scalability . . . . . . . . . . . . . . . . . . . . . 219
7-2 Time to infer loops in programs with various measures of complexity 222
7-3 Number of candidate loop structures in programs with various mea-
sures of complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
7-4 Log base 10 of the number of candidate AST structures in programs
with various maximum depths . . . . . . . . . . . . . . . . . . . . . . 225
17
18
List of Tables
5.1 Inference effort and regenerated code size . . . . . . . . . . . . . . . . 164
7.1 Shear‚Äôs performance on inferring and regenerating benchmark com-
mands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
7.2 Shear‚Äôs performance on inferring and regenerating benchmark com-
mands (continued) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
19
20
Chapter 1
Introduction
Progress in human societies is cumulative ‚Äî each new generation builds on tech-
nology, knowledge, and experience accumulated over previous generations. Software
collectively comprises one valuable store of human knowledge and experience as con-
cretely realized in applications and software components. But there is currently no
easy way to extract this knowledge and experience from its original context to pro-
ductively deploy it into the new contexts that inevitably arise as societies evolve over
time.
This thesis presents techniques for analyzing software to extract its core function-
ality and formulate this core functionality as a formal model. The goal is to make this
model flexible, comprehensible, and exact. To achieve this goal, I identify recurring
patterns in software, capture these patterns formally, and then exploit properties
of these patterns to develop targetedprogram inference algorithmsthat use active
learning to infer the model of the target program.
This approach involves the following key components:
Domain of Computation. The approach involves a domain of supported pro-
grams whose behavior is defined formally via a domain-specific language (DSL). The
DSL characterizes the externally observable behavior of programs that can be in-
ferred. Generally, the externally observable behavior consists of the input-output
behavior of the program (Figure 1-1a).
21
(a) Generic concept
 (b) Specialized for database-backed programs
Figure 1-1: Program inference and regeneration via active learning
This thesis presents techniques for inferring programs that interact with an ex-
ternal database, whose the externally visible behavior also includes the database
query traffic during execution (Figure 1-1b). Applications that access databases
are ubiquitous in computing systems. Such applications translate commands from
the application domain into operations on the database, with the application con-
structing strings that it then passes to the database to implement the operations.
Web servers, which accept HTTP commands from web browsers and interact with
back-end databases to retrieve relevant data, are one particularly prominent exam-
ple of such applications. These applications are written in a range of languages,
often quickly become poorly-understood legacy software, and, because they are typ-
ically directly exposed to Internet traffic, have been a prominent target for security
attacks [85, 25, 34, 84, 114, 104, 95, 71]. Such applications therefore comprise a
particularly compelling target for automatic program inference and regeneration.
Inference Algorithm. The approach involves an algorithm for inferring programs
in the target domain. This algorithm exploits the domain knowledge to make the
inference problem feasible. This thesis presents inference algorithms that perform
active learning to eliminate uncertainty efficiently. In other words, the algorithms
automatically select the inputs to run a program and infer its behavior. The inputs
are selected to be the useful ones that distinguish nonequivalent programs in the
target domain. These algorithms are efficient even when working with an infinite
space of potential inputs and candidate programs, and they infer a uniquely correct
model in the DSL that is observationally equivalent to the original program, as long
22
as the behavior of the original program is expressible in the DSL.
Correctness Guarantee. We provide correctness guarantees for programs whose
behavior is expressible in our DSL. Our approach involves a rigorous mathematical
proof that the inference algorithm will terminate with a uniquely correct model, which
is the same program as the original one as expressed in the DSL. A key enabler of
this property is that the DSL has acanonical form. That is, when two programs in
the DSL are observationally equivalent, they must be syntactically identical except
for equivalent variable references. This characteristic enables us to prove that the
inference algorithms are sound and complete.
Augmented Regeneration. In general, we expect the extracted models to have
many potential uses in the software development life cycle. In this thesis I focus on
the automatic regenerationof new programs that implement the original core func-
tionality, but are potentially augmented or transformed to operate successfully in new
software environments or platforms, contain systematically inserted security checks,
or consist of newly generated code that is clean, maintainable, and/or expressed in a
modern target programming language.
This model can then enable the automatic regeneration of new programs that
deliver the same core functionality but are potentially augmented or transformed
to operate successfully in different environments, such as by retargeting to various
platforms, inserting systematic security checks, or generating new code that is clean
and maintainable. These capabilities can help developers automatically manipulate
and transform software, thereby reducing manual engineering effort.
1.1 Konure
Chapters 3, 4, and 5 present a new system,Konure, that implements active learn-
ing plus regeneration for applications that retrieve data from relational databases.
Konure systematically constructs database contents and application inputs, runs
23
the application with the database and inputs, then observes the resulting database
traffic and outputs to infer a model of application behavior.
Domain-Specific Language. To make the inference problem tractable,Konure
works with a domain-specific language (DSL) that (1) captures common application
behavior and (2) supports a hierarchical inference algorithm that progressively ex-
plores application behavior to infer the model.
The DSL captures database-backed programs with the following key characteris-
tics: (1) each statement performs an SQL query to retrieve rows from the database,
(2) the retrieved rows determine the control flow, and (3) the data flow is largely
visible in the database traffic.
Although we designed the DSL to be an internal representation that is invisible
to users, it is straightforward to provide direct access to the DSL so that users may
write programs directly in the DSL.
Inference Algorithm. The Konure algorithm uses an SMT solver to generate
useful inputs and database values with which to execute the original program. As
the algorithm executes the program, it observes the program behavior in terms of
the database traffic and the outputs. Based on this observation, the algorithm (con-
ceptually) maintains a hypothesis of the inferred program structure as a sentential
form [16] (a partially expanded syntax tree) of the grammar that defines the DSL.
The algorithm recursively expands nonterminal symbols in the current working
sentential form. Each recursive step of the algorithm identifies a unique correct pro-
duction for expanding a nonterminal symbol in the DSL. Specifically, the algorithm
selects a nonterminal in the hypothesis, constructs inputs and database contents that
enable it to determine the one production to apply to this nonterminal that is consis-
tent with the behavior of the application, configures the database, runs the applica-
tion, then observes the resulting database traffic and outputs to refine the hypothesis
by applying the inferred production to the nonterminal.
24
Guarantees. If the application conforms to one of the models defined by the DSL,
thenthealgorithmisguaranteedto(1)terminateand(2)produceaninferredprogram
that correctly models the full core functionality of the application. BecauseKonure
interacts with the application only via its inputs, outputs, and observed database
interactions, it can infer and regenerate applications written in any language or in
any coding style or methodology.
Key Inferrability Properties. The design of theKonure DSL, together with its
associated top-down inference algorithm, is a central contribution of this thesis. We
next outline several key properties of the design that enable inferrability via active
learning.
In general, programs contain statements linked together by control and data flow.
To promote control-flow inferrability, each statement in the DSL executes a query
that is directly observable in the intercepted database traffic. All control flow is tied
directly to the query results ‚Äî If statements test if their query retrieves empty data;
For statements iterate over all rows that their query retrieves, with all iterations
independent. These properties help Konure generate a focused, tractably small
sequence of inputs and database contents that (1) finds and traverses all relevant
control-flow paths and (2) completely resolves each For loop with a single execution
of two or more iterations.
To promote data flow inferrability, all data flows directly from either input pa-
rameters or retrieved query results to executed queries or outputs.Konure infers
the data flow by matching concrete values in executed queries or outputs against the
input parameter or retrieved query result with the same value.Konure eliminates
potential data flow ambiguities by populating the input parameters and database
contents with appropriately distinct concrete values.
The DSL is designed to enable the formulation of all properties of interest as
quantifier-free SMT formulas. Konure leverages this property to construct inputs
and databases that explore all relevant control-flow paths and deliver the distinct
values that enableKonure to infer the data flow.
25
Contributions. The Konure research makes the following contributions.
‚Ä¢ Inference Algorithm: It presents a new algorithm for inferring the behav-
ior of database-backed applications. Conceptually, the algorithm works with
hypotheses represented as sentential forms of the grammar ofKonure DSL.
At each stage the algorithm systematically constructs database contents and
application inputs, runs the application, and observes the resulting database
traffic and outputs to resolve a selected nonterminal in the current hypothe-
sis. This approach enablesKonure to work effectively with unbounded model
spaces to infer models that capture the core functionality of the target class of
applications.
‚Ä¢ DSL Design:It presents a DSL for capturing specific computational patterns
typically implemented by database-backed applications. The inference algo-
rithm and DSL are designed together to enable an effective active learning al-
gorithm that leverages the structure of the DSL to iteratively refine hypotheses
represented as sentential forms in the DSL grammar.
‚Ä¢ Soundness and Completeness:It presents a key theorem that states that if
the behavior of the application conforms to the DSL, then the inference algo-
rithm infers a program that correctly captures the full core functionality of the
application.
‚Ä¢ Regeneration: It shows how to regenerate new versions of the application
that implement safe computational patterns and contain appropriate safety and
security checks. The regenerator encapsulates the knowledge required to work
effectively in the target domain and can eliminate coding errors that lead to
incorrect application behavior or security vulnerabilities.
‚Ä¢ Experimental Results: It presents results usingKonure to infer and re-
generate commands written in Ruby on Rails and Java. The commands are
chosen from five open-source applications: Fulcrum Task Manager [3], Kandan
26
Chat Room [5], Enki Blogging Application [2], Blog [4], and a student regis-
tration application developed by an independent evaluation team to test SQL
injection attack detection and nullification techniques. Our results highlight
Konure‚Äôs ability to infer and regenerate robust, safe Python implementations
of commands originally coded in other languages.
1.2 Shear
With Konure, an important open question is how to effectively infer programs that
contain loops and repetitive structures. A common approach inKonure and other
prior work is to apply heuristics that attempt to recognize repetitive structures in
execution traces, then use those structures to infer the underlying presence of loops.
Because there are, in general, multiple program structures that can generate the
observed repetitions, prior techniques all limit either the program structures or the
observed sequences that they can successfully work with. For example, theKonure
DSL allows only a few limited forms of multiple similar queries to occur in programs.
It also requires any loop to be the last statement of the program. And it does
not support nested loops. These limitations can constrain the applicability of prior
techniques (Section 7.1.3).
Chapters 6 and 7 present a new system,Shear, that addresses the loop inference
problem. Shear significantly expands the DSL to support more expressive loop and
repetition structures thanKonure while preserving the correctness guarantees.
Shear uses a novel dynamic analysis technique based onspeculative manipulation.
Our technique works with database-backed programs, observing and manipulating the
interactions with the database to infer the presence and structure of loops in the pro-
gram. This capability enablesShear to expand the range of inferrable computations
that may involve loop and repetition structures.
Inference Algorithm. The Shear algorithm is based on the following key ideas.
‚Ä¢ Probe-and-Validate Cycle: Our technique first identifies program execu-
27
tion points that may correspond to loops in the program that iterate over rows
returned from database queries. It then repeatedly executes the program on
the same input, but systematically intervenes in the interactions between the
program and the database by changing queries presented to the database to ma-
nipulate the number of rows that the database returns in response to the query.
This intervention systematically elicits different program behaviors that expose
information about the program structure, enhancing our ability to observe in-
ternal program structures and enabling us to efficiently infer the presence and
structure of loops.
‚Ä¢ Fine-Grained Interactive Feedback:The probe-and-validate cycle enables
our technique to go beyond merely observing unaltered program executions.
Actively manipulating the interactions with the environment enables the tech-
nique to purposefully generate new, altered, and otherwise unrealizable exe-
cutions that expose additional information about the internal structure of the
program. The result is a more powerful observation mechanism that enables
our technique to formulate and efficiently resolve more expressive hypotheses
about the internal structure of the program.
‚Ä¢ Modular Constructive Inference:The fine-grained interactive feedback en-
ables our technique to identify and fully disambiguate loop and repetitive struc-
tures in our target programs, many of which are otherwise indistinguishable
given tractable numbers of unaltered program executions. The enhanced ob-
servational power also enables an efficient, top-down inference algorithm that
unambiguously resolves each successive program construct in turn with no need
to backtrack or explore a larger program search space. The result is an algo-
rithm that linearly infers the full program by performing one inference step for
each program structure.
We characterize the range of programs that work withShear using a domain-
specific language (DSL). For any program that is expressible in this DSL,Shear un-
28
ambiguouslyinferscorrectprogramstructures‚Äîincludingloopsandrepetitivestructures‚Äî
that are identical to the ground truth.
We evaluate our technique based on its ability to infer and regenerate database-
backed programs. The evaluation indicates thatShear is able to infer and regenerate
a much wider range of programs than prior work [110, 135].1 Our evaluation also
indicates that our algorithm is scalable and efficient, which highlights the broader
applicability of our dynamic analysis approach.
Contributions. The Shear research makes the following contributions.
‚Ä¢ Speculative Manipulation: It presents a dynamic analysis approach based
on speculative manipulation, which alters a program‚Äôs interaction with the en-
vironment to infer the program structure. To the best of our knowledge, this is
the first technique that analyzes a program by intervening in the program execu-
tions. This novel approach enablesShear to address loop-related ambiguities,
an open question in program inference.
‚Ä¢ Soundness and Completeness:It presents a theorem that states that if the
behavior of a program conforms to the DSL, thenShear infers the correct
program. Shear infers the program by exploiting its strong boundary for in-
teracting with the external database.Shear works well with programs written
in any language or implementation styles, as long as the externally observable
behavior of the programs can be expressed in theShear DSL.
‚Ä¢ Experimental Results:It presents experimental results from ourShear im-
plementation. We evaluate Shear‚Äôs expressiveness by using it to infer and
regenerate open-source applications in Java and Ruby on Rails.Shear suc-
cessfully infers computations that go beyond the scope of prior work. We also
evaluate the scalability and efficiency of our algorithm. These results highlight
the effectiveness of our approach in inferring loop and repetitive structures.
1The most closely related prior work is Konure [135], which also infers programs that interact
with relational databases, but only by observing unaltered program executions.Shear infers a strict
superset of the programs that Konure infers. See Chapter 7 for a detailed analysis of the differences
between Konure andShear.
29
1.3 Design Rationale
Our approach is founded on several principles:
Programs as Specifications. We propose to use programs as (partial, noisy) spec-
ifications of the desired core functionality. In comparison with using standard speci-
fication languages based on formal logic, programming is a relatively widely available
skill within our society (and a skill that promises to become more available over
time). In comparison with natural language specifications, programs provide preci-
sion and the ability to explore and learn the specification by observing the program
as it produces outputs in response to targeted synthesized inputs.
Noisy, Partial Programs. Developing a fully correct program that handles every
corner case correctly is known to be much more difficult than developing a program
that implements most of the desired functionality correctly. The inference algorithms
are therefore designed to work with such mostly correct programs, in some cases by
workingwithinputsthatareunlikelytotriggerrarecornercases, inothersbyidentify-
ing and discarding undesirable behavior (noise) from the original program that should
not be part of the specification. Thus, this approach can work with original programs
that implement the desired core functionaliry, potentially omitting error-checking and
corner-case code, which can be inserted automatically during regeneration.
Focused Domains. To make the inference tractable, each inference algorithm fo-
cuses on a specific domain. In this thesis, we work with domains that arefinitely
testable, i.e., each computation in the domain can be uniquely identified from within
all of the computations in the domain by a finite set of inputs. In this thesis we
capture the domain via a domain-specific language.
Reinterpretation. Many modern programming languages support a simple and
basic model of computation (sequential execution, file input and output, standard
data structures, a single address space) that usually enables straightforward imple-
30
mentation of the desired core functionality. In many cases, however, the goal is to
implement this core functionality in a more complex environment ‚Äî to operate on
distributed data, to work with data stored in a relational database or key/value store,
to access specialized computing devices, to execute time-consuming computations in
parallel, to package the core functionality into an appealing graphical user interface
potentially accessed via the Internet, or to access values available via remote sensors.
To support such implementations, the regeneration algorithm reinterprets standard
constructs to translate them into implementations that operate successfully in the
new, more complex target context.
Encapsulated Knowledge. The regenerator encapsulates the knowledge of how
to use the complex software components that the regenerated code uses. Over the
last several decades, the field has explored a variety of approaches for capturing and
communicating this kind of knowledge. Examples include user manuals, textbooks,
example programs, and, more recently, web sites such as Stack Overflow [1]. All of
these mechanisms require the developer to examine the provided code and modify
it to adapt it for their purpose in their system. Regeneration enables the developer
to immediately obtain working code that implements the desired core functionality
without the need to examine and/or modify the code (although the developer may
very well do so if he or she desires). In this sense the regenerator can provide a
more robust encapsulation of the (in some cases quite involved) knowledge required
to productively use the powerful but complex target components.
1.3.1 Observer Models
A key trade-off point in the design of inference algorithms is the strength of the ob-
server that collects the program behavior. Programs that are observationally equiva-
lent when the observer is weaker may become distinguishable by a stronger observer.
A stronger observer therefore enables an inference algorithm that is more precise and
efficient but may also produce low-level detail that is less relevant for the target use
case.
31
Monolithic Black Box. We previously developed a black-box inference algorithm
that interacts with an original program by generating inputs and observing the re-
sulting outputs [126]. An advantage of treating the program as a black box is that the
original program can use any language or implementation methodology. For example,
the black-box approach readily works with obfuscated programs.
Gray Box Consisting of Black-Box Components whose Interactions are
Observable. Konure [135, 138] takes a gray-box approach. Konure treats a
database-backed application as a gray box that consists of two main components that
interact with each other. One such component is the database. The other component
is the controller that implements the core business logic. This separation of com-
ponents is appropriate for our target domain of database-backed applications, since
these applications in practice are often structured as code bases that implement the
business logic and interact with a third-party database server such as MySQL [165].
Konure infers the controller component as a black box by observing its inputs, out-
puts, and interactions with the database. By treating the controller component as a
black box,Konure works directly with applications that would be difficult to ana-
lyze otherwise, such as ones that are obfuscated, built with complicated frameworks,
or written in multiple languages. Meanwhile, because the database traffic is visible
to Konure, it distinguishes nonequivalent programs more efficiently than when only
the end-to-end inputs and outputs are observable.
Gray Box Consisting of Black-Box Components whose Interactions can
be Overwritten. Shear [136] also takes a gray-box approach, but its observer
is stronger than that of Konure. In addition to observing the inputs, outputs,
and database interactions asKonure does, Shear also intervenes in the database
interactions while the program executes.Shear uses such intervention to obtain fine-
grained interactive feedback, which enables a more precise and efficient algorithm for
inferring loop and repetition structures.
32
White Box. White-box approaches can also be appropriate, but may require more
involved mechanisms that (dynamically or statically) instrument and/or analyze as-
pects of the program such as the source code or the binaries.
1.4 Benefits
Our approach enables a novel paradigm,automatic software rejuvenation, which takes
an existing program, learns its core functionality, formulates it as a precise model,
and uses the model to generate a new program. It enables the rejuvenation and
retargeting of existing software. This paradigm can deliver benefits in many aspects
of the software life cycle.
New Software. The first benefit is enabling new development methodologies that
work with simple prototype implementations as (potentially noisy) specifications,
then use regeneration to automatically obtain clean, efficient, and secure implemen-
tations specialized for the specific context into which they will be deployed.
One example is starting from simple prototypes that implement only the core func-
tionality and generating correct-by-construction code augmented with checks that
eliminate security vulnerabilities [126]. In this thesis, I present techniques that re-
generate data-retrieval programs to add systematic checks that prevent SQL injection
vulnerabilities [135, 138, 136]. My collaborators and I have also used the DSL-based
approach to regenerate string-processing libraries, where the new versions no longer
invoke original potentially dangerous dependencies, eliminating software supply-chain
vulnerabilities [154].
Our approach promises to substantially reduce the time and effort required to
obtain programs that work with complex programming interfaces on modern complex
hardware platforms. By automating the generation of error, privacy, and security
checking code, it promises to improve program robustness and reliability.
Program Comprehension. The second benefit is automatically improving pro-
gram comprehension and producing cleaner code, making the code more transparent
33
and the developers more productive. Our techniques produce models of a program
that characterizes the program‚Äôs externally visible behavior, rather than its internal
implementation details [135, 138, 136, 154, 126, 137]. Because the model captures
core application functionality, it can help developers explore and better understand
this functionality especially when the source code is obscure, obfuscated, or unavail-
able. Preliminary results indicate that these models can help developers understand
the business logic flowing across multiple source files built with sophisticated frame-
works [55].
More broadly, our approach brings benefits to software archaeology, where the de-
veloper starts with a legacy system that implements the desired functionality. Here
one use case is to start with a system that runs in an obsolete or otherwise undesirable
computing context to obtain a regenerated version that can operate successfully in
a more modern context. Another use case is to start with a system that may have
defects or security vulnerabilities to generate a program without defects or vulnera-
bilities (by, for example, systematically generating appropriate checks and code). Yet
another use case is to improve performance by replacing an inefficient implementation
with a more efficient regenerated implementation. Even another use case is to replace
a program that has been maintained so intensively that its lifecycle is over and it is
no longer feasible to continue to maintain it [30].
Targeted Functionality Extraction. The third benefit is automatically extract-
ing the human knowledge in software and retargeting it to different languages and
platforms that provide more powerful features. Conceptually, the original program
implements a range of functionality, only part of which comprises the desired core
functionality. The developer provides a limited interface specification that targets
only the desired core functionality. The remaining undesired functionality is discarded
by the program inference and regeneration system, which then generates additional
functionality in the new version of the program.
For example, our techniques regenerate data storage and retrieval programs, where
the new versions are augmented with back-end databases and front-end web inter-
34
faces [126]. As another example, I supervised a Master‚Äôs thesis that regenerates
Python programs to use an external database instead of the original in-memory data
structures [45, 167]. Our technique can also regenerate stream-processing programs
with parallelism, so that the new versions perform the same computations but run
faster [137]. More broadly, our approach promises to enable developers to express
software functionality in flexible new ways that adapt to a variety of contexts.
35
36
Chapter 2
Related Work
In this chapter, we discuss related work in active learning, program synthesis, re-
verse engineering, and program transformation techniques such as code translation,
refactoring, and optimization.
2.1 Active Learning
Machine Learning. Active learning is a classical topic in machine learning [133].
Machine learning algorithms learn a relationship between features and predictions by
extracting statistical information from training data. Our approach similarly gener-
ates programs that are consistent with the given implementation, and we anticipate
the possibility of applying techniques related to program synthesis or machine learn-
ing. In contrast to most approaches in the machine learning community [133, 124],
our approach symbolically reasons about potential program structures and obtains
unique correct answers. Our approach is characterized by its extensive exploitation
of structure present in the program inference task: (1) learning outcomes specified by
a DSL, (2) hypotheses as sentential forms in the DSL, and (3) learning by resolving
nonterminals in the current hypothesis.
State Machine Model Learning.State machine learning algorithms [108, 23, 53,
120, 78, 13, 89, 157, 48, 70, 153, 12, 62, 119, 169] construct partial representations
37
of program functionality in the form of finite automata with states and transition
rules. State fuzzing tools [12, 62, 119] hypothesize state machines for programs. Net-
work function state model extraction [169] uses program slicing and models the sliced
partial programs as packet-processing automata. These algorithms extract partial
models of the given programs. Our approach, in contrast, (1) extracts a complete
representation of the core functionality, which, in turn, enables the regeneration (and
replacement) of the initial program, (2) can work with programs with defects or that
only partially implement the core functionality, (3) regenerates a new program or
programs, augmented as appropriate, that implement the core functionality without
defects or security vulnerabilities on new implementation platforms, and (4) repre-
sents the inferred programs in a DSL, which can capture a wide range of programs
that access databases.
Stateless Model Extraction. Model extraction algorithms use queries to con-
struct representations for programs, where the representations are stateless functions
such as decision trees [151, 59] or symbolic rules [150]. Model compression algorithms
[39, 88] use machine learning models, such as neural networks, to mimic a machine
learning model, often by generating inputs (training data) and observing the outputs
from the given model. Our approach, in contrast, (1) infers stateful models that re-
trieve data across multiple queries and (2) regenerates a new program or programs,
augmented as appropriate, that implement the core functionality on new implemen-
tation platforms.
Learning the Core Program Functionality. Our previous research produced
active learning techniques for black-box inference of programs that manipulate key/-
value maps [126] and string-processing libraries [154].Konure and Shear, in con-
trast, also observe database traffic, work with broader and more expressive classes of
applications, and deploy top-down, syntax-guided inference algorithms (as opposed
to enumerating store/retrieve pairs as in [126]). Our previous research also produced
an active learning technique that infers in-memory data structure accesses in certain
38
Python programs, models these accesses with database queries, and uses database
implementations instead of the in-memory data structures to regenerate the pro-
grams [45, 167]. Konure and Shear, in contrast, observe the use of an existing
external database, work with programs implemented in any programming language,
and guarantee sound and complete inference for programs in theKonure and Shear
DSLs (as opposed to providing probabilistic correctness properties as in [45, 167]).
Shear also differs from all these techniques in that it manipulates the program exe-
cution in addition to observing it.
Oracle-guided synthesis as implemented in Brahma [92] interacts with a program
to infer a model that completely captures the behavior of the program. Brahma
implements oracle-guided synthesis for loop-free programs that compute functions of
finite-precision bit-vector inputs. Brahma finitizes the synthesis problem by work-
ing with a finite set of components, with each component used exactly once in the
synthesized model. Our approach, in contrast, works with an unbounded space of
programs that may contain nested control flow and loops that iterate over the results
of database queries. Brahma adopts a flat, solver-based approach that repeatedly 1)
generates two programs that both satisfy the current set of input/output pairs, 2)
generates a new input that distinguishes the two programs, 3) queries an oracle to
find the correct output for the new input, and 4) adds the resulting input/output pair
to the current set of input/output pairs. Brahma terminates when there is only one
program that satisfies the set of input/output pairs. Our approach, in contrast, main-
tains a structured representation that captures the inferred program structure. Our
approach deploys an inference algorithm guided by assumptions about the inferrable
program behavior defined as a DSL. In particular,Konure and Shear maintain a
sentential form that captures all remaining possible models and refines the hypothesis
by generating inputs and database configurations to determine which production to
apply to the current nonterminal in the sentential form. This structured approach is
very efficient when narrowing down an unbounded space of programs.
Mimic [87] traces the memory accesses of an opaque function to synthesize a
model of the traced function. It uses a random generate-and-test search over a space
39
of programs generated by code mutation operators, with a carefully designed fitness
function measuring the degree to which the current model matches the observed
memory traces. Input generation heuristics are used to find inputs that work well
with the mutation operators and fitness function to find suitable code models. There
is no guarantee that the generated model is correct or that the search will find a
model if one exists. Mimic was applied to infer models for the Java Arrays.prototype
computations, successfully inferring models for 12 of these computations. In contrast,
our approach targets a different class of computations, which enables it to deploy an
algorithm that is guaranteed to infer a model if the application conforms to the
required domain.
LearningSpecificAspectsofProgramBehavior. ALPSusesactivelearningto
prune the search space for synthesizing Datalog programs, which consist of rules [139].
Konure andShear, incontrast, workwithdatabaseprogramsthatcontaindatabase
queries, value references, and nested control flow.
Other related techniques include an active learning technique for learning commu-
tativity specifications of data structures [74], a technique for learning program input
grammars [27], a technique for learning points-to specifications [28], a technique for
learning models of the design patterns that Java computations implement [90], a
technique for learning classifiers for event-transition behavior [36], and a technique
for inferring the input parsing functionality of programs [45]. UnlikeKonure and
Shear, all of these techniques focus on characterizing specific aspects of program
behavior and do not aspire to capture the complete behavior of the application.
Other areas of programming language research have also used active learning,
such as for ranking relevant code [161], ranking anomaly reports [106], and improving
candidate assertions [115].
Generating Inputs to Discover Defects.Concolic testing [132, 75, 44, 76] gen-
erates inputs that systematically explore all execution paths in the program. The goal
is to find inputs that expose software defects. BuzzFuzz [73] generates inputs that
40
target defects that occur because of coding oversights at the boundary between appli-
cation and library code. DIODE [140] generates inputs that target integer overflow
errors. All of these techniques dynamically analyze the execution of the program and
use the resulting information to guide the input generation. They all target programs
written in general-purpose languages such as C. Given the complexity and generality
of computations as expressed in this form, completely exploring and characterizing
application behavior is infeasible in this context. Simian [33] synthesizes multi-client
interactions to trigger defects such as conflicts in collaborative web applications. Our
approach, in contrast, (1) works with the given implementation as a black box, with-
out analyzing code, (2) works with applications whose behavior can be productively
modeled with programs in our DSL, (3) infers a model that captures the complete
core functionality of the program, and (4) regenerates a new program or programs,
augmented as appropriate, that implement the core functionality without defects or
security vulnerabilities on new implementation platforms.
2.2 Program Synthesis
The vast majority of program synthesis research works with a given set of input/out-
put examples [145, 68, 91, 170, 116, 69, 31, 20, 67, 164, 82, 65, 117, 171, 172, 158, 141,
80, 77, 35, 113]. Because the examples typically underspecify the program behavior,
there are often many programs that satisfy the examples. The synthesized program
is therefore typically selected according to either the choices the solver makes [91] or
a heuristic that ranks synthesized programs (for example, ranking shorter programs
above longer programs) [69, 82, 65]. Our approach, in contrast, uses active learning
and speculative manipulation to reverse engineer an existing program (in effect using
the original program as a specification), without requiring user interaction and is not
restricted to a limited set of training data. Because this approach is not constrained
by a given set of input/output pairs, it can select the inputs the inputs and database
contents that purposefully target and resolve ambiguities, eliminate uncertainty, and
obtain a model that completely captures the core application functionality. Another
41
key difference is that our approach is designed for generating better implementations
after modeling the core functionality of the original implementation. Our approach
therefore does not aim at strictly following all details of the specification (i.e., the
original implementation). This design can be especially valuable for tolerating noise,
such as corner cases overlooked by developers, in the original implementation.
Other synthesis techniques often involve solving constraints [94, 81], applying
templates [145, 148, 147], or using hypothetical I/O oracles [92] to solve for pro-
grams that satisfy the specification. These techniques do not work with existing
implementations, but require abstract specifications in other forms. Our approach,
in contrast, (1) works with a concrete program implementation rather than abstract
specifications, which can be especially useful for regenerating new implementations
for legacy software, (2) actively and automatically executes the given implementation
as needed to infer the core functionality, without requiring user interaction and is not
restricted to a limited set of training data, (3) can work with programs with defects
or that only partially implement the core functionality, and (4) automatically regen-
erates a new program or programs, augmented as appropriate, that implement the
core functionality without defects or security vulnerabilities on new implementation
platforms.
SyGus [20] identifies a range of program synthesis problems for which it is pro-
ductive to structure the search space as a domain-specific language and presents a
framework for this approach. Our approach similarly uses a domain to structure
the search space. Unlike the examples presented in [20], our approach exploits the
structure of the domain to obtain an inference algorithm that uses active learning to
progressively refine the knowledge of the program structure. In particular,Konure
and Shear deploy top-down inference algorithms that progressively refine a working
hypothesis represented as a sentential form of the DSL grammar. Unlike the vast
majority of solver-driven synthesis algorithms (which require finite search spaces),
Konure and Shear work effectively with an unbounded space of models.
LaSy works with a sequence of user-provided input/output pairs to iteratively
generalize an overspecialized program [113].Konure, in contrast, (1) automatically
42
generates a sequence of inputs and database contents that uniquely identify the pro-
gram within the DSL, (2) observes not just inputs and outputs, but also the traffic
between the database and the application, and (3) uses a top-down approach that
iteratively resolves DSL grammar nonterminals as opposed to a bottom-up approach
that replaces overspecialized code fragments.
Synthesizing Loops, Regular Expressions, and Recursions. In contrast to
othersystemsthatsynthesizeloopsbyobservingexecutionsofanexistingprogram[32,
87, 118, 64],Shear (1) performs speculative manipulation to obtain fine-grained in-
teractive feedback, (2) fully and precisely identifies loop structures in the program,
and (3) constructs the loop structures modularly, without requiring enumerative
search.
A fundamental difference betweenShear and existing regular expression synthe-
sis techniques is thatShear performs speculative manipulation to obtain an efficient
modular constructive synthesis algorithm. There are two kinds of regular expres-
sion synthesis algorithms. Techniques that work only with positive and negative
examples [102, 51, 175] provide no guarantees that they will infer the exact regular
expression and rely on heuristics to deliver an ordered list of synthesized expressions.
Shear, in contrast, produces a single correct loop structure within theShear DSL.
Techniques that do deliver a single correct regular expression require the ability to
ask an oracle whether a candidate is correct [23].Shear does not need this oracle,
but instead works with an existing program.
Most other existing program synthesis techniques cannot explicitly synthesize the
precise loop structures that produce a specified repetition behavior. These techniques
work with loops in restricted ways. One approach used by these techniques is to use
parameterized templates that contain known loop or recursive structures, followed
by synthesizing loop-free expressions as parameters and synthesizing loop-free callers
that invoke these templates as sealed building blocks [145, 100, 18, 92, 144, 146].
Another approach is to synthesize recursive or iterative functions‚Äîsuch as map, filter,
fold, sum, and replace‚Äîthat apply on data structures‚Äîsuch as lists and trees‚Äîwith
43
known repetition boundaries [69, 142, 163, 14, 159, 80, 103, 50, 116, 111]. Yet another
approach is to rank multiple nonequivalent loop candidates with heuristics [87, 51,
102, 143, 101, 112, 175, 162].
Synthesizing Models of Loops from High-Level Execution Traces.Inferring
loops from repetitions has been a recurring problem in many areas, including pro-
gram synthesis, program comprehension, performance profiling, and protocol reverse
engineering. Prior systems that infer loops from program traces have used heuris-
tics to partially address the loop inference problem. These systems either (1) do not
attempt to fully identify the loop structure [87, 168, 41] or (2) impose restrictions
to avoid dealing with ambiguous repetitions [110, 135, 99, 64]. Mimic [87] uses a
probabilistic approach to rank candidate loops but does not guarantee identifying
the correct loops. Nero [168] uses instrumentation to identify where each loop it-
eration starts in the trace, but does not identify where the last loop iteration ends
unless it already knows the loop body. Dispatcher‚Äôs [41, 42] ‚Äúdynamic‚Äù loop detection
technique detects repetitions from traces using heuristics and does not accurately
determine where the loop ends in the trace. DaViS [110] uses heuristics to identify
possible nested queries from the SQL trace, where the loop body contains exactly
one SQL query. WebRobot [64] and Kobayashi‚Äôs [99] algorithms are based on repeti-
tions and would not work with programs that contain conditionals in a loop body or
ambiguous repetitive instructions. In contrast,Shear infers the full loop structure
unambiguously and removes many restrictions from prior work.
MemoryAddressTraceCompression. Manytechniquesidentifypotentialloops
in memory address traces, often to compress the traces for storage or to improve run-
timeperformanceofpredictedloops[66,40,97,127]. Thesetechniquesareoftenbased
on detecting linear progressions from the memory addresses in the traces.Shear, in
contrast, does not require knowledge of the internal memory layouts.
Synthesizing Loops Based on Static Analysis or Low-Level Program State.
There are many techniques that detect potential loops according to control flow
44
graphs, instruction addresses, memory addresses, stack frames, register values, taints,
or other forms of low-level runtime information [152, 109, 43, 41, 42, 129, 86, 47, 98,
107, 14, 52, 96, 49, 26, 15]. In contrast to these techniques, Shear does not re-
quire analyzing the source code or low-level runtime information. Our approach, in
contrast, observes only the SQL queries visible in the network traffic as the pro-
gram communicates with an external database. As a result Konure and Shear
works well with applications written in any language or any implementation styles,
as long as their externally observable behavior conforms to the corresponding DSL.
Our approach also regenerates a more sophisticated version of a whole program with
potentially added functionality.
2.3 Reverse Engineering
Techniques for Program Comprehension.There is a large body of research on
dynamic analysis for program comprehension, but (due to complicated logic of Web
technologies) relatively little of this research targets Web application servers [58, 22].
WAFA [17] analyzes Web applications, focusing on interactions between Web com-
ponents, using source code annotations. In contrast, Konure infers applications
without analyzing, modifying, or requiring access to source code.Konure works for
applications written in any language and can infer both Web and non-Web applica-
tions that interact with an external relational database.
DAViS [110] visualizes the data-manipulation behavior of an execution of a data-
intensive program. DAViS detects loops whose body contains only one query. Disco-
Tect [174] summarizes the software architecture of a running object-oriented system
as a state machine. They both analyze program behavior when processing certain
user-specified inputs. In contrast,Konure actively explores the execution paths of
the program by solving for inputs and database contents that enable it to infer the
application behavior.
45
Database Reverse Engineering. Database reverse engineering analyzes a pro-
gram‚Äôs data access patterns, often to reconstruct implicit assumptions of the database
schema [60, 56].Konure infers programs that interact with databases (and not the
structure of the database).
2.4 Code Translation, Refactoring, and Optimiza-
tion
SoftwareModernization. Softwaremodernization[72,46,128]analyzesthesource
code of a legacy program, translates the program into a high-level modeling lan-
guage, then uses this representation to generate a new program that implements the
functionality in a more modern language. The translation strictly follows syntactic
cues and usually requires human intervention. Our approach, in contrast, (1) works
with the given implementation without analyzing code and (2) regenerates an aug-
mented computation with additional error and security checks that implements the
core functionality with complex new software components that execute on modern
target platforms.
Partial Program Rejuvenation and Reengineering.Helium uses dynamic in-
strumentation to extract the functionality of computational stencil kernels embedded
within production binaries [107]. It then replaces the stencil kernel with a compu-
tation expressed in Halide [121]. The goal is to replace the legacy implementation
with a version optimized for modern computational platforms. Several other tech-
niques [52, 26, 96, 15] also rewrite fragments of programs that perform loops into
equivalent loop implementations to optimize the performance. Program fracture and
recombination [21] works with multiple applications to automatically find efficient, so-
phisticated, and/or robust implementations of subcomputations across applications,
then transfers subcomputations across implementations to maximize efficiency or ro-
bustness. A goal is to automatically replace simple code that executes on a single
machine with more complex code that operates on parallel or distributed computing
46
platforms. Our approach, in contrast, (1) models the full data-retrieval computation
and regenerates executable code, augmented as appropriate, (2) can work with in-
complete or buggy implementations of the original program, and (3) targets programs
that access databases.
Database program reengineering often involves analyzing the source code to pro-
duce equivalent but more efficient implementations [57, 52, 22]. In contrast, our
approach (1) does not require program instrumentation or static analysis, (2) does
not require the program to be written in specific languages or patterns, and (3)
regenerates a new executable program (instead of only transforming the individual
database queries).
Model-Driven Engineering. In model-driven engineering (MDE) [38, 131, 130],
developers specify functionality in high-level models, often using domain-specific lan-
guages or formalisms such as Unified Modeling Language (UML), which are then
used to generate low-level platform-dependent implementations. Use cases of MDE
include migrating software across different platforms [130] and automating the code
generation for CRUD (create/read/update/delete) applications [19, 122, 63]. Like the
regenerators presented in this paper, MDE code generators encapsulate the knowledge
of how to use specific computational platforms and enable the automatic generation
of code for multiple platforms. In contrast to having developers work directly with
high-level domain-specific models, our approach starts from an existing implemen-
tation, then infers the program functionality as a black box and regenerates a new
implementation.
Program refinement [166] is a software development strategy that gradually ex-
pands parts of a high-level implementation with more detailed versions.
47
48
Chapter 3
Konure: Active Learning for
Inference and Regeneration of
Applications that Access Databases
In this chapter, we first present an example that illustrates howKonure works. We
then present the design and implementation ofKonure, including an overview, the
Konure DSL, the core inference and regeneration algorithm, and other implemen-
tation details.
3.1 Example
We next present an example that illustrates howKonure infers and regenerates a
database-backed application. The example is a student registration system adapted
from an application written by an independent evaluation team hired by an agency
of the United States Government to evaluate techniques for detecting and nullifying
SQL injection attacks. The application was written in Java and interacts with a
MySQL database [165] via JDBC [123].
Command. Theapplicationimplementsthefollowingcommand: ‚Äú liststudentcourses
-s ùë† -p ùëù‚Äù, where the input parameterùë† denotes student ID andùëù denotes pass-
49
word. The application first checks whether the student with IDùë† has passwordùëù in
the database. If so, the application displays the list of courses for which this student
has registered, along with the teacher for each course. Figure 3-1 presents the main
implementation of this command, which invokes thepasswordCheck method in Fig-
ure 3-2 to check the student‚Äôs password against the database. This method passes the
input password to the database directly by string concatenation, causing the SQL
injection vulnerability.
Database. The database contains: (1) a student table, which contains student
ID (primary key), first name, last name, and password, (2) ateacher table, which
contains teacher ID (primary key), first name, and last name, (3) acourse table,
which contains course ID (primary key), name, course number, and teacher ID, and
(4) aregistration table, which contains student ID and course ID.
First Execution. The Konure inference algorithm configures an empty database,
then executes the application with the command ‚Äúliststudentcourses -s 0 -p
1,‚Äù which sets input parametersùë† and ùëù to 0 and 1, respectively. Konure uses a
transparent proxy (Figure 3-3) to observe the resulting database traffic, which the
proxy collects as theconcrete traceof the execution (Figure 3-5a). The query uses
the constant ‚Äô0‚Äô, which comes from the input parameterùë†, and retrieves no data
from the (empty) database. For this execution, the application produces no output.
Based on this information,Konure rewrites the concrete trace to replace concrete
values (such as‚Äô0‚Äô) withorigin locations, which identify the source of each value. The
result is a correspondingabstract trace(Figure 3-5b). This abstract trace contains a
query q1 that selects all columns from thestudent table. The selection criterion is
that the student ID must equal the input parameterùë†. Konure derives the origin
locations by matching concrete values in the concrete trace against input values and
values in the database.
Konure DSL. Figure 3-6 presents the (abstract) grammar for theKonure DSL.
A program consists of a sequence of Query statements potentially terminated by an If
50
public Set < Course > getRegistrationsForStudent ( final Config config )
throws SQLException {
final Student studentreg = getStudent ( config . getStudentId ());
final Set < Course > courses = new HashSet < Course >() ;
Connection conn = null ;
PreparedStatement stmt = null , stmt2 = null , stmt3 = null ;
ResultSet rs = null , rs2 = null , rs3 = null ;
try {
if (! passwordCheck ( studentreg , config . getPassword ())) {
System . err . println (" Incorrect Password ");
} else {
conn = new DataConnection (). initialize ();
stmt = conn . prepareStatement (" SELECT * FROM course c "
+ " JOIN registration r on "
+ "r. course_id = c.id WHERE r. student_id = ?");
stmt . setString (1 , studentreg . getId ());
rs = stmt . executeQuery ();
while (rs. next ()) {
final String id = rs. getString (1) ;
final String name = rs. getString (2) ;
final String limit = rs. getString (3) ;
final String courseNumber = rs. getString (4) ;
final String isOffered = rs. getString (5) ;
final String tid = rs. getString (6) ;
String fname = null ;
String lname = null ;
stmt3 = conn . prepareStatement (" Select firstname , lastname
from teacher where id = ?");
stmt3 . setString (1 , tid );
rs3 = stmt3 . executeQuery ();
while ( rs3 . next ()) {
fname = rs3 . getString (1) ;
lname = rs3 . getString (2) ;
}
final Course course = new Course (id , name , limit ,
courseNumber );
course . setOffered ( isOffered );
course . setTeacher ( new Teacher (tid , fname , lname ));
stmt2 = conn . prepareStatement (" SELECT count (*) FROM
registration WHERE course_id = ?");
stmt2 . setString (1 , id);
rs2 = stmt2 . executeQuery ();
while ( rs2 . next ()) {
final String totalEnrolled = rs2 . getString (1) ;
course . setTotalEnrolled ( totalEnrolled );
}
courses . add ( course );
} } } finally { closeResultSet (rs); closeResultSet ( rs2 );
closeStatement ( stmt ); closeStatement ( stmt2 ); conn . close (); }
return courses ;
}
Figure 3-1: Example command in Java
51
private boolean passwordCheck ( Student unregstudent , String password
) throws SQLException {
Connection conn = null ;
PreparedStatement stmt = null ;
ResultSet rs = null ;
try {
conn = new DataConnection (). initialize ();
stmt = conn . prepareStatement (" SELECT * FROM student WHERE id =?
AND password =‚Äô" + password +"‚Äô");
stmt . setString (1 , unregstudent . getId ());
rs = stmt . executeQuery ();
if (rs. next ()) {
return true ;
} else {
return false ;
}
} catch ( SQLException e) {
System . err . println (" sql error ");
} finally {
closeStatement ( stmt );
conn . close ();
}
return false ;
}
Figure 3-2: Example command in Java (continued)
DB
KonureInference Algorithm
KonureProxyNew program with same core functionality
Application main logic
Figure 3-3: TheKonure architecture, including a transparent proxy interposed be-
tween the application and the database to observe the generated database traffic.
52
Konure AppExecute
Algorithm
DB schemaInput parameter format
Outputs andintercepted SQL
Initial inputs and DB
Refine hypothesisChoose inputs and DB valuesOutputs andintercepted SQL
Inputs and DBExecute
Algorithm ExecuteInputs and DB
‚Ä¶ ‚Ä¶ ‚Ä¶
Refine hypothesisChoose inputs and DB values
Initial hypothesis
Figure 3-4: TheKonure active learning algorithm iteratively refines its hypothesis
to infer the application.
SELECT * FROM student WHERE id = ‚Äô0‚Äô
(a) Concrete trace from the first execution. The database is empty and the query retrieves
zero rows.
q1: select student .id , student .password , student .firstname , student .
lastname
where student .id = ùë†
(b) Abstract trace from the first execution, converted from the concrete trace in Figure 3-5a.
The conversion replaces the constant‚Äô0‚Äô with its origin location, the input parameterùë†.
Figure 3-5: First execution trace
53
Prog := ùúñ | Seq | If | For
Seq := Query Prog
If := if Query then Prog else Prog
For := for Query do Prog else Prog
Query := ùë¶ ‚Üê select Col+ where Expr ; print Orig*
Expr := true | Expr ‚àßExpr | Col = Col | Col = Orig
Col := ùë°.ùëê
Orig := ùë• |ùë¶.Col
ùë•, ùë¶‚ààVariable, ùë° ‚ààTable, ùëê ‚ààColumn
Figure 3-6: Grammar for theKonure DSL
or For statement. An If statement does not test an arbitrary condition ‚Äî it instead
only tests if the Query in the condition retrieves empty or nonempty data. Similarly,
a For statement does not iterate over an arbitrary list ‚Äî it instead iterates over the
rows in its Query, executing itselse clause if its Query retrieves zero rows. These
restrictions (among others, Section 3.3) are key to the inferrability of the DSL.
First Production. The first execution generated a single query (Figure 3-5a).
Konure determines if this query came from a Seq, If, or For statement as follows.
Working with the abstract trace in Figure 3-5b,Konure generates three sets of
constraints. Each set specifies input parameters and database contents. The first
set specifies that the query retrieves zero rows. The second specifies that the query
retrieves at least one row. The third specifies that the query retrieves at least two
rows. Konure invokes an SMT solver to obtain acontextfor each set of constraints.
Each context identifies inputs and database values that satisfy the constraints.
In the example the third set of constraints is unsatisfiable, because the query ac-
cesses the primary key and there is at most one row for each value of the primary key.
The first and second sets of constraints are satisfiable and therefore produce viable
contexts. Konure executes the application in each of these contexts. Figures 3-5a
and 3-7a present the recorded concrete traces; Figures 3-5b and 3-7b present the
corresponding abstract traces. These traces indicate that the observable behavior of
the application differs depending on whether the first Query retrieves no rows (Fig-
54
SELECT * FROM student WHERE id = ‚Äô5‚Äô
SELECT * FROM student WHERE id = ‚Äô5‚Äô AND password = ‚Äô6‚Äô
(a) Concrete trace from the second execution. The context is configured to ensure that the
first query retrieves at least one row.
q1: select student .id , student .password , student .firstname , student .
lastname
where student .id = ùë†
q2: select student .id , student .password , student .firstname , student .
lastname
where student .id = ùë† ‚àß student .password = ùëù
(b) Abstract trace from the second execution, converted from the concrete trace in Figure 3-
7a. The conversion replaces the constants‚Äô5‚Äô and ‚Äô6‚Äô with their origin locations, input
parameters ùë† and ùëù.
Figure 3-7: Second execution trace
if ùë¶1 ‚Üêselect student .id , student.password , student .firstname , student .
lastname
where student .id = ùë† then ùëÉ1 else ùëÉ2
Figure 3-8: Hypothesis after resolving the topmost Prog nonterminal to an If state-
ment.
ures 3-5a and 3-5b) or at least one row (Figures 3-7a and 3-7b).Konure concludes
that the first Query comes from an If statement and produces the first hypothesis in
Figure 3-8. This hypothesis corresponds to applying an If production to the topmost
Prog nonterminal.
Intuition. Recall that, in theKonure DSL (Figure 3-6), there are four potential
productions to apply for each Prog nonterminal: Prog:= ùúñ, Prog:= Seq, Prog:= If,
and Prog := For. Konure resolves each Prog nonterminal in turn by applying the
appropriate production. For the topmost Prog nonterminal, applying theùúñ produc-
tion would result in an empty program, which is incorrect because the program has
produced nonempty traces (Figures 3-5 and 3-7). Applying the Seq production would
result in a program that does not condition on the results of the first query (q1 in
Figures 3-5b and 3-7b), which is incorrect because the program behavior differs in
the first two traces ‚Äî the program terminates immediately after the first query in
the first trace (Figure 3-5) but continues execution after the first query in the second
55
trace (Figure 3-7). Applying the For production would result in a program that iter-
ates over the rows retrieved by the first query, which is incorrect because the query
retrieves at most one row, making iterations unobservable. The If production is the
only production that is consistent with the observed program behavior.
Second Production. Konure next resolves theùëÉ1 nonterminal in the first hy-
pothesis. Working with the abstract trace in Figure 3-7b,Konure generates three
sets of constraints that (1) force the first query (q1) to retrieve at least one row (this
constraint forces the application to execute thethen branch of the topmost If state-
ment) and (2) force the second query (q2) to retrieve no rows, at least one row, and
at least two rows, respectively. Once again, the first two sets of constraints produce
viable contexts; the third is unsatisfiable.
Figure 3-7a presents the trace from the execution in which the second query re-
trieves no rows; Figure 3-9a presents the trace from the execution in which the second
query retrieves at least one row. Because the traces differ (similarly to the above First
Production), Konure resolves the nonterminalùëÉ1 to an If statement. Figure 3-10
presents the resulting hypothesis.
Intuition. As with the topmost Prog nonterminal, theùëÉ1 nonterminal (Figure 3-
8) also has four potential productions: Prog := ùúñ, Prog := Seq, Prog := If, and
Prog := For. For ùëÉ1, applying the ùúñ production would result in a program with
an empty then branch (Figure 3-8), which is incorrect because the program has
produced traces that perform actions after the first query (q1 in Figures 3-7b and 3-
9b) retrieves nonempty data (Figures 3-7 and 3-9). Applying the Seq production to
ùëÉ1 would result in a program that does not condition on the results of the first query
in ùëÉ1 (q2 in Figures 3-7b and 3-9b), which is incorrect because the program behavior
differs in the second and the third traces ‚Äî the program terminates immediately
after the second query in the second trace (Figure 3-7) but continues execution after
the second query in the third trace (Figure 3-9). Applying the For production toùëÉ1
would result in a program that iterates over the rows retrieved by the first query in
56
SELECT * FROM student WHERE id = ‚Äô1‚Äô
SELECT * FROM student WHERE id = ‚Äô1‚Äô AND password = ‚Äô2‚Äô
SELECT * FROM course c JOIN registration r ON r. course_id = c.id
WHERE r. student_id = ‚Äô1‚Äô
(a) Concrete trace from the third execution. The context is configured so that the first and
second queries retrieve at least one row and the third query retrieves zero rows.
q1: select student .id , student .password , student .firstname , student .
lastname
where student .id = ùë†
q2: select student .id , student .password , student .firstname , student .
lastname
where student .id = ùë† ‚àß student .password = ùëù
q3: select course .id , course.name , course.course_number , course .
size_limit , course .is_offered , course .teacher_id , registration .
student_id , registration .course_id
where registration .course_id = course .id ‚àß registration .student_id
= ùë†
(b) Abstract trace from the third execution, converted from the concrete trace in Figure 3-
9a. The conversion replaces the constants‚Äô1‚Äô and ‚Äô2‚Äô with their origin locations, input
parameters ùë† and ùëù.
Figure 3-9: Third execution trace
if ùë¶1 ‚Üêselect student .id , student.password , student .firstname , student .
lastname
where student .id = ùë† then {
if ùë¶2 ‚Üêselect student .id , student.password , student .firstname , student .
lastname
where student .id = ùë† ‚àß student .password = ùëù
then ùëÉ3 else ùëÉ4 } else ùëÉ2
Figure 3-10: Hypothesis after resolvingùëÉ1 (Figure 3-8).
ùëÉ1, which is incorrect because the query retrieves at most one row, making iterations
unobservable. The If production is the only production that is consistent with the
observed program behavior.
Third Production. Konure next resolves the ùëÉ3 nonterminal. Working with
the abstract trace produced by the previous step (Figure 3-9b),Konure generates
constraints that force the application to executeùëÉ3, once again with zero, at least
one, or at least two rows retrieved by the first query inùëÉ3 (q3 in Figure 3-9b). The
solver generates viable contexts for all three sets of constraints. For the context with
at least two rows retrieved,Konure collects the trace in Figure 3-11.
57
In this execution the third query retrieves two rows. TheKonure loop detection
algorithm examines the trace, detects the repetitive pattern in the last four queries,
concludes that the application iterates over all of the rows retrieved from the third
query, and resolvesùëÉ3 to a For statement.
For this execution the application also produces theid and teacher_id columns
from the retrieved rows of the course table as output. The updated hypothesis
(Figure 3-12) therefore contains a Print statement that prints these values.
Intuition. As with the previous Prog nonterminals, theùëÉ3 nonterminal (Figure 3-
10) also has four potential productions: Prog := ùúñ, Prog := Seq, Prog := If, and
Prog := For. For ùëÉ3, applying the ùúñ production would result in a program with
an empty innerthen branch (Figure 3-10), which is incorrect because the program
has produced traces that perform actions after the second query (q2 in Figure 3-9b)
retrieves nonempty data (Figures 3-9 and 3-11). Applying the Seq production toùëÉ3
would result in a program that does not condition on the results of the first query in
ùëÉ3 (q3 in Figure 3-9b), which is incorrect because the program behavior differs in the
third and the fourth traces ‚Äî the program terminates immediately after the third
query in the third trace (Figure 3-9) but continues execution after the third query in
the fourth trace (Figure 3-11). The remaining two potential productions are If and
For. To choose the appropriate production,Konure obtains an execution where the
third query retrieves at least two rows (Figure 3-11). In this execution, the third
query retrieves two rows, followed by two repetitions of a set of two queries. Because
the row count matches the repetition count, the trace is consistent with a potential
For statement that iterates over the rows retrieved by the third query. We designed
the Konure DSL to restrict certain repetitive queries in the program (more detail
in Section 3.3), so that this repetition is plausible only whenùëÉ3 resolves to a For
statement.
Regeneration. Konure proceeds as above, systematically targeting and resolving
nonterminals in the hypothesis, until all of the nonterminals are resolved and it has
58
SELECT * FROM student WHERE id = ‚Äô3‚Äô
SELECT * FROM student WHERE id = ‚Äô3‚Äô AND password = ‚Äô4‚Äô
SELECT * FROM course c JOIN registration r ON r. course_id = c.id
WHERE r. student_id = ‚Äô3‚Äô
SELECT firstname , lastname FROM teacher WHERE id = ‚Äô16 ‚Äô
SELECT count (*) FROM registration WHERE course_id = ‚Äô12 ‚Äô
SELECT firstname , lastname FROM teacher WHERE id = ‚Äô11 ‚Äô
SELECT count (*) FROM registration WHERE course_id = ‚Äô7‚Äô
Figure 3-11: Concrete trace from an execution to resolveùëÉ3 (Figure 3-10). The third
query retrieves two rows. The final four queries are generated by a loop that iterates
over the retrieved two rows.
if ùë¶1 ‚Üêselect student .id , student.password , student .firstname , student .
lastname
where student .id = ùë† then {
if ùë¶2 ‚Üêselect student .id , student.password , student .firstname , student .
lastname
where student .id = ùë† ‚àß student .password = ùëù
then {
for ùë¶3 ‚Üêselect course .id , course.name , course.course_number , course .
size_limit , course .is_offered , course .teacher_id , registration .
student_id , registration .course_id
where registration .course_id = course .id ‚àß registration .
student_id = ùë†;
print ùë¶3.course .id ,ùë¶3.course .teacher_id
do ùëÉ5 else ùëÉ6 } else ùëÉ4 } else ùëÉ2
Figure 3-12: Hypothesis after resolvingùëÉ3 (Figure 3-10).
59
inferred a model of the command. It can then regenerate the command, inserting
security/safety checks as desired. Our currentKonure implementation regenerates
Python code using a standard SQL library to perform the database queries. Figure 3-
13 presents the regenerated code. Here, each function call
util.do_sql(conn, query, params)
performs a database query. The query is constructed by (conceptually) replacing
the variables inquery with the corresponding values specified inparams while sys-
tematically checking for errors in the SQL syntax. More concretely, the function
util.do_sql invokes
conn.execute(sqlalchemy.text(query), params)
which uses the SQLAlchemy library to ensure that the values inparams are passed to
the database appropriately [29]. This regeneration eliminates a seeded SQL injection
attack vulnerability present in the original program.
Noisy Specifications. Because the active learning algorithm, guided by the DSL,
tends to generate contexts that conform to common use cases,Konure can work pro-
ductively with programs that contain obscure corner-case bugs not exercised during
the inference [125, 105]. The SQL injection attack vulnerability present in the origi-
nal Student Registration application but discarded in the regeneration is an example
of just such an obscure corner case bug. We view such programs asnoisy specifica-
tions. Given the known challenges developers face when attempting to deliver correct
programs, we consider the ability ofKonure to work successfully with such noisy
specifications as a significant advantage of the overall approach.
Developer Understanding. In a deployed system, we expect that developers
would be given examples and documentation that outlines theKonure DSL and
the model of computation. We expect that this information, along with experience
using Konure, would enable developers to work productively withKonure using
programs written in their language of choice.
60
3.2 Design Overview
Konure infers two aspects of the program. Firstly, starting from a concrete trace
intercepted by the proxy (Figure 3-3),Konure locates the concrete values and infers
their origin locations. To infer the origin locations, Konure keeps track of the
concrete values that are available when the program performs each SQL query. To
disambiguate different origin locations that happen to hold the same concrete value in
an execution,Konure adopts a demand-driven approach. With the origin locations
inferred, Konure constructs an abstract trace.
Secondly, starting from the unstructured sequences of queries in traces,Konure
infers the underlying control flow in the program. This inference algorithm is con-
structive [24] ‚Äî instead of enumerating candidate solutions, the algorithm constructs
the solution progressively every timeKonure finds an interesting behavior of the
application. During inference,Konure maintains a hypothesis of what is currently
known about the program. The hypothesis is (conceptually) represented as a sen-
tential form in theKonure DSL, with nonterminals denoting hidden parts that are
left to infer. The algorithm starts with a Prog nonterminal as its initial hypothesis,
then progressively resolves Prog nonterminals until it completely infers the program.
The algorithm resolves each of the Prog nonterminals by applying an appropriate
production, that is, applying one of Prog:= ùúñ, Prog := Seq, Prog := If, and Prog
:= For (Figure 3-6). Konure chooses the appropriate production based on three
(potential) executions of the program, forcing a specific query to retrieve zero rows,
at least one row, and at least two rows, respectively. These three executions are suffi-
cient forKonure to uniquely determine the correct production for the current Prog
nonterminal. The inference proceeds by expanding nonterminals until it obtains a
complete program. AsKonure recursively traverses the paths through the program
as expressed in the DSL, it maintains path constraints that lead to the next part of
the program to infer. Instead of maintaining the current hypothesis as an explicit
sentential form,Konure represents the hypothesis implicitly in the data structures
and recursive structure of the inference algorithm as it executes.
61
3.3 Konure Domain-Specific Language
Konure infers application functionality that can be expressed in theKonure DSL.
3.3.1 DSL Overview
We deisgn theKonure DSL to precisely capture the programs that our technique
works with. A goal here is to balance between expressiveness and inferrability. We
outline the expressiveness in this section and defer the discussion on inferrability to
Sections 3.3.4 and 3.3.5.
The Konure DSL captures a range of data retrieval applications that work with
an external database. A user runs an application through interfaces such as command
line arguments or HTTP requests. When the application runs, it sends SQL queries
to the database, which retrieves data as requested. For many real-world applications,
such as forums, blogs, and inventory management systems, a significant part of their
core functionality is dedicated to retrieving data in this form. In practice, many of
these applications have multiple commands that access different parts of the database.
In this research we infer one command at a time, and we refer to each command as
a program.
Many of these programs share an interesting pattern: The data flow often mani-
fests as SQL queries, and the control flow largely depends on the query results. As
an example of conditional statements that depend on query results, a program may
first look up a user‚Äôs name in the database and then execute one of two branches,
that is, (1) if the user does not exist, then print an error and terminate or (2) if the
user exists, then perform more queries to look up more information. As an example
of loops that depend on query results, a program may first retrieve a list of articles
in the database, then repeatedly perform the same action on each of these articles.
When a program‚Äôs control flow largely depends on the database queries, the database
traffic during program execution may reveal much information about the program
functionality. TheKonure DSL is designed to capture data retrieval programs that
have this common pattern.
62
3.3.2 Preliminaries
To formally define the Konure DSL, we first define skeletons (Definition 3.3.1),
then describe the externally observable part of a program (Definition 3.3.2), and
finally define the DSL as a subset of programs in Prog (Figure 3-6) that satisfy two
additional restrictions (Definition 3.3.3 and Definition 3.3.4). For readability, we
present Definition 3.3.2 and Definition 3.3.3 here only at a high level and postpone
their formalization to Chapter 4.
Definition 3.3.1.The skeleton of a program ùëÉ ‚ààProg is a program that is syn-
tactically identical toùëÉ except for replacing syntactic components derived from the
Orig nonterminal (Figure 3-6) with an empty placeholder3. Figure 3-14 presents the
syntax for skeleton programs. We writeS for the set of skeleton programs,S = SProg.
For readability, we shall denote Prog elements (Figure 3-6) with uppercase letters,
except for variables such asùë•, ùë¶, and denoteS elements with lowercase letters.
We shall writeùúãSùëÉ for the skeleton of programùëÉ ‚ààProg; it is defined in Figure 3-
15. We use an overline, as inùê∂ and ùëÇ, to denote a list.
Clearly for any programùëÉ ‚ààProg, queryùëÑ ‚ààQuery, and expressionùê∏ ‚ààExpr,
we haveùúãSùëÉ ‚ààS, ùúãSùëÑ ‚ààSQuery, andùúãSùê∏ ‚ààSExpr.
Definition 3.3.2.For any programùëÉ ‚ààProg, ÃÉÔ∏ÄùëÉ is the semantically equivalent pro-
gram obtained fromùëÉ by discarding unreachable branches in If and For statements,
downgrading For statements with empty loop bodies or loop bodies that execute
at most once to If statements, and downgrading If statements with an unreachable
branch or two semantically equivalent branches to Seq statements. We present the
algorithms for this code transformation in Section 4.2.
Definition 3.3.3.For any programùëÉ ‚ààProg, T(ùëÉ) is the set of queries inùëÉ that
retrieve at least two rows in some execution.1 R(ùëÉ) is the set of all queriesùëÑ in
ùëÉ with two subsequent queriesùëÑ1 and ùëÑ2 such that ùëÑ1 immediately follows ùëÑ in
the program,ùëÑ1 does not appear as the first query of anelse branch of an If or For
statement, ùëÑ2 occurs afterùëÑ1 in the program, andùëÑ1 and ùëÑ2 have the same skeleton.
1A query will never retrieve more than one row if, for example, it selects rows that have a specific
primary key value.
63
D(ùëÉ) is a predicate that istrue if and only if the two branches of all conditional
statements inùëÉ start with queries with different skeletons (or one of the branches is
empty). We formally define the functionsT(¬∑), R(¬∑), andD(¬∑) in Section 4.3.
3.3.3 DSL Definition
We present the grammar for theKonure DSL in Figure 3-6. Each query in this
DSL performs an SQLselect operation that retrieves data from specified columns
in specified tables. Our current DSL supports SQLwhere clauses that select rows in
which one column has the same value as another column (Col = Col) or the samevalue
as a value in the context (Col = Orig). Selecting from multiple tables corresponds to
an SQL join operation. The query stores the retrieved data in a unique variable (ùë¶)
for later use. All variables must be defined before they are used.
The control flow in the DSL is directly tied to queries and their results. An If
statement first performs a query to retrieve data. If the query retrieves nonempty
data, it enters thethen branch, otherwise theelse branch. A For statement likewise
first performs a query. If the query retrieves nonempty data, the loop body executes
once for each row retrieved by the query. If the query retrieves empty data, execution
enters theelse branch.
To enable theKonure inference algorithm to effectively distinguish If statements
from Seq statements,Konure requires the two branches of each If statement to start
with queries that have different skeletons (or one of the branches must be empty). To
facilitate effective loop detection,Konure requires the first query after any query
that may retrieve multiple rows to have a skeleton that is distinct from all subsequent
queries. Konure also requires that the program have no nested loops.
The outcomes of executing a program consists of a concrete trace, which consists
of the intercepted SQL queries, and the output values produced by Print statements.
Each Print statement is associated with a query and only prints values retrieved by
its query.
Definition 3.3.4 (The Konure DSL). We define theKonure DSL as the set of
64
programs K ‚äÇProg defined as:
K = {ÃÉÔ∏ÄùëÉ |ùëÉ ‚ààProg, T( ÃÉÔ∏ÄùëÉ) ‚à©R( ÃÉÔ∏ÄùëÉ) = ‚àÖ, D( ÃÉÔ∏ÄùëÉ) = true}
The first restriction,T( ÃÉÔ∏ÄùëÉ) ‚à©R( ÃÉÔ∏ÄùëÉ) = ‚àÖ, states that if a query may retrieve multiple
rows from the database, then the next query does not share a skeleton with any
other subsequent query in the program. This restriction facilitates loop detection
by eliminating repeated queries that do not come from iterations of the same loop
(Section 3.4.2).2 The second restriction,D( ÃÉÔ∏ÄùëÉ) = true, states that the two branches
of any If statement inÃÉÔ∏ÄùëÉ must start with queries with different skeletons (or one of the
branches must be empty). Intuitively, this restriction enablesKonure to efficiently
distinguish Seq from If statements (Chapter 4).
We present several immediate extensions toK in Section 4.8.
Because of the focused expressive power of theKonure DSL, it is possible to
decide all relevant conditions statically, rewriteùëÉ to ÃÉÔ∏ÄùëÉ, and determine if ÃÉÔ∏ÄùëÉ ‚ààK.
Note that because programsùëÉ ‚ààK may reference values using distinct but semanti-
cally equivalent variables,K is not a true canonical form, i.e., there may be distinct
but semantically equivalent programs inK. It is possible, however, to eliminate such
equivalences by replacing each variable with the first semantically equivalent vari-
able to occur in the program. This transformation is implementable with an SMT
solver and eliminates distinct but semantically equivalent programs to deliver a true
canonical form for theKonure DSL.
3.3.4 Design Rationale
The DSL captures a wide range of applications that display data from a database by
retrieving data based on inputs and database contents. Meanwhile, these applications
are restrictive enough to be inferred efficiently.
Because the DSL directly ties the control flow to query results,Konure can
2Our implemented Konure prototype deploys a more sophisticated loop detection algorithm
that enables it to relax this restriction.
65
effectively observe the control flow execution by observing the database traffic (Fig-
ure 3-3). For example, the student registration program in Section 3.1 enters two
different branches in the first two executions, which is inferrable by comparing the
two corresponding traces (Figures 3-5 and 3-7).
Another benefit of tying the control flow to query results in the DSL is that
Konure can effectively force the program to execute down certain paths.Konure
achieves this goal by carefully choosing values for the inputs and the database so
that, whenKonure executes the program, the relevant queries retrieve appropriate
numbers of rows that lead to the path. For example, to force the student registration
program (Section 3.1) to enter a (potential) branch unvisited by the first execution
(Figure 3-5),Konure solves for a set of new input and database values to guarantee
that, in the second execution, the first query retrieves at least one row (Figure 3-7).
3.3.5 Expressiveness and Limitations
Konure works well with programs whose behavior conforms to theKonure DSL,
though the programs themselves can be implemented in any language or in any coding
style or methodology. Two key properties of theKonure DSL are that (1) the data
flow manifests as database queries, which are directly observable in the database
traffic, and (2) the control flow is directly tied to the query results.Konure takes
advantage of these properties to actively explore various paths in the program. The
outcome is an accurate inferred model of the program, and the inference algorithm
does not require an analysis of the source code or the binary of the program.
The Konure inference algorithm may not extend well to infer unknown con-
ditional expressions or arithmetic calculations in the program that are not directly
observable. Example programs include online-shopping applications, whose core func-
tionality often involve numeric calculations that are not implemented as database
query expressions. We discuss unsupported programs in Section 5.1.3. In general,
Konure is not designed to infer programs that cannot be captured by an inferrable
DSL.
Ontheotherhand, itisstraightforwardtoextend Konure tosupportapplications
66
with SQL queries that involve relational comparisons (besides equality and member-
ship checks), simple arithmetics, constants, or aggregate functions. It is straightfor-
ward because (1) we use an SMT solver that supports solving constraints involving
these operators and (2) the operators are directly present in the intercepted SQL
queries. Because experience with SMT solvers in other contexts shows that these
solvers readily support formulas with these kinds of operators and constraints, we do
not anticipate any significant performance issues with this extension. It is also possi-
ble to extendKonure to access not only the database traffic, but also other runtime
or descriptive information, of the program. For example, one could first statically
extract all of the constant values used in the program (binary or source code), then
take advantage of these known constants while inferring conditional checks. Another
way to extendKonure is to incorporate domain knowledge about computations that
are well known, widely used, and easy to reason about in the solver. Example com-
putations include standard string manipulations (such as concatenation, splitting,
and capitalizing), date and time conversions, and number translations. We anticipate
that adding these features would require only relatively small changes to the overall
framework of the inference algorithm.
3.4 Konure Inference Algorithm
We present theKonure inference algorithm (Algorithm 1) for a programùëÉ that
implements a single command. For programs with multiple commands, Konure
uses Algorithm 1 to infer each command in turn.
Recall that, conceptually, theKonure inference algorithm works with hypotheses
represented as sentential forms of the DSL grammar. The algorithm systematically
constructs inputs and database contents, runs the program, and observes the re-
sulting database traffic and outputs to resolve a selected nonterminal in the current
hypothesis.
Algorithm 1 configures an empty database, sets the parameters to distinct values,
invokes Algorithm 2 to run the program and obtain an initial trace, then invokes
67
Algorithm 6 to recursively infer the program. The inference algorithm works with
deduplicated annotated traces ùë° that record one iteration of each executed loop, so
that the structure of the trace matches the corresponding path through the program.
3.4.1 Notation
Before presenting the algorithms, we first define the relevant terminology and nota-
tion, including contexts, origin locations, concrete traces, abstract traces, annotated
traces, and path constraints.
Definition 3.4.1.A contextùúé = ‚ü®ùúéùêº, ùúéùê∑, ùúéùëÖ‚ü©‚àà Context contains value mappings for
the input parameters (ùúéùêº ‚ààInput), database contents (ùúéùê∑ ‚ààDatabase), and results
retrieved by database queries (ùúéùëÖ ‚ààResult):
ùúé ‚ààContext = Input √óDatabase √óResult
ùúéùêº ‚ààInput = Variable ‚ÜíValue
ùúéùê∑ ‚ààDatabase = Table ‚ÜíZ>0 ‚ÜíColumn ‚ÜíValue
ùúéùëÖ ‚ààResult = Variable ‚ÜíZ>0 ‚ÜíTable ‚ÜíColumn ‚ÜíValue
Value = Int ‚à™String
The input contextùúéùêº maps input parameter variablesùë• ‚ààVariable to concrete values.
The database contextùúéùê∑ maps database locations (identified by a table name, a row
number, and a column name) to concrete values. The results contextùúéùëÖ maps each
query result variable ùë¶ ‚ààVariable to a list of rows, with each value in each row
identified by the table and column from which it was retrieved.
Example 3.4.2.In Section 3.1, the first execution of the program (Figure 3-5) uses
the following context:
ùúé1 = ‚ü®{ùë† : ‚Äô0‚Äô, ùëù: ‚Äô1‚Äô}, {student : ‚àÖ, teacher : ‚àÖ, course : ‚àÖ, registration : ‚àÖ}, ‚àÖ‚ü©.
This context sets input parameters ùë† and ùëù to 0 and 1, respectively, and sets all
database tables to empty. The second execution (Figure 3-7) uses the following con-
68
text:
ùúé2 = ‚ü®{ùë† : ‚Äô5‚Äô, ùëù: ‚Äô6‚Äô},
{student : {1 : {id : ‚Äô5‚Äô, password : ‚Äô2‚Äô, firstname : ‚Äô3‚Äô, lastname : ‚Äô4‚Äô}},
teacher : ‚àÖ, course : ‚àÖ, registration : ‚àÖ}, ‚àÖ‚ü©.
This context sets input parametersùë† and ùëù to ‚Äô5‚Äô and ‚Äô6‚Äô, respectively, and sets the
student table to contain one row whose columnid equals the inputùë†.
Definition 3.4.3.An origin locationùëÇ ‚ààOrig in a programùëÉ ‚ààProg is an occur-
rence of a variableùë• or a columnùë¶.Col in a query resultùë¶.
Definition 3.4.4.For an origin locationùëÇ ‚ààOrig and a contextùúé = ‚ü®ùúéùêº, ùúéùê∑, ùúéùëÖ‚ü©‚àà
Context, ùúé(ùëÇ) denotes the result from looking upùëÇ in ùúé. Specifically, for an input
parameter ùë• ‚ààVariable, ùúé(ùë•) = ùúéùêº(ùë•). For a query result variable ùë¶ ‚ààVariable,
table ùë° ‚ààTable, and columnùëê ‚ààColumn, ùúé(ùë¶.ùë°.ùëê) = ùúéùëÖ(ùë¶)(ùë°)(ùëê). When a program
references a query result variable that holds multiple rows, they are referenced as a
list.
For a queryùëÑ ‚ààQuery, SQLùúé(ùëÑ) denotes the concrete queryùëÑ in SQL syntax:
SQLùúé(ùë¶ ‚Üêselect ùê∂ where ùê∏ ; print ùëÇ)
= SELECT ùê∂ FROM Join(ùê∂, ùê∏) WHERE SQLùúé(ùê∏)
SQLùúé(true) = true
SQLùúé(ùê∏1 ‚àßùê∏2) = SQLùúé(ùê∏1) AND SQLùúé(ùê∏2)
SQLùúé(ùê∂1 = ùê∂2) = (ùê∂1 = ùê∂2)
SQLùúé(ùê∂ = ùëÇ) =
‚éß
‚é™‚é®
‚é™‚é©
ùê∂ = ùúé(ùëÇ) if ùúé(ùëÇ) is a value
ùê∂ IN ùúé(ùëÇ) if ùúé(ùëÇ) is a list
where ùê∂, ùê∂1, ùê∂2 ‚ààCol, ùê∏, ùê∏1, ùê∏2 ‚ààExpr, ùëÇ ‚ààOrig, and ùë¶ ‚ààVariable. We use
an overline, as inùê∂ and ùëÇ, to denote a list. TheJoin(ùê∂, ùê∏) operation collects the
relevant tables inùê∂ to construct corresponding SQLJOIN operations, using the checks
69
in ùê∏ to construct the relevantON expressions.
ùúé(ùëÑ) denotes the result from evaluatingùëÑ in ùúé. Evaluating ùëÑ involves replacing
origin locations in ùëÑ with their values in ùúéùêº and ùúéùëÖ, rewriting the query in SQL
syntax (SQLùúé(ùëÑ)), then performing the SQL query onùúéùê∑. The query result contains
an ordered list of rows.|ùúé(ùëÑ)|denotes the number of rows inùúé(ùëÑ). ùëÑ.ùë¶ denotes the
variable that stores the retrieved data.ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùëß] denotes the new context after
updating ùúéùëÖ to mapùëÑ.ùë¶ to ùëß. When the new contentùëß is empty, we shall writeùúé for
ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üí‚àÖ].
Printùúé(ùëÑ) denotes the output fromùëÑ: if ùëÑ is of the form
‚Äúùë¶ ‚Üêselect ùê∂ where ùê∏ ; print ùëÇ‚Äù
then Printùúé(ùëÑ) = ùúé[ùë¶ ‚Ü¶‚Üíùúé(ùëÑ)](ùëÇ), whereùê∂ ‚ààCol, ùê∏ ‚ààExpr, andùëÇ ‚ààOrig.
Example 3.4.5. Following the notation in Example 3.4.2, we haveùúé1(ùë†) = ‚Äô0‚Äô,
ùúé1(ùëù) = ‚Äô1‚Äô, ùúé2(ùë†) = ‚Äô5‚Äô, and ùúé2(ùëù) = ‚Äô6‚Äô. Let ùëÑ1 be the first inferred query in
Figure 3-8, that is,
ùëÑ1 = ùë¶1 ‚Üêselect student.id, student.password, student.firstname,
student.lastname
where student.id = ùë† ; print [].
We have concrete queries:3
SQLùúé1 (ùëÑ1) = SELECT * FROM student WHERE id= ‚Äô0‚Äô,
SQLùúé2 (ùëÑ1) = SELECT * FROM student WHERE id= ‚Äô5‚Äô.
Moreover, ùúé1(ùëÑ1) = ‚àÖand |ùúé1(ùëÑ1)|= 0, consistent with the first example execution
3For brevity, we do not spell out the columns in theSELECT clause and the tables in theWHERE
clause.
70
(Figure 3-5a). Also,ùúé2(ùëÑ1) contains the row in thestudent table:
ùúé2(ùëÑ1) = ({student.id : ‚Äô5‚Äô, student.password : ‚Äô2‚Äô, student.firstname : ‚Äô3‚Äô,
student.lastname : ‚Äô4‚Äô}).
The row count|ùúé2(ùëÑ1)|= 1 is consistent with the second example execution, where
the first query is configured to retrieve at least one row (Figure 3-7a).
Definition 3.4.6.We denote theconcrete tracefrom executing a programùëÉ ‚ààProg
in contextùúé ‚ààContext as ùúé(ùëÉ) ‚ààCTrace (Figure 3-16a). A concrete trace consists
of the intercepted SQL traffic, specifically, the queries CQuery* and corresponding
retrieved rows CData*. Clearly for any queryùëÑ ‚ààQuery, expressionùê∏ ‚ààExpr, and
context ùúé ‚ààContext, we haveSQLùúé(ùëÑ) ‚ààCQuery andSQLùúé(ùê∏) ‚ààCExpr.
Figure 3-17 presents the rules for executing a program to obtain a concrete trace.
We shall write[ ùëû
ùëë ] for the concrete trace(ùëû ùëë) ‚ààCTrace. We write ¬∑@ ¬∑to denote
concatenating two lists into a list.
Remark. In addition to producing a trace of database traffic, the program execution
also produces outputs (CVal*) from evaluating Print statements withPrint¬∑(¬∑). As
presented, our algorithm (and associated soundness proof) does not work with Print
statements. Our implemented Konure prototype infers Print statements by corre-
lating values that appear in the output with values observed in the database traffic.
Recall that in theKonure DSL, each Print statement is associated with a query
and only prints values retrieved by its query. This restriction enablesKonure to
associate each Print statement with its corresponding query.
Example 3.4.7.Following the notation in Example 3.4.2 and Example 3.4.5, letùëÑ2
be the second inferred query in Figure 3-10, that is,
ùëÑ2 = ùë¶2 ‚Üêselect student.id, student.password, student.firstname,
student.lastname
where student.id = ùë† ‚àßstudent.password = ùëù ; print [].
71
Let hypothetical program
ùëÉ‚Ä≤= if ùëÑ1 then ùëÑ2 else ùúñ,
then executingùëÉ‚Ä≤ in ùúé1 would produce concrete trace:
ùúé1(ùëÉ‚Ä≤) = [ SELECT * FROM student WHERE id= ‚Äô0‚Äô
‚àÖ ] .
Executing ùëÉ‚Ä≤ in ùúé2 would produce concrete trace:
ùúé2(ùëÉ‚Ä≤) =
[Ô∏Å
SELECT * FROM student WHERE id= ‚Äô5‚Äô, SELECT * FROM student WHERE id= ‚Äô5‚Äô ‚àßpassword = ‚Äô6‚Äô
({student.id:‚Äô5‚Äô,student.password:‚Äô2‚Äô,student.firstname:‚Äô3‚Äô,student.lastname:‚Äô4‚Äô}), ‚àÖ
]Ô∏Å
.
These two concrete traces are consistent with the two example traces in Figure 3-
5a and Figure 3-7a, respectively. So far, the hypothetical programùëÉ‚Ä≤ is consistent
with the observed behavior of the example program (Section 3.1). However, the third
context in the example would causeùëÉ‚Ä≤ to behave inconsistently (Figure 3-9).
Definition 3.4.8. ùëÉ denotes the black box executable of a programùëÉ ‚ààProg, i.e.,
executing ùëÉ in contextùúé ‚ààContext produces the concrete traceùúé(ùëÉ). Note that
Konure does not access the source code ofùëÉ when it executes ùëÉ .
Definition 3.4.9.An abstract trace is the list of queries, along with their results,
that Konure generates from a concrete trace after replacing concrete values with
their origin locations and replacing SQL syntax with the syntax of abstract traces
(Figure 3-16b). An abstract trace contains abstract queries (AQuery*) and row counts
for each query (ùëü*). The main modifications from a concrete trace are to replace each
concrete value by its origin location and to summarize the retrieved data with row
counts.
To infer the origin locations,Konure maintains a context, which keeps track of
the concrete values available at each origin location in the input and result compo-
nents. One complication is the possibility that two distinct origin locations may hold
the same concrete value in an execution. When such ambiguities occur,Konure
adopts a demand-driven approach to obtain an unambiguous origin location (Sec-
72
tion 3.6). With the origin locations inferred, it is straightforward to rewrite the trace
syntax as an abstract trace.
Example 3.4.10.Following the notation in Example 3.4.7, the abstract trace for
ùúé1(ùëÉ‚Ä≤) is the same as Figure 3-5b, with a row count0. The abstract trace forùúé2(ùëÉ‚Ä≤)
is the same as Figure 3-7b, with row counts1, 0.
Definition 3.4.11.A query-result pair(ùëÑ, ùëü) has a queryùëÑ ‚ààQuery and an integer
ùëü ‚ààZ‚â•0 that counts the number of rows retrieved byùëÑ during execution. Converting
an abstract trace into a list of query-result pairs is straightforward.
Example 3.4.12.Following the notation in Example 3.4.7, the abstract trace for
ùúé1(ùëÉ‚Ä≤) converts into the following list of query-result pairs:ùëí1 = ( ùëÑ1, 0). The ab-
stract trace for ùúé2(ùëÉ‚Ä≤) converts into the following list of query-result pairs: ùëí2 =
(ùëÑ1, 1) , (ùëÑ2, 0).
Definition 3.4.13.A loop layout treefor a programùëÉ ‚ààProg is a tree that rep-
resents information about the execution of loops (Figure 3-18). Each node in the
loop layout tree is a query-result pair that corresponds to a query inùëÉ. Each node
represents whether a loop inùëÉ iterates over the corresponding query multiple times.
In particular, when a loop in ùëÉ iterates over a query multiple times, the query‚Äôs
corresponding node in the loop layout tree has multiple subtrees, with each subtree
corresponding to an iteration of the loop. We convert a list of query-result pairs into
a loop layout tree inDetectLoops, which we discuss below.
Example 3.4.14.Following the notation in Example 3.4.7, the loop layout tree for
ùëÉ‚Ä≤ executing inùúé1 is:
ùëô1 = (ùëÑ1, 0) %Nil.
The loop layout tree forùëÉ‚Ä≤ executing inùúé2 is:
ùëô2 = (ùëÑ1, 1) % ((ùëÑ2, 0) %Nil) .
Let ùëÑ3, ùëÑ4, ùëÑ5 be the inferred queries for the third, fourth, and fifth queries in
73
Figure 3-11, respectively. Let hypothetical program
ùëÉ‚Ä≤‚Ä≤= if ùëÑ1 then {if ùëÑ2 then {for ùëÑ3 do {ùëÑ4 ùëÑ5}else ùúñ}else ùúñ}else ùúñ.
Letùúé3 be the context for producing the example trace in Figure 3-11. When executing
ùëÉ‚Ä≤‚Ä≤ in ùúé3, the queriesùëÑ1, ùëÑ2, ùëÑ3 retrieve one, one, and two rows, respectively. The
loop that iterates overùëÑ3 is repeated twice. Letùëü41, ùëü51 be the row counts forùëÑ4, ùëÑ5
in the first iteration of the loop. Letùëü42, ùëü52 be the row counts forùëÑ4, ùëÑ5 in the second
iteration of the loop. The loop layout tree forùëÉ‚Ä≤‚Ä≤ executing inùúé3 is:
ùëô3 = (ùëÑ1, 1) %((ùëÑ2, 1) %((ùëÑ3, 2) ‚ü≥( (ùëÑ4, ùëü41) %((ùëÑ5, ùëü51) %Nil),
(ùëÑ4, ùëü42) %((ùëÑ5, ùëü52) %Nil)))).
Definition 3.4.15.An annotated traceis an ordered list of annotated query tuples.
Each tuple, denoted as‚ü®ùëÑ, ùëü, ùúÜ‚ü©, has three components obtained from a queryùëÑ ‚àà
Query. The first component is the queryùëÑ. The second component is the number
of rows retrieved byùëÑ during an execution. The third component is the annotated
information of whether a loop was found to iterate over data retrieved byùëÑ. If such
loop was found thenùúÜ is a nonnegative integer that indicates the iteration index. If
no such loop was found thenùúÜ = NotLoop. Each path from the root of the loop
layout tree to a leaf generates a corresponding annotated trace.
Example 3.4.16.Following the notation in Example 3.4.14, executingùëÉ‚Ä≤ in ùúé1 re-
sults in an annotated trace:
ùë°1 = ‚ü®ùëÑ1, 0, NotLoop‚ü©.
Executing ùëÉ‚Ä≤ in ùúé2 results in an annotated trace:
ùë°2 = ‚ü®ùëÑ1, 1, NotLoop‚ü©, ‚ü®ùëÑ2, 0, NotLoop‚ü©.
74
Executing ùëÉ‚Ä≤‚Ä≤ in ùúé3 results in two annotated traces:
ùë°31 = ‚ü®ùëÑ1, 1, NotLoop‚ü©, ‚ü®ùëÑ2, 1, NotLoop‚ü©, ‚ü®ùëÑ3, 2, 1‚ü©, ‚ü®ùëÑ4, ùëü41, NotLoop‚ü©,
‚ü®ùëÑ5, ùëü51, NotLoop‚ü©,
ùë°32 = ‚ü®ùëÑ1, 1, NotLoop‚ü©, ‚ü®ùëÑ2, 1, NotLoop‚ü©, ‚ü®ùëÑ3, 2, 2‚ü©, ‚ü®ùëÑ4, ùëü42, NotLoop‚ü©,
‚ü®ùëÑ5, ùëü52, NotLoop‚ü©.
Definition 3.4.17.A path constraint ùëä = ( ‚ü®ùëÑ1, ùëü1, ùë†1‚ü©, . . . ,‚ü®ùëÑùëõ, ùëüùëõ, ùë†ùëõ‚ü©), consists
of a sequence of queriesùëÑ1, . . . , ùëÑùëõ ‚ààQuery, row count constraintsùëü1, . . . , ùëüùëõ, and
boolean flagsùë†1, . . . , ùë†ùëõ. Eachùëüùëñ specifies the range of the number of rows in a query
result, denoted as one of(= 0), (‚â•1), or (‚â•2). Each ùë†ùëñ is true if a loop iterates
over the corresponding retrieved rows andfalse otherwise.
Example 3.4.18.In Section 3.1, the first execution does not impose any path con-
straints,
ùëä1 = Nil.
Following the notation in Example 3.4.14, the path constraint specifying thatùëÑ1
retrieves at least one row is:
ùëä2 = ‚ü®ùëÑ1, ‚â•1, false‚ü©.
The path constraint specifying thatùëÑ1, ùëÑ2 each retrieves at least one row is:
ùëä3 = (‚ü®ùëÑ1, ‚â•1, false‚ü©, ‚ü®ùëÑ2, ‚â•1, false‚ü©) .
Before knowing whether a loop iterates over the results ofùëÑ3, the path constraint
specifying that ùëÑ1, ùëÑ2, ùëÑ3 retrieve at least one, at least one, and at least two rows,
respectively, is:
ùëä4 = (‚ü®ùëÑ1, ‚â•1, false‚ü©, ‚ü®ùëÑ2, ‚â•1, false‚ü©, ‚ü®ùëÑ3, ‚â•2, false‚ü©) .
75
Afterknowingthataloopiteratesovertheresultsof ùëÑ3, thepathconstraintspecifying
that ùëÑ1, ùëÑ2, ùëÑ3, ùëÑ4 each retrieves at least one row is:
ùëä5 = (‚ü®ùëÑ1, ‚â•1, false‚ü©, ‚ü®ùëÑ2, ‚â•1, false‚ü©, ‚ü®ùëÑ3, ‚â•1, true‚ü©, ‚ü®ùëÑ4, ‚â•1, false‚ü©) .
Definition 3.4.19.We define the‚âÉoperator as follows:
ùëü ‚âÉ(= 0) =
‚éß
‚é™‚é®
‚é™‚é©
true if ùëü = 0
false otherwise
ùëü ‚âÉ(‚â•1) =
‚éß
‚é™‚é®
‚é™‚é©
true if ùëü ‚â•1
false otherwise
ùëü ‚âÉ(‚â•2) =
‚éß
‚é™‚é®
‚é™‚é©
true if ùëü ‚â•2
false otherwise
where ùëü ‚ààZ‚â•0.
Definition 3.4.20.A contextùúé ‚ààContext satisfies a path constraint
ùëä = (‚ü®ùëÑ1, ùëü1, ùë†1‚ü©, . . . ,‚ü®ùëÑùëõ, ùëüùëõ, ùë†ùëõ‚ü©)
if (1) a sequence of contexts ùúé1, . . . , ùúéùëõ ‚àà Context are updated according to the
evaluation of the queriesùëÑ1, . . . , ùëÑùëõ in ùúé and (2) |ùúéùëñ(ùëÑùëñ)|‚âÉ ùëüùëñ for all ùëñ = 1, . . . , ùëõ.
Specifically, the context sequence satisfiesùúé1 = ùúé and for allùëñ = 1, . . . , ùëõ‚àí1:
ùúéùëñ+1 =
‚éß
‚é™‚é®
‚é™‚é©
ùúéùëñ[ùëÑùëñ.ùë¶ ‚Ü¶‚Üíùúéùëñ(ùëÑùëñ)] if ùë†ùëñ = false or |ùúéùëñ(ùëÑùëñ)|= 0
ùúéùëñ[ùëÑùëñ.ùë¶ ‚Ü¶‚Üíùúéùëñ(ùëÑùëñ)[ùëòùëñ]] if ùë†ùëñ = true and |ùúéùëñ(ùëÑùëñ)|‚â• 1
for some integerùëòùëñ such that if|ùúéùëñ(ùëÑùëñ)|‚â• 1 then 1 ‚â§ùëòùëñ ‚â§|ùúéùëñ(ùëÑùëñ)|. We callùúéùëõ the
context after updatingùúé with ùëä.
A contextùúé ‚ààContext always satisfies the trivial path constraintùëä = Nil.
76
Example 3.4.21. Following the notation in Example 3.4.2, Example 3.4.14, and
Example 3.4.18, we have:
1. ùúé1 satisfies ùëä1 but does not satisfyùëä2, ùëä3, ùëä4,
2. ùúé2 satisfies ùëä1, ùëä2 but does not satisfyùëä3, ùëä4, and
3. ùúé3 satisfies ùëä1, ùëä2, ùëä3, ùëä4.
These results are consistent with how the example in Section 3.1 chooses contexts to
infer each production.
Definition 3.4.22.Origin locations ùëÇ1, ùëÇ2 ‚ààOrig are equivalent with respect to
path constraint ùëä, denoted as ùëÇ1 ‚â°ùëä ùëÇ2, if for any context ùúé ‚àà Context that
satisfies ùëä, ùëÇ1, ùëÇ2 hold the same values in the context after updatingùúé with ùëä.
Example 3.4.23.Following the notation in Example 3.4.5, Example 3.4.7, and Ex-
ample 3.4.18, we have:
ùë† ‚â°ùëä2 ùë¶1.student.id, ùëù Ã∏‚â°ùëä2 ùë¶1.student.password,
ùë† ‚â°ùëä3 ùë¶2.student.id, ùëù ‚â°ùëä3 ùë¶2.student.password.
Definition 3.4.24.Expressions ùê∏1, ùê∏2 ‚ààExpr are identical except for equivalent
variables with respect to path constraintùëä, denoted asùê∏1
.=ùëä ùê∏2, if all of their cor-
responding origin locations are equivalent with respect toùëä and all of the remaining
components are syntactically identical (Figure 3-19).
Queries ùëÑ1, ùëÑ2 ‚ààQuery are identical except for equivalent variables with respect
to path constraintùëä and variablesùëå1, ùëå2, denoted asùëÑ1
.=ùëä,ùëå1,ùëå2 ùëÑ2, if the following
conditions hold:
1. ùëÑ1 = ùë¶1 ‚Üêselect ùê∂ where ùê∏1 ; print ùëÇ1,
2. ùëÑ2 = ùë¶2 ‚Üêselect ùê∂ where ùê∏2 ; print ùëÇ2, and
3. ùê∏‚Ä≤
1
.=ùëä ùê∏2, where ùê∏‚Ä≤
1 is the expression obtained from ùê∏1 after replacing all
occurrences of variables inùëå1 with their counterparts inùëå2.
77
Informally, two queries are identical except for equivalent variables when, after renam-
ing variables and removing Print statements, the queries are syntactically identical
except for the use of different but equivalent origin locations.
Example 3.4.25.Following the notation in Example 3.4.7 and Example 3.4.18, let
ùëÑ‚Ä≤
2 be an alternative second inferred query in Figure 3-10, that is,
ùëÑ‚Ä≤
2 = ùë¶2 ‚Üêselect student.id, student.password, student.firstname,
student.lastname
where student.id = ùë¶1.student.id ‚àßstudent.password = ùëù ; print [],
then ùëÑ2
.=ùëä2,Nil,Nil ùëÑ‚Ä≤
2.
Definition 3.4.26.An annotated traceùë° = ‚ü®ùëÑ1, ùëü1, ùúÜ1‚ü©, . . . ,‚ü®ùëÑùëõ, ùëüùëõ, ùúÜùëõ‚ü©is consistent
with path constraintùëä, denoted asùë° ‚àºùëä, if the path specified inùëä is not longer
than ùë°, each query inùë° matches the corresponding query inùëä, and each row count
in ùë° matches the corresponding requirement inùëä:
ùë° ‚àºNil = true
ùë° ‚àº(‚ü®ùëÑ‚Ä≤
1, ùëü‚Ä≤
1, ùë†‚Ä≤
1‚ü©, . . . ,‚ü®ùëÑ‚Ä≤
ùëö, ùëü‚Ä≤
ùëö, ùë†‚Ä≤
ùëö‚ü©)
= ùëö ‚â§ùëõ ‚àß
(Ô∏Ä
‚àÄùëñ = 1, . . . , ùëö: ùëüùëñ ‚âÉùëü‚Ä≤
ùëñ ‚àßùëÑùëñ
.=ùëäùëñ,ùëåùëñ,ùëå ‚Ä≤
ùëñ ùëÑ‚Ä≤
ùëñ
)Ô∏Ä
where ùëäùëñ =
(Ô∏Ä
‚ü®ùëÑ‚Ä≤
1, ùëü‚Ä≤
1, ùë†‚Ä≤
1‚ü©, . . . ,
‚ü®Ô∏Ä
ùëÑ‚Ä≤
ùëñ‚àí1, ùëü‚Ä≤
ùëñ‚àí1, ùë†‚Ä≤
ùëñ‚àí1
‚ü©Ô∏Ä)Ô∏Ä
contains the first(ùëñ ‚àí1) constraint
tuples inùëä, ùëåùëñ = (ùëÑ1.ùë¶, . . . , ùëÑùëñ‚àí1.ùë¶) is the list of variables defined by the first(ùëñ ‚àí1)
queries inùë°, andùëå ‚Ä≤
ùëñ =
(Ô∏Ä
ùëÑ‚Ä≤
1.ùë¶, . . . , ùëÑ‚Ä≤
ùëñ‚àí1.ùë¶
)Ô∏Ä
is the list of variables defined by the queries
in ùëäùëñ.
Example 3.4.27.Following the notation in Example 3.4.16 and Example 3.4.18, we
have ùë°1 ‚àºùëä1, ùë°2 ‚àºùëä1, ùë°31 ‚àºùëä1, ùë°32 ‚àºùëä1, ùë°1 Ã∏‚àºùëä2, ùë°2 ‚àºùëä2, ùë°31 ‚àºùëä2, ùë°32 ‚àºùëä2,
ùë°1 Ã∏‚àºùëä3, ùë°2 Ã∏‚àºùëä3, ùë°31 ‚àºùëä3, ùë°32 ‚àºùëä3, ùë°1 Ã∏‚àºùëä4, ùë°2 Ã∏‚àºùëä4, ùë°31 ‚àºùëä4, ùë°32 ‚àºùëä4,
ùë°1 Ã∏‚àºùëä5, andùë°2 Ã∏‚àºùëä5.
If we additionally have, for example,ùëü41 = 0, ùëü42 = 1, andùëü52 = 3, thenùë°31 Ã∏‚àºùëä5
and ùë°32 ‚àºùëä5.
78
Algorithm 1Infer an executable program
Input: ùëÉ is the executable of a programùëÉ ‚ààK.
Output: Program equivalent toùëÉ.
1: procedure Infer( ùëÉ )
2: ùúé ‚ÜêDatabase empty, input parameters distinct
3: ùë° ‚ÜêGetTrace( ùëÉ , Nil, ùúé)
4: return InferProg( ùëÉ , Nil, ùë°)
5: end procedure
Algorithm 2 Execute a program and deduplicate the trace according to a path
constraint
Input: ùëÉ is the executable of a programùëÉ ‚ààK.
Input: ùëä is a path constraint.
Input: ùúé is a context that satisfiesùëä.
Output: Annotated traceùë°, ùë° ‚àºùëä, from executing ùëÉ with ùúé.
1: procedure GetTrace( ùëÉ , ùëä, ùúé)
2: ùëí ‚ÜêExecute( ùëÉ , ùúé)
3: ùëô ‚ÜêDetectLoops(ùëí)
4: ùë° ‚ÜêMatchPath(ùëô, ùëä)
5: return ùë°
6: end procedure
3.4.2 Algorithm
We next present theKonure inference algorithm, which works with the black box
executable of a program (Algorithm 1).Konure executes the program using care-
fully chosen contexts that match certain path constraints. Each time the program
runs, it produces a concrete trace, from whichKonure constructs an abstract trace
and then an annotated trace (Algorithm 2). Conceptually,Konure follows anno-
tated traces to traverse paths in the program, assuming that the program belongs to
the Konure DSL (Section 3.3).Konure recursively infers the program by choosing
the appropriate production to resolve each nonterminal of the DSL program (Algo-
rithm 6).
Infer: Algorithm 1 takes an executable programùëÉ . It first configures an initial
context ùúé where all database tables are empty and the input parameters are distinct.
It then invokesGetTrace, which executes ùëÉ in contextùúé and returns an initial
annotated trace ùë°. Finally, Infer invokes the mainKonure inference algorithm,
79
InferProg, to inferùëÉ.
Example 3.4.28.In Section 3.1,Konure invokes Infer to infer the example pro-
gram. To execute the program for the first time,Konure uses the initial context
in variableùúé, which equalsùúé1 in Example 3.4.2. The resulting trace (Figure 3-5) is
converted into an annotated trace, variableùë°, which equalsùë°1 in Example 3.4.16.
GetTrace: Algorithm 2 takes an executable program ùëÉ , path constraint ùëä,
and contextùúé as parameters. It first invokesExecute, which runs ùëÉ in contextùúé
to obtain the flat listùëí of query-result pairs converted from the concrete trace that
ùëÉ generates when it runs. It then invokesDetectLoops, which runs theKonure
loop detection algorithm to produce the loop layout treeùëô. Finally, MatchPath
generates an annotated trace that corresponds to a path throughùëô consistent with
the path constraintùëä.
Execute: TheExecute proceduretakesanexecutableprogram ùëÉ andacontext
ùúé = ‚ü®ùúéùêº, ùúéùê∑, ùúéùëÖ‚ü©‚àà Context. It first populates the database with contents specified
in ùúéùê∑ and then executes ùëÉ with input parameters specified inùúéùêº. It collects the
outputs and database traffic, i.e., the concrete traceùúé(ùëÉ) (Figure 3-3). Execute
converts the concrete trace into an abstract trace, converts the abstract trace into a
list of query-result pairs, then returns this list of pairs.
Example 3.4.29.In Section 3.1, whenKonure executes the program for the first
time, it invokesExecute with contextùúé1 (Example 3.4.2).Execute configures the
database to empty and runs the program with inputs‚Äô0‚Äô and ‚Äô1‚Äô. This execution
results in the first concrete trace (Figure 3-5a) which equalsùúé1(ùëÉ‚Ä≤) in Example 3.4.7.
Execute converts the concrete trace into an abstract trace, described in Exam-
ple 3.4.10, and then into a list of query-result pairs that equalsùëí1 in Example 3.4.12.
DetectLoops: Algorithm 3 takes a list of query-result pairs and constructs a
loop layout tree. (1) If the first query retrievesùëü ‚â•2 rows, DetectLoops checks if
the skeleton of the second query is repeated exactlyùëü times in the tail of the trace.
If the repetitions match, DetectLoops determines that a loop iterates over the
80
first query in the trace, splits the trace intoùëü segments that each correspond to an
iteration of the loop, recursively constructs a loop layout tree for each segment, and
then inserts the recursively constructed loop layout trees as the children of the first
query. (2) In all other scenarios, DetectLoops determines that no loop iterates
over the first query in the trace, recursively constructs a loop layout tree for the tail
of the trace, and then inserts the recursively constructed loop layout tree as the child
of the first query of the trace.
Example 3.4.30.Following the notation in Example 3.4.12 and Example 3.4.14, we
have DetectLoops(ùëí1) = ùëô1 and DetectLoops(ùëí2) = ùëô2. Let ùëí3 be the list of
query-result pairs resulting from executingùëÉ‚Ä≤‚Ä≤ in ùúé3 (Example 3.4.14), that is,
ùëí3 = (ùëÑ1, 1) , (ùëÑ2, 1) , (ùëÑ3, 2) , (ùëÑ4, ùëü41) , (ùëÑ5, ùëü51) , (ùëÑ4, ùëü42) , (ùëÑ5, ùëü52) ,
then DetectLoops(ùëí3) = ùëô3.
MatchPath: Algorithm 4 takes a loop layout tree and a path constraint. The
procedure first callsGetAnnotatedTraceto convert the loop layout tree into a set
of annotated traces that each contains at most one iteration of any loop.MatchPath
then picks an annotated trace that is consistent with the given path constraint.
Example 3.4.31.Following the notation in Example 3.4.14 and Example 3.4.16, we
have
GetAnnotatedTrace(ùëô1) = {ùë°1},
GetAnnotatedTrace(ùëô2) = {ùë°2},
GetAnnotatedTrace(ùëô3) = {ùë°31, ùë°32}.
Note that the annotated tracesùë°31 and ùë°32 each contains only one iteration of the
loop, even though this loop is repeated multiple times.
81
Algorithm 3Loop detection algorithm
Input: ùëí is either Nil or a nonempty list of query-result pairs(ùëÑ1, ùëü1) , . . . ,(ùëÑùëõ, ùëüùëõ).
Output: Loop layout tree constructed fromùëí.
1: procedure DetectLoops(ùëí)
2: if ùëí = Nil then
3: return Nil
4: end if
5: (ùëÑ1, ùëü1) , . . . ,(ùëÑùëõ, ùëüùëõ) ‚Üêùëí
6: ùëé ‚Üêempty list
7: for ùëó ‚Üê2, 3, . . . , ùëõdo ‚óÅ Identify repetitions
8: if ùúãSùëÑùëó = ùúãSùëÑ2 then
9: Append ùëó to ùëé
10: end if
11: end for
12: if ùëü1 ‚â§1 or ùëü1 Ã∏= len(ùëé) then ‚óÅ Did not find repetitions caused by any loops that
iterate overùëÑ1
13: ùëí‚Ä≤‚Üê(ùëÑ2, ùëü2) , . . . ,(ùëÑùëõ, ùëüùëõ)
14: ùëô ‚ÜêDetectLoops(ùëí‚Ä≤)
15: return (ùëÑ1, ùëü1) %ùëô
16: else ‚óÅ Found a loop that iterates overùëÑ1
17: Append ùëõ + 1to ùëé
18: for ùëó ‚Üê1, 2, . . . , ùëü1 do
19: ùëè ‚Üêùëé[ùëó]
20: ùëê ‚Üêùëé[ùëó + 1]‚àí1
21: ùëí‚Ä≤‚Üê(ùëÑùëè, ùëüùëè) , . . . ,(ùëÑùëê, ùëüùëê)
22: ùëôùëó ‚ÜêDetectLoops(ùëí‚Ä≤)
23: end for
24: return (ùëÑ1, ùëü1) ‚ü≥(ùëô1, . . . , ùëôùëü1 )
25: end if
26: end procedure
Following the notation in Example 3.4.18, we have
MatchPath(ùëô1, ùëä1) = ùë°1,
MatchPath(ùëô2, ùëä2) = ùë°2,
MatchPath(ùëô3, ùëä3) = ùë°31
(or ùë°32, depending on the order in whichMatchPathenumerates the traces returned
from GetAnnotatedTrace), and
MatchPath(ùëô3, ùëä4) = ùë°31 (or ùë°32).
82
Algorithm 4Pick an annotated trace that is consistent with a path constraint
Input: ùëô is a loop layout tree.
Input: ùëä is a path constraint.
Output: Annotated trace constructed fromùëô that is consistent withùëä.
1: procedure MatchPath(ùëô, ùëä)
2: for ùë° in GetAnnotatedTrace(ùëô) do
3: if ùë° = Nil then
4: continue
5: end if
6: if ùë° ‚àºùëä then
7: return ùë°
8: end if
9: end for
10: return Nil
11: end procedure
Input: ùëô is a loop layout tree.
Output: Set of annotated traces constructed fromùëô.
12: procedure GetAnnotatedTrace(ùëô)
13: if ùëô = Nil then
14: return {Nil}
15: else ifùëô = (ùëÑ, ùëü) %ùëô‚Ä≤then
16: return {‚ü®ùëÑ, ùëü,NotLoop‚ü©@ ùë° |ùë° ‚ààGetAnnotatedTrace(ùëô‚Ä≤)}
17: else ifùëô = (ùëÑ, ùëü) ‚ü≥(ùëô‚Ä≤
1, ùëô‚Ä≤
2, . . . , ùëô‚Ä≤
ùëü) then ‚óÅ ùëü‚â•2
18: return ‚à™ùëü
ùëñ=1{‚ü®ùëÑ, ùëü, ùëñ‚ü©@ ùë° |ùë° ‚ààGetAnnotatedTrace(ùëô‚Ä≤
ùëñ)}
19: end if
20: end procedure
If we additionally have, for example, ùëü41 = 0 , ùëü42 = 1 , and ùëü52 = 3 , then
MatchPath(ùëô3, ùëä5) = ùë°32. In this case ùë°31 can no longer be returned, because
ùë°31 Ã∏‚àºùëä5 (Example 3.4.27).
MakePathConstraint: TheMakePathConstraintprocedure takes an an-
notated trace prefixùë°, a subsequent queryùëÑ ‚ààQuery, and an integerùëü ‚ààZ‚â•0. The
procedure constructs a new path constraint,ùëä, which specifies that any satisfying
context must enable the program to execute down the same path asùë°, then perform
query ùëÑ and retrieve a certain number of rows as specified byùëü. In particular, if
ùëü = 0 then ùëÑ is required to retrieve zero rows. Ifùëü = 1 or ùëü = 2 then ùëÑ is required to
retrieve at leastùëü rows. More concretely, for each annotated query tuple‚ü®ùëÑùëñ, ùëüùëñ, ùúÜùëñ‚ü©in
83
Algorithm 5Obtain a deduplicated annotated trace that satisfies a path constraint
Input: ùëÉ is the executable of a programùëÉ ‚ààK.
Input: ùëä is a path constraint.
Output: The first component represents the satisfiability of ùëä. When satisfiable, the
second component is an annotated traceùë° where ùë° ‚àºùëä.
1: procedure SolveAndGetTrace( ùëÉ , ùëä)
2: ùúé ‚ÜêSolve(ùëä)
3: if ùúé = Unsat then
4: return false, Nil
5: else
6: ùë° ‚ÜêGetTrace( ùëÉ , ùëä, ùúé)
7: return true, ùë°
8: end if
9: end procedure
ùë°, the procedure adds‚ü®ùëÑùëñ, ùëü‚Ä≤
ùëñ, ùë†‚Ä≤
ùëñ‚ü©to the path constraint whereùëü‚Ä≤
ùëñ =
‚éß
‚é™‚é®
‚é™‚é©
(= 0) if ùëüùëñ = 0
(‚â•1) if ùëüùëñ ‚â•1
and ùë†‚Ä≤
ùëñ = true if an only if previous recursions ofInferProg chose the production
‚ÄúProg := For‚Äù for the corresponding query. The procedure then adds‚ü®ùëÑ, ùëü‚Ä≤, false‚ü©
to the path constraint whereùëü‚Ä≤=
‚éß
‚é™‚é™‚é™‚é™‚é™‚é®
‚é™‚é™‚é™‚é™‚é™‚é©
(= 0) if ùëü = 0
(‚â•1) if ùëü = 1
(‚â•2) if ùëü = 2
.
Example 3.4.32.Following the notation in Example 3.4.14 and Example 3.4.18, we
have:
MakePathConstraint(Nil, ùëÑ1, 1) = ùëä2,
MakePathConstraint(‚ü®ùëÑ1, 1, NotLoop‚ü©, ùëÑ2, 1) = ùëä3,
MakePathConstraint((‚ü®ùëÑ1, 1, NotLoop‚ü©, ‚ü®ùëÑ2, 1, NotLoop‚ü©) , ùëÑ3, 2) = ùëä4.
InferProg: Algorithm6implementsthemain Konure inferencealgorithm. This
algorithm recursively explores all relevant paths through the program, resolving Prog
nonterminals as they are (conceptually) encountered. Algorithm 6 takes as parame-
ters the executableùëÉ of the program to infer and a split annotated trace consisting
84
of a prefixùë†1 that corresponds to an explored path through the program and a suffix
ùë†2 from the remaining unexplored part of the program. The first QueryùëÑ in ùë†2 is
generated by the next Prog nonterminal to resolve.Konure therefore determines
whether the queryùëÑ was generated by a Seq, If, or For statement, then recurses to
infer the remaining parts of the program.
Konure makes this determination by examining three deduplicated annotated
traces ùë°0, ùë°1, and ùë°2. All of these traces are from executions that follow the same path
to ùëÑ as ùë†1. In the execution that generatedùë°0, ùëÑ retrieves zero rows, in the execution
that generatedùë°1, ùëÑ retrieves at least one row, and in the execution that generated
ùë°2, ùëÑ retrieves at least two rows. IfKonure detects a loop inùë°2 over the rows thatùëÑ
retrieves, it infers thatùëÑ was generated by a For statement (line 14 in Algorithm 6).
Otherwise, it examinesùë°0 and ùë°1 to determine ifùëÑ was generated by an If statement
(line 20 in Algorithm 6) or a Seq statement (line 24 in Algorithm 6) ‚Äî conceptually,
if the queries that followùëÑ in ùë°0 and ùë°1 differ, thenùëÑ is generated by an If statement,
otherwise it is generated by a Seq statement.
Konure obtains tracesùë°0, ùë°1, and ùë°2 by usingMakePathConstraint to con-
struct three path constraintsùëä0, ùëä1, and ùëä2, then using an SMT solver to obtain
contexts ùúé0, ùúé1, andùúé2 that cause ùëÉ to produce (deduplicated annotated) tracesùë°0,
ùë°1, andùë°2 (Algorithm 5). Ifùëäùëñ is satisfiable thenùë°ùëñ ‚àºùëäùëñ.
Example 3.4.33.Consider the first execution of the example program in Section 3.1.
Infer invokes GetTrace with contextùúé1 (Example 3.4.28). The initial path con-
straint isùëä1 = Nil (Example 3.4.18).GetTrace invokesExecute with ùúé1, result-
ing in the list of query-result pairsùëí1 (Example 3.4.29). Recall from Example 3.4.30
thatDetectLoops(ùëí1) = ùëô1. RecallfromExample3.4.31that MatchPath(ùëô1, ùëä1) =
ùë°1. Hence ùë°1 is the initial annotated trace obtained fromGetTrace.
Infer then invokesInferProg with trace prefix Nil and trace suffixùë°1. The first
query in ùë°1 is ùëÑ1 (Example 3.4.16). InferProg invokes MakePathConstraint
three times, constructing three different path constraints. The first path constraint
85
specifies thatùëÑ1 retrieves zero rows:
MakePathConstraint(Nil, ùëÑ1, 0) = ‚ü®ùëÑ1, = 0, false‚ü©.
The second path constraint specifies thatùëÑ1 retrieves at least one row:
MakePathConstraint(Nil, ùëÑ1, 1) = ‚ü®ùëÑ1, ‚â•1, false‚ü©.
The third path constraint specifies thatùëÑ1 retrieves at least two rows:
MakePathConstraint(Nil, ùëÑ1, 2) = ‚ü®ùëÑ1, ‚â•2, false‚ü©.
InferProg then invokes SolveAndGetTrace to determine if these path con-
straints are satisfiable and, if so, obtain the corresponding annotated traces. In the
example (Section 3.1), the first path constraint results in the annotated traceùë°1. The
second path constraint results in the annotated traceùë°2 (Example 3.4.16). The third
path constraint is not satisfiable. Based on these results,InferProg applies the
‚ÄúProg := If‚Äù production to resolve the topmost Prog nonterminal.
Intuition. InferProg implements the core recursion of theKonure inference
algorithm. For any programùëÉ ‚ààK, each Prog nonterminal in the abstract syntax
tree of ùëÉ corresponds to a recursive call toInferProg as follows. Each step of
the recursion resolves a Prog nonterminal by applying the appropriate production,
that is, one of Prog:= ùúñ, Prog := Seq, Prog := If, and Prog := For (Figure 3-6).
The appropriate production is the (only) one that is consistent with the incoming
trace, ùë†1 @ ùë†2, as well as three other potential traces,ùë°0, ùë°1, and ùë°2. InferProg
recurses only after collecting sufficient information to uniquely determine the correct
production for the current Prog nonterminal. As a result, this recursion does not
need to backtrack.
Note that all of the traces used inInferProg are deduplicated annotated traces.
Because each annotated trace corresponds to a path through the program AST, the
86
length of the annotated trace is bounded by the code size ofùëÉ. Because each recursive
call toInferProg consumes a tuple in the incoming trace (ùë†1 @ ùë†2), the number of
recursive calls toInferProg is bounded by the maximum length of annotated traces,
which is bounded by the size ofùëÉ. AlthoughK can express arbitrarily large programs,
each program has a finite code size. Hence,Infer( ùëÉ ) terminates for any program
ùëÉ ‚ààK. We present these properties in Chapter 4.
3.5 Path Constraint Solver
Solve takes a path constraint ùëä and uses an SMT solver to solve for a context
ùúé ‚ààContext that satisfies ùëä. The procedure returns a satisfyingùúé if it exists and
returns ‚ÄúUnsat‚Äù otherwise.
Like many database test data generation approaches [54, 160, 155, 156, 83, 149],
Solve uses a row-based approach to translate path constraints into SMT formulas.
For each queryùëÑùëñ in ùëä that is required to retrieve at least one or at least two rows,
Solve generates variables that model the required number of rows of the relevant
tables. It then generates constraints that require the values of these variables to
satisfy the selection criteria ofùëÑùëñ. It also generates constraints that require primary
keys to be unique.
For each queryùëÑùëñ that is required to retrieve zero rows,Solve generates con-
straints that ensure that none of the values in the relevant tables satisfy the selection
criteria of ùëÑùëñ. If ùëÑùëñ occurs in a loop, the constraints only enforce thatùëÑùëñ retrieves
zero rows in at least one iteration of the loop (as opposed to always retrieving zero
rows). Here, loop iterations map easily to the rows of unknown variables, because
loops in theKonure DSL are designed to iterate over rows of data.
3.6 Origin Location Disambiguation
Recall that an origin locationùëÇ ‚ààOrig in a programùëÉ ‚ààProg is an occurrence of
a variableùë• or a column referenceùë¶.Col in ùëÉ. Concrete traces contain intercepted
87
def liststudentcourses (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT * FROM student WHERE id = :x0",
{‚Äôx0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s2 = util . do_sql (conn , " SELECT * FROM student WHERE id =: x0
AND password =: x1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äô student
‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs [1]})
if util . has_rows (s2):
s6 = util . do_sql (conn , " SELECT * FROM course c JOIN
registration r on r. course_id = c.id WHERE r.
student_id = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s2 , ‚Äô
student ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s6 , ‚Äô course ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äô course ‚Äô, ‚Äô teacher_id ‚Äô
))
outputs . extend ( util . get_data (s6 , ‚Äô registration ‚Äô, ‚Äô
course_id ‚Äô))
if util . has_rows (s6):
s6_all = s6
for s6 in s6_all :
s12 = util . do_sql (conn , " Select firstname ,
lastname from teacher where id = :x0", {‚Äôx0 ‚Äô
: util . get_one_data (s6 , ‚Äô course ‚Äô, ‚Äô
teacher_id ‚Äô)})
s13 = util . do_sql (conn , " SELECT count (*) FROM
registration WHERE course_id = :x0", {‚Äôx0 ‚Äô:
util . get_one_data (s6 , ‚Äô registration ‚Äô, ‚Äô
course_id ‚Äô)})
s6 = s6_all
else :
pass
else :
pass
else :
pass
return util . add_warnings ( outputs )
Figure 3-13: Konure infers the example command and regenerates code in Python
88
SProg := ùúñ | SSeq | SIf | SFor
SSeq := SQuery SProg
SIf := if SQuery then SProg else SProg
SFor := for SQuery do SProg else SProg
SQuery := 3‚Üê select SCol+ where SExpr ; print 3
SExpr := true | SExpr ‚àßSExpr | SCol = SCol | SCol = 3
SCol := ùë°.ùëê
ùë° ‚ààTable, ùëê ‚ààColumn, 3is a placeholder
Figure 3-14: Grammar for skeleton programs (S)
ùúãSùúñ = ùúñ
ùúãS(ùëÑ ùëÉ) =ùúãSùëÑ ùúãSùëÉ
ùúãS(if ùëÑ then ùëÉ1 else ùëÉ2) =if ùúãSùëÑ then ùúãSùëÉ1 else ùúãSùëÉ2
ùúãS(for ùëÑ do ùëÉ1 else ùëÉ2) =for ùúãSùëÑ do ùúãSùëÉ1 else ùúãSùëÉ2
ùúãS(ùë¶ ‚Üêselect ùê∂ where ùê∏ ; print ùëÇ) =3‚Üêselect ùê∂ where ùúãSùê∏ ; print 3
ùúãStrue = true
ùúãS(ùê∏1 ‚àßùê∏2) =ùúãSùê∏1 ‚àßùúãSùê∏2
ùúãS(ùê∂1 = ùê∂2) = (ùê∂1 = ùê∂2)
ùúãS(ùê∂ = ùëÇ) = (ùê∂ = 3)
ùëÉ, ùëÉ1, ùëÉ2 ‚ààProg, ùëÑ ‚ààQuery, ùê∂, ùê∂1, ùê∂2 ‚ààCol, ùê∏, ùê∏1, ùê∏2 ‚ààExpr, ùëÇ ‚ààOrig, ùë¶ ‚ààVariable
Figure 3-15: Calculating the skeleton of a program
89
CTrace := CQuery*CData*
CQuery := SELECT CCol+ FROM CJoin WHERE CExpr
CJoin := ùë° | CJoin JOIN ùë° ON CCol = CCol
CExpr := true | CExpr AND CExpr | CCol = CCol | CCol = CVal
| CCol IN CVal*
CCol := ùë°.ùëê
CVal := ùëñ |ùë†
CData := CRow*
CRow := ( CCol CVal)+
ùë° ‚ààTable, ùëê ‚ààColumn, ùëñ ‚ààInt, ùë† ‚ààString
(a) Concrete traces.
ATrace := AQuery*ùëü*
AQuery := ùë¶ ‚Üê select ACol+ where AExpr
AExpr := true | AExpr ‚àßAExpr | ACol = ACol| ACol ‚ààAOrig+
ACol := ùë°.ùëê
AOrig := ùë• |ùë¶.ACol
ùë•, ùë¶‚ààVariable, ùë° ‚ààTable, ùëê ‚ààColumn, ùëü ‚ààZ‚â•0
(b) Abstract traces.
Figure 3-16: Grammars for concrete and abstract traces.
90
ùúé(ùúñ) =
[Ô∏ÄNil
Nil
]Ô∏Ä (epsilon)
ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ)](ùëÉ) = [ùëû
ùëë ]
ùúé(ùëÑ ùëÉ) =
[Ô∏Å
SQLùúé(ùëÑ) @ùëû
ùúé(ùëÑ) @ùëë
]Ô∏Å (seq)
|ùúé(ùëÑ)|> 0 ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ)](ùëÉ1) = [ùëû
ùëë ]
ùúé(if ùëÑ then ùëÉ1 else ùëÉ2) =
[Ô∏Å
SQLùúé(ùëÑ) @ùëû
ùúé(ùëÑ) @ùëë
]Ô∏Å (if-1)
|ùúé(ùëÑ)|= 0 ùúé(ùëÉ2) = [ùëû
ùëë ]
ùúé(if ùëÑ then ùëÉ1 else ùëÉ2) =
[Ô∏Å
SQLùúé(ùëÑ) @ùëû
‚àÖ@ ùëë
]Ô∏Å (if-2)
ùúé(ùëÑ) = (ùë•1, . . . , ùë•ùëü) ùëü >0
ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùë•1](ùëÉ1) =
[Ô∏Äùëû1
ùëë1
]Ô∏Ä
. . . ùúé [ùëÑ.ùë¶ ‚Ü¶‚Üíùë•ùëü](ùëÉ1) =
[Ô∏Äùëûùëü
ùëëùëü
]Ô∏Ä
ùúé(for ùëÑ do ùëÉ1 else ùëÉ2) =
[Ô∏Å
SQLùúé(ùëÑ) @ùëû1 @ ... @ ùëûùëü
ùúé(ùëÑ) @ùëë1 @ ... @ ùëëùëü
]Ô∏Å (for-1)
|ùúé(ùëÑ)|= 0 ùúé(ùëÉ2) = [ùëû
ùëë ]
ùúé(for ùëÑ do ùëÉ1 else ùëÉ2) =
[Ô∏Å
SQLùúé(ùëÑ) @ùëû
‚àÖ@ ùëë
]Ô∏Å (for-2)
ùëÉ, ùëÉ1, ùëÉ2 ‚ààProg, ùëÑ ‚ààQuery, ùúé ‚ààContext, ùë¶ ‚ààVariable, ùëü ‚ààZ‚â•0
ùëû, ùëû1, . . . , ùëûùëü ‚ààCQuery, ùëë, ùëë1, . . . , ùëëùëü ‚ààCData, ùë• 1, . . . , ùë•ùëü ‚ààCRow
Figure 3-17: Semantics for executing a program using a context to obtain a concrete
trace
Tree := Nil |(ùëÑ, ùëü) %Tree|(ùëÑ, ùëü) ‚ü≥Tree*
ùëÑ ‚ààQuery, ùëü ‚ààZ‚â•0
Figure 3-18: Grammar for loop layout trees
91
true .=ùëä true (true) (ùê∂1 = ùê∂2) .=ùëä (ùê∂1 = ùê∂2) (col)
ùëÇ ‚â°ùëä ùëÇ‚Ä≤
(ùê∂ = ùëÇ) .=ùëä (ùê∂ = ùëÇ‚Ä≤) (orig) ùê∏1
.=ùëä ùê∏‚Ä≤
1 ùê∏2
.=ùëä ùê∏‚Ä≤
2
(ùê∏1 ‚àßùê∏2) .=ùëä (ùê∏‚Ä≤
1 ‚àßùê∏‚Ä≤
2) (and)
ùê∏1, ùê∏2, ùê∏‚Ä≤
1, ùê∏‚Ä≤
2 ‚ààExpr, ùê∂, ùê∂1, ùê∂2 ‚ààCol, ùëÇ, ùëÇ‚Ä≤‚ààOrig, ùëä is a path constraint
Figure 3-19: Check if two expressions are identical except for equivalent variables
with respect to a path constraint
92
Algorithm 6Recursively infer a subprogram
Input: ùëÉ is the executable of a programùëÉ ‚ààK.
Input: ùë†1 is a prefix of an annotated trace.
Input: ùë†2 is a suffix of an annotated trace.
Output: Subprogram equivalent toùëÉ‚Äôs subprogram after traceùë†1.
1: procedure InferProg( ùëÉ , ùë†1, ùë†2)
2: if ùë†2 = Nil then returnùúñ ‚óÅ Prog := ùúñ
3: end if
4: ùëò ‚ÜêThe length ofùë†1
5: ùëÑ ‚ÜêThe first query inùë†2
6: for ùëñ = 0, 1, 2 do
7: ùëäùëñ ‚ÜêMakePathConstraint(ùë†1, ùëÑ, ùëñ)
8: (ùëìùëñ, ùë°ùëñ) ‚ÜêSolveAndGetTrace( ùëÉ , ùëäùëñ)
9: if ùëìùëñ then ‚óÅ Satisfiable
10: ùë°ùëñ,1 ‚Üêùë°ùëñ[1, . . . ,(ùëò + 1)] ‚óÅ New trace prefix
11: ùë°ùëñ,2 ‚Üêùë°ùëñ[(ùëò + 2), . . .] ‚óÅ New trace suffix
12: end if
13: end for
14: if ùëì2 and found loop on the last query inùë°2,1 then
15: ùëèùë° ‚ÜêInferProg( ùëÉ , ùë°2,1, ùë°2,2)
16: if ùëì0 then ùëèùëì ‚ÜêInferProg( ùëÉ , ùë°0,1, ùë°0,2)
17: elseùëèùëì ‚Üêùúñ
18: end if
19: return ‚Äúfor ùëÑ do ùëèùë° else ùëèùëì ‚Äù ‚óÅ Prog := For
20: else ifùëì0 and ùëì1 and ((ùë°0,2 = Nil and ùë°1,2 Ã∏= Nil) or (ùë°0,2 Ã∏= Nil and ùë°1,2 = Nil) or
the first queries inùë°0,2 and ùë°1,2 have different skeletons)then
21: ùëèùë° ‚ÜêInferProg( ùëÉ , ùë°1,1, ùë°1,2)
22: ùëèùëì ‚ÜêInferProg( ùëÉ , ùë°0,1, ùë°0,2)
23: return ‚Äúif ùëÑ then ùëèùë° else ùëèùëì ‚Äù ‚óÅ Prog := If
24: else
25: if ùëì0 then ùëè ‚ÜêInferProg( ùëÉ , ùë°0,1, ùë°0,2)
26: elseùëè ‚ÜêInferProg( ùëÉ , ùë°1,1, ùë°1,2)
27: end if
28: return ‚ÄúùëÑ ùëè‚Äù ‚óÅ Prog := Seq
29: end if
30: end procedure
93
queries executed by the program. In these intercepted queries, the origin locations
have been replaced by the corresponding concrete values from the execution. When
Konure converts concrete traces into abstract traces, it restores the origin locations
by matching concrete values across query results and input parameters to translate
the concrete values back into their corresponding origin locations.
Because Konure uses a general SMT solver to obtain contextsùúé that satisfy
specified path constraintsùëä, the contexts may introduce ambiguity by coincidentally
generating the same value in different input parameters or database locations. This
ambiguity shows up as different origin locationsùëÇ1 and ùëÇ2 that both contain the
same concrete value to translate.Konure resolves the ambiguity as follows:
‚Ä¢ Konure first asks the solver if it is possible to reproduce the path to the
ambiguous concrete value with the additional constraint thatùëÇ1 and ùëÇ2 hold
disjoint values. If so, the resulting execution resolves the ambiguity.
‚Ä¢ Otherwise, Konure asks the solver if it is possible to reproduce this path with
the additional constraint thatùëÇ1 holds a value not inùëÇ2. If not, the values
in ùëÇ1 are a subset of the values inùëÇ2. Konure similarly uses the solver to
determine if the values inùëÇ2 are a subset of the values inùëÇ1. If ùëÇ1 and ùëÇ2 are
subsets of each other, they hold the same values andKonure can use either
origin location.
‚Ä¢ Otherwise, there exists an execution in whichùëÇ1 has at least one valueùë£ not in
ùëÇ2 (or vice-versa).Konure asks the solver to produce a context that generates
this execution. The resulting execution in this context resolves the ambiguity
‚Äî if the valueùë£ ever appears in the same location as the concrete value, then
Konure uses ùëÇ1 as the origin location, otherwise it usesùëÇ2.
94
Chapter 4
Soundness Proof ofKonure
Inthischapter, wefirstoutlinethestructureofasoundnessproofforthecore Konure
inference algorithm (Algorithm 1) and then provide the full proof. The proof is
structured as follows. Sections 4.2 and 4.3 elaborate on the transformation and the
functions that are used to define K in Section 3.3 (Definition 3.3.4). Section 4.4
proves Theorem 1. Section 4.5 proves Theorem 2. Section 4.6 proves Theorem 3 and
Theorem 4. Section 4.7 proves Theorem 5.
4.1 Soundness Proof Overview
Definition 4.1.1.Programs ùëÉ1, ùëÉ2 ‚ààProg are identical except for equivalent vari-
ables, denoted asùëÉ1
.= ùëÉ2, if they have the same control structures and if all of the
corresponding queries are identical except for equivalent variables with respect to the
paths that reach these queries (Figure 4-1).
Informally, two programs are identical except for equivalent variables when, after
renaming variables and removing Print statements, the programs are syntactically
identical except for the use of different but equivalent origin locations.
To simplify the presentation, when the context is clear, we writeùëÉ1
.= ùëÉ2 as a
shorthand forùëÉ1
.=ùëä,ùëå1,ùëå2 ùëÉ2 and writeùëÑ1
.= ùëÑ2 as a shorthand forùëÑ1
.=ùëä,ùëå1,ùëå2 ùëÑ2.
By default we keep track ofùëä, ùëå1, ùëå2 by traversing the program in the same manner
as in Figure 4-1.
95
ùëÉ .=Nil,Nil,Nil ùëÉ‚Ä≤
ùëÉ .= ùëÉ‚Ä≤ (full)
ùúñ .=ùëä,ùëå,ùëå ‚Ä≤ ùúñ (epsilon)
ùëÑ .=ùëä,ùëå,ùëå ‚Ä≤ ùëÑ‚Ä≤ ùëåùëÑ = ùëå @ ùëÑ.ùë¶ ùëå ‚Ä≤
ùëÑ = ùëå ‚Ä≤@ ùëÑ‚Ä≤.ùë¶ ùëÉ .=ùëä,ùëåùëÑ,ùëå ‚Ä≤
ùëÑ
ùëÉ‚Ä≤
ùëÑ ùëÉ .=ùëä,ùëå,ùëå ‚Ä≤ ùëÑ‚Ä≤ùëÉ‚Ä≤ (seq)
ùëä0 = ùëä @ ‚ü®ùëÑ‚Ä≤, = 0, false‚ü© ùëä1 = ùëä @ ‚ü®ùëÑ‚Ä≤, ‚â•1, false‚ü©
ùëåùëÑ = ùëå @ ùëÑ.ùë¶ ùëå ‚Ä≤
ùëÑ = ùëå ‚Ä≤@ ùëÑ‚Ä≤.ùë¶
ùëÑ .=ùëä,ùëå,ùëå ‚Ä≤ ùëÑ‚Ä≤ ùëÉ1
.=ùëä1,ùëåùëÑ,ùëå ‚Ä≤
ùëÑ
ùëÉ‚Ä≤
1 ùëÉ2
.=ùëä0,ùëåùëÑ,ùëå ‚Ä≤
ùëÑ
ùëÉ‚Ä≤
2
if ùëÑ then ùëÉ1 else ùëÉ2
.=ùëä,ùëå,ùëå ‚Ä≤ if ùëÑ‚Ä≤then ùëÉ‚Ä≤
1 else ùëÉ‚Ä≤
2
(if)
ùëä0 = ùëä @ ‚ü®ùëÑ‚Ä≤, = 0, true‚ü© ùëä1 = ùëä @ ‚ü®ùëÑ‚Ä≤, ‚â•1, true‚ü©
ùëåùëÑ = ùëå @ ùëÑ.ùë¶ ùëå ‚Ä≤
ùëÑ = ùëå ‚Ä≤@ ùëÑ‚Ä≤.ùë¶
ùëÑ .=ùëä,ùëå,ùëå ‚Ä≤ ùëÑ‚Ä≤ ùëÉ1
.=ùëä1,ùëåùëÑ,ùëå ‚Ä≤
ùëÑ
ùëÉ‚Ä≤
1 ùëÉ2
.=ùëä0,ùëåùëÑ,ùëå ‚Ä≤
ùëÑ
ùëÉ‚Ä≤
2
for ùëÑ do ùëÉ1 else ùëÉ2
.=ùëä,ùëå,ùëå ‚Ä≤ for ùëÑ‚Ä≤do ùëÉ‚Ä≤
1 else ùëÉ‚Ä≤
2
(for)
ùëÉ, ùëÉ1, ùëÉ2, ùëÉ‚Ä≤, ùëÉ‚Ä≤
1, ùëÉ‚Ä≤
2 ‚ààProg, ùëÑ, ùëÑ‚Ä≤‚ààQuery, ùë¶ ‚ààVariable,
ùëä, ùëä0, ùëä1 are path constraints, ùëå, ùëåùëÑ, ùëå‚Ä≤, ùëå‚Ä≤
ùëÑ ‚ààVariable
Figure 4-1: Check if two programs are identical except for equivalent variables
Definition 4.1.2.For a programùëÉ ‚ààProg and a contextùúé ‚ààContext, ùúé ‚ä¢ùëÉ ‚áìexec ùëí
denotes evaluatingùëÉ in ùúé to obtain a list of query-result pairsùëí. Figure 4-2 defines
this evaluation.
ùúé ‚ä¢ùëÉ ‚áìloops ùëô denotes evaluating ùëÉ in ùúé to obtain a loop layout tree ùëô (see
Definition 3.4.13). Figure 4-3 defines this evaluation.
Definition 4.1.3. For programs ùëÉ, ùëÉ‚Ä≤ ‚ààProg and annotated trace ùë°, we use the
notation ùëÉ
ùë°
‚àí ‚ÜíùëÉ‚Ä≤ to denote that traversing the AST ofùëÉ from top to bottom, by
following the row counts inùë°, leads to a subtreeùëÉ‚Ä≤. Figure 4-4 defines this traversal.
For loop layout treesùëô, ùëô‚Ä≤ and annotated trace ùë°, we use the notationùëô
ùë°
Àì‚àí ‚Üíùëô‚Ä≤ to
denote that traversingùëô from top to bottom, by following the row counts and loop
iteration numbers inùë°, leads to a subtreeùëô‚Ä≤. Figure 4-5 defines this traversal.
Definition 4.1.4.A path constraintùëä is derived froma programùëÉ ‚ààProg if one
of the following holds:
1. ùëä = Nil.
96
ùúé ‚ä¢ùúñ ‚áìexec Nil (epsilon)
ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ)] ‚ä¢ùëÉ ‚áìexec ùëí
ùúé ‚ä¢ùëÑ ùëÉ ‚áìexec (ùëÑ, |ùúé(ùëÑ)|) @ùëí (seq)
|ùúé(ùëÑ)|> 0 ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ)] ‚ä¢ùëÉ1 ‚áìexec ùëí
ùúé ‚ä¢if ùëÑ then ùëÉ1 else ùëÉ2 ‚áìexec (ùëÑ, |ùúé(ùëÑ)|) @ùëí (if-1)
|ùúé(ùëÑ)|= 0 ùúé ‚ä¢ùëÉ2 ‚áìexec ùëí
ùúé ‚ä¢if ùëÑ then ùëÉ1 else ùëÉ2 ‚áìexec (ùëÑ, 0) @ùëí (if-2)
ùúé(ùëÑ) = (ùë•1, . . . , ùë•ùëü) ùëü >0
ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùë•1] ‚ä¢ùëÉ1 ‚áìexec ùëí1 . . . ùúé [ùëÑ.ùë¶ ‚Ü¶‚Üíùë•ùëü] ‚ä¢ùëÉ1 ‚áìexec ùëíùëü
ùúé ‚ä¢for ùëÑ do ùëÉ1 else ùëÉ2 ‚áìexec (ùëÑ, ùëü) @ùëí1 @ . . .@ ùëíùëü
(for-1)
|ùúé(ùëÑ)|= 0 ùúé ‚ä¢ùëÉ2 ‚áìexec ùëí
ùúé ‚ä¢for ùëÑ do ùëÉ1 else ùëÉ2 ‚áìexec (ùëÑ, 0) @ùëí (for-2)
ùëÉ, ùëÉ1, ùëÉ2 ‚ààProg, ùëÑ ‚ààQuery, ùúé ‚ààContext, ùë¶ ‚ààVariable, ùëü ‚ààZ‚â•0, ùë• 1, . . . , ùë•ùëü ‚ààCRow
Figure 4-2: Semantics for executing a program using a context to directly obtain a
list of query-result pairs
2. ùëä = ‚ü®ùëÑ‚Ä≤, ùëü‚Ä≤, ùë†‚Ä≤‚ü©, ùëÉ Ã∏= ùúñ, andùëÑ‚Ä≤ .=Nil,Nil,Nil F(ùëÉ), whereF(ùëÉ) is the first query in
ùëÉ. We formally define the functionF(¬∑) in Section 4.3.
3. ùëä = (‚ü®ùëÑ‚Ä≤
1, ùëü‚Ä≤
1, ùë†‚Ä≤
1‚ü©, . . . ,‚ü®ùëÑ‚Ä≤
ùëö, ùëü‚Ä≤
ùëö, ùë†‚Ä≤
ùëö‚ü©), where ùëö ‚â•2, and there exists an anno-
tated traceùë° such that:
(a) ùëÉ
ùë°
‚àí ‚Üíùúñ,
(b) ùë° ‚àºùëä‚Ä≤, where ùëä‚Ä≤ =
(Ô∏Ä
‚ü®ùëÑ‚Ä≤
1, ùëü‚Ä≤
1, ùë†‚Ä≤
1‚ü©, . . . ,
‚ü®Ô∏Ä
ùëÑ‚Ä≤
ùëö‚àí1, ùëü‚Ä≤
ùëö‚àí1, ùë†‚Ä≤
ùëö‚àí1
‚ü©Ô∏Ä
, ‚ü®ùëÑ‚Ä≤
ùëö, ùëü‚Ä≤, ùë†‚Ä≤
ùëö‚ü©
)Ô∏Ä
for some row constraintùëü‚Ä≤, and
(c) for allùëñ = 1, . . . , ùëö‚àí1, ùë†‚Ä≤
ùëñ = true if and only if the corresponding element
in ùëÉ is afor-construct.
Definition 4.1.5.The size of a programùëÉ ‚ààProg is denoted as‚ÄñùëÉ‚Äñand defined
as the number of times that the AST ofùëÉ applies a production to expand a ‚ÄúProg‚Äù
nonterminal:
97
ùúé ‚ä¢ùúñ ‚áìloops Nil (epsilon)
ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ)] ‚ä¢ùëÉ ‚áìloops ùëô
ùúé ‚ä¢ùëÑ ùëÉ ‚áìloops (ùëÑ, |ùúé(ùëÑ)|) %ùëô (seq)
|ùúé(ùëÑ)|> 0 ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ)] ‚ä¢ùëÉ1 ‚áìloops ùëô
ùúé ‚ä¢if ùëÑ then ùëÉ1 else ùëÉ2 ‚áìloops (ùëÑ, |ùúé(ùëÑ)|) %ùëô (if-1)
|ùúé(ùëÑ)|= 0 ùúé ‚ä¢ùëÉ2 ‚áìloops ùëô
ùúé ‚ä¢if ùëÑ then ùëÉ1 else ùëÉ2 ‚áìloops (ùëÑ, 0) %ùëô (if-2)
ùúé(ùëÑ) = (ùë•1, . . . , ùë•ùëü) ùëü ‚â•2
ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùë•1] ‚ä¢ùëÉ1 ‚áìloops ùëô1 . . . ùúé [ùëÑ.ùë¶ ‚Ü¶‚Üíùë•ùëü] ‚ä¢ùëÉ1 ‚áìloops ùëôùëü
ùúé ‚ä¢for ùëÑ do ùëÉ1 else ùëÉ2 ‚áìloops (ùëÑ, ùëü) ‚ü≥(ùëô1, . . . , ùëôùëü) (for-1a)
|ùúé(ùëÑ)|= 1 ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ)] ‚ä¢ùëÉ1 ‚áìloops ùëô
ùúé ‚ä¢for ùëÑ do ùëÉ1 else ùëÉ2 ‚áìloops (ùëÑ, 1) %ùëô (for-1b)
|ùúé(ùëÑ)|= 0 ùúé ‚ä¢ùëÉ2 ‚áìloops ùëô
ùúé ‚ä¢for ùëÑ do ùëÉ1 else ùëÉ2 ‚áìloops (ùëÑ, 0) %ùëô (for-2)
ùëÉ, ùëÉ1, ùëÉ2 ‚ààProg, ùëÑ ‚ààQuery, ùúé ‚ààContext, ùë¶ ‚ààVariable, ùëü ‚ààZ‚â•0, ùë• 1, . . . , ùë•ùëü ‚ààCRow
Figure 4-3: Semantics for executing a program using a context to obtain a loop layout
tree
‚Äñùúñ‚Äñ= 1
‚ÄñùëÑ ùëÉ‚Äñ= 1 + ‚ÄñùëÉ‚Äñ
‚Äñif ùëÑ then ùëÉ1 else ùëÉ2‚Äñ= 1 + ‚ÄñùëÉ1‚Äñ+ ‚ÄñùëÉ2‚Äñ
‚Äñfor ùëÑ do ùëÉ1 else ùëÉ2‚Äñ= 1 + ‚ÄñùëÉ1‚Äñ+ ‚ÄñùëÉ2‚Äñ
where ùëÉ, ùëÉ1, ùëÉ2 ‚ààProg andùëÑ ‚ààQuery.
Proposition 4.1.6 (Solver). For any path constraintùëä, the procedureSolve(ùëä)
returns a contextùúé ‚ààContext if and only ifùëä is satisfiable.
Rationale. The path constraint solver outlined in Section 3.5 asks the SMT solver
a question that is equisatisfiable as the existence of a satisfying context. Since the
98
ùëÉ
Nil
‚àí‚àí‚ÜíùëÉ
(nil)
ùëÉ
ùë°
‚àí ‚ÜíùëÉ‚Ä≤ ùëÑ .= ùëÑ‚Ä≤
ùëÑ ùëÉ
‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©@ ùë°
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíùëÉ‚Ä≤
(seq)
ùëü >0 ùëÉ1
ùë°
‚àí ‚ÜíùëÉ‚Ä≤
1 ùëÑ .= ùëÑ‚Ä≤
if ùëÑ then ùëÉ1 else ùëÉ2
‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©@ ùë°
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíùëÉ‚Ä≤
1
(if-1)
ùëÉ2
ùë°
‚àí ‚ÜíùëÉ‚Ä≤
2 ùëÑ .= ùëÑ‚Ä≤
if ùëÑ then ùëÉ1 else ùëÉ2
‚ü®ùëÑ‚Ä≤,0,ùúÜ‚ü©@ ùë°
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíùëÉ‚Ä≤
2
(if-2)
ùëü >0 ùëÉ1
ùë°
‚àí ‚ÜíùëÉ‚Ä≤
1 ùëÑ .= ùëÑ‚Ä≤
for ùëÑ do ùëÉ1 else ùëÉ2
‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©@ ùë°
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíùëÉ‚Ä≤
1
(for-1)
ùëÉ2
ùë°
‚àí ‚ÜíùëÉ‚Ä≤
2 ùëÑ .= ùëÑ‚Ä≤
for ùëÑ do ùëÉ1 else ùëÉ2
‚ü®ùëÑ‚Ä≤,0,ùúÜ‚ü©@ ùë°
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíùëÉ‚Ä≤
2
(for-2)
ùëÉ, ùëÉ1, ùëÉ2, ùëÉ‚Ä≤, ùëÉ‚Ä≤
1, ùëÉ‚Ä≤
2 ‚ààProg, ùëÑ, ùëÑ‚Ä≤‚ààQuery, ùëü ‚ààZ‚â•0, ùúÜ ‚ààZ‚â•0 ‚à™{NotLoop}
Figure 4-4: Traverse a program by following an annotated trace, to obtain a subpro-
gram
logical formulas are quantifier-free and involve only equality checks, their satisfiability
is decidable, for example by first converting the formulas to disjunctive normal form
(DNF) and then checking each disjunct with a congruence closure algorithm [37]. Our
Konure prototype uses an off-the-shelf SMT solver, Z3 [61], that works efficiently
in practice.
Proposition 4.1.7 (Disambiguation). For any program ùëÉ ‚ààK and context ùúé ‚àà
Context, if ùúé ‚ä¢ùëÉ ‚áìexec ùëí, Execute( ùëÉ , ùúé) = ùëí‚Ä≤, and ùëí = ((ùëÑ1, ùëü1) , . . . ,(ùëÑùëõ, ùëüùëõ)),
then ùëí‚Ä≤= ((ùëÑ‚Ä≤
1, ùëü1) , . . . ,(ùëÑ‚Ä≤
ùëõ, ùëüùëõ)), whereùëÑùëñ
.= ùëÑ‚Ä≤
ùëñ for anyùëñ = 1, . . . , ùëõ.
Rationale. The disambiguation procedure (Section 3.6) asks the SMT solver a ques-
tion that equivalently encodes the relationship between origin locations. By Propo-
sition 4.1.6, we obtain a correct list of query-result pairs after disambiguating the
traces obtained from program execution.
99
ùëô
Nil
Àì‚àí ‚àí ‚Üíùëô
(nil)
ùëô
ùë°‚Ä≤
Àì‚àí ‚Üíùëô‚Ä≤ ùëÑ .= ùëÑ‚Ä≤
(ùëÑ, ùëü) %ùëô
‚ü®ùëÑ‚Ä≤,ùëü,NotLoop‚ü©@ ùë°‚Ä≤
Àì‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üíùëô‚Ä≤
(next)
1 ‚â§ùëñ ‚â§ùëü ùëô ùëñ
ùë°‚Ä≤
Àì‚àí ‚Üíùëô‚Ä≤ ùëÑ .= ùëÑ‚Ä≤
(ùëÑ, ùëü) ‚ü≥(ùëô1, . . . , ùëôùëü)
‚ü®ùëÑ‚Ä≤,ùëü,ùëñ‚ü©@ ùë°‚Ä≤
Àì‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üíùëô‚Ä≤
(iter)
ùëÑ, ùëÑ‚Ä≤‚ààQuery, ùëü, ùëñ ‚ààZ‚â•0
Figure 4-5: Traverse a loop layout tree by following an annotated trace, to obtain a
subtree
This proposition states that, afterKonure executes the program as a black box
and obtains an abstract trace, the resulting list of query-result pairs is equivalent to
the outcome from evaluating the source code as in Figure 4-2.
Theorem 1(Loop Detection). For any programùëÉ ‚ààK and contextùúé ‚ààContext, if
ùúé ‚ä¢ùëÉ ‚áìexec ùëí and ùúé ‚ä¢ùëÉ ‚áìloops ùëô then DetectLoops(ùëí) = ùëô.
Proof Sketch.By induction on the derivation ofùëÉ. We present a full proof in Sec-
tion 4.4.
This theorem states that DetectLoops correctly identifies repetitions in the
trace caused by loops in a program in K. In particular, the algorithm produces
a loop layout tree, same as the outcome of extracting loop information from the
program‚Äôs source code.
Theorem 2(Trace-Code Correspondence). For any programùëÉ ‚ààK, path constraint
ùëä that is derived fromùëÉ, contextùúé ‚ààContext that satisfiesùëä, and annotated trace
ùë°, ifùë° = GetTrace( ùëÉ , ùëä, ùúé) then there exists a loop layout treeùëô‚Ä≤ such that:
1. ùúé ‚ä¢ùëÉ ‚áìloops ùëô‚Ä≤,
2. ùë° ‚àºùëä,
3. ùëÉ
ùë°
‚àí ‚Üíùúñ,
100
4. ùëô‚Ä≤ ùë°
Àì‚àí ‚ÜíNil, and
5. ùëô‚Ä≤ and the variableùëô are identical except for equivalent variables.
Proof Sketch.By induction on the derivation ofùëÉ. We present a full proof in Sec-
tion 4.5.
This theorem states thatGetTrace correctly extracts from the program execu-
tion an annotated trace that corresponds to a path through the program AST. This
property ensures that the length of the annotated trace is bounded by the code size
of the program inK. This annotated trace also corresponds to a path through the
loop layout tree, which enables the core inference algorithm to identify the location
of loops in the trace. This annotated trace also satisfies the given path constraint.
This property is nontrivial, because when the program executes multiple iterations of
a loop, not all of the iterations are required to satisfy the path constraint.
Theorem 3(Core Recursion). For any programsùëÉ ‚ààProg andùëÉ‚Ä≤ ‚ààK and anno-
tated tracesùë°, ùë°‚Ä≤, ifùëÉ‚Ä≤ ùë°‚Ä≤
‚àí ‚ÜíùëÉ and ùëÉ
ùë°
‚àí ‚Üíùúñ then ùëÉ .= InferProg( ùëÉ‚Ä≤, ùë°‚Ä≤, ùë°).
Proof Sketch.The proof first performs case analysis of the relationship between the
possible first production in ùëÉ, properties of the path constraints ùëäùëñ, and values
ùëìùëñ, ùë°ùëñ,ùëó from the executions of ùëÉ‚Ä≤ in Algorithm 6 to show that Algorithm 6 chooses
the correct first production in ùëÉ. The proof then proceeds by induction on the
productions applied to deriveùëÉ. We present a full proof in Section 4.6.
This theorem states that each recursive call toInferProg correctly returns a
subprogram of the final AST.
Theorem 4(Soundness of Inference). For any programùëÉ ‚ààK, ùëÉ .= Infer( ùëÉ ).
Proof Sketch.The proof first shows that the initial traceùë° at line 3 of Algorithm 1
satisfies ùëÉ
ùë°
‚àí ‚Üíùúñ. The rest of the proof follows from Theorem 3. We present a full
proof in Section 4.6.
This theorem states our main soundness claim: If a program belongs toK then
Konure infers the correct program.
101
Theorem 5 (Complexity). For any programùëÉ ‚ààK, the execution ofInfer( ùëÉ )
calls theInferProg procedure at most‚ÄñùëÉ‚Äñtimes.
Proof Sketch.By induction on the derivation ofùëÉ. We present a full proof in Sec-
tion 4.7.
Intuition. Each recursive call to InferProg constructs a subprogram for ùëÉ ‚àà
K. The algorithm does not need to backtrack because it never makes an incorrect
hypothesis choice. Each step is conclusive ‚Äî only one nonterminal expansion is
possible. The algorithm also does not involve an equivalence check.
The inference algorithm terminates when it has fully constructed the AST ofùëÉ.
More concretely, the number of recursive calls toInferProg is linear in the size of
the given program. Critically, this number of executions is bounded by the size of the
source code ofùëÉ, not by the number of iterations that any loop executes. It works
because any loop‚Äôs iterations are independent from each other (Figure 3-6).
We prove Theorems 2 through 5 only for programsùëÉ ‚ààK (and without reasoning
about Print statements). However, the proofs rely only on the black box execution
of ùëÉ in Execute( ùëÉ , ùúé). The soundness properties therefore hold for arbitrary pro-
grams written in arbitrary languages as long as the program‚Äôs externally observable
behavior is equivalent to that of some programùëÉ ‚ààK. We will discuss these impli-
cations in Section 4.8.
4.2 The Trim Transformation
This section presents the transformation that obtainsÃÉÔ∏ÄùëÉ, which we introduce in Sec-
tion 3.3 to define theKonure DSL, K (Definition 3.3.4). Recall from Section 3.3
that, for any programùëÉ ‚ààProg, ÃÉÔ∏ÄùëÉ is the program after discarding unreachable code
in ùëÉ. The reachability properties facilitate the soundness proof in Section 4.6 and
enable a concise way to characterize complexity in Section 4.7. In Section 4.8 we will
extend our soundness results to programs not inK, such as programs in Prog that
may contain unreachable code.
102
Algorithm 7Iteratively simplify code until reaching a fixed point
Input: ùëÉ is a program in Prog.
Output: Succinct form ofùëÉ.
1: procedure Trim(ùëÉ)
2: while true do
3: (ùë†, ùëÉ‚Ä≤) ‚ÜêTrimOnce(ùëÉ, Nil)
4: if ¬¨ùë† then
5: return ùëÉ‚Ä≤
6: end if
7: ùëÉ ‚ÜêùëÉ‚Ä≤
8: end while
9: end procedure
Algorithm 7 presents theTrim transformation that obtains ÃÉÔ∏ÄùëÉ, ÃÉÔ∏ÄùëÉ = Trim(ùëÉ),
which simplifies ùëÉ by iteratively discarding unreachable branches withTrimOnce
(Algorithm 8).
The TrimOnce procedure takes an initial program,ùëÉ ‚ààProg, and a path con-
straint, ùëä. The procedure returns a tuple of two components. The first component
is a boolean value which indicates whether the transformation altersùëÉ. The second
component is the transformed program. IfùëÉ is empty,TrimOnce returns the empty
program. If the top-most nonterminal symbol ofùëÉ is Seq, TrimOnce first recur-
sively simplifies the tail of the sequence and then uses the simplified tail to construct
a new Seq. If the top-most nonterminal ofùëÉ is If or For,TrimOnce first recursively
simplifies the subprograms and then simplifies the current control construct if possi-
ble. To perform these checks,TrimOnce updates the path constraintùëä and calls
Solve (Section 3.5) to check reachability.
Weshowthatthe Trim transformationterminates(Theorem6)withanequivalent
program (Theorem 7) with no unreachable code (Proposition 4.2.17).
4.2.1 Termination of Trim
To show termination, we define a measure of code size and show that theTrimOnce
transformation decreases the code size.
Definition 4.2.1.The branch complexity tuplefor a programùëÉ ‚ààProg is denoted as
B(ùëÉ) and defined as a 3-tuple of nonnegative integers,B(ùëÉ) = (ùëì, ùëñ, ùë†) ‚ààZ3
‚â•0. Here,
103
Algorithm 8Trim unreachable branches and simplify control constructs if possible
Input: ùëÉ is a program in Prog.
Input: ùëä is a path constraint.
Output: Tuple(ùë†, ùëÉ‚Ä≤) where ùëÉ ‚â°ùëÉ‚Ä≤and ùë† indicates whetherùëÉ‚Ä≤Ã∏= ùëÉ.
1: procedure TrimOnce(ùëÉ, ùëä)
2: if ùëÉ = ùúñ then return(false, ùúñ)
3: else ifùëÉ = ùëÑ ùëÉ1 then
4: (ùë†1, ùëÉ‚Ä≤
1) ‚ÜêTrimOnce(ùëÉ1, ùëä)
5: return (ùë†1, ùëÑ ùëÉ‚Ä≤
1)
6: else ifùëÉ = if ùëÑ then ùëÉ1 else ùëÉ2 then
7: if Solve(ùëä @ ‚ü®ùëÑ, ‚â•1, false‚ü©) = Unsat then return(true, ùëÑ ùëÉ2)
8: else ifSolve(ùëä @ ‚ü®ùëÑ, = 0, false‚ü©) = Unsat then return(true, ùëÑ ùëÉ1)
9: end if
10: (ùë†1, ùëÉ‚Ä≤
1) ‚ÜêTrimOnce(ùëÉ1, ùëä@ ‚ü®ùëÑ, ‚â•1, false‚ü©)
11: (ùë†2, ùëÉ‚Ä≤
2) ‚ÜêTrimOnce(ùëÉ2, ùëä@ ‚ü®ùëÑ, = 0, false‚ü©)
12: if ùëÉ‚Ä≤
1
.=ùëä,Nil,Nil ùëÉ‚Ä≤
2 then
13: return (true, ùëÑ ùëÉ‚Ä≤
1)
14: else
15: return (ùë†1 ‚à®ùë†2, if ùëÑ then ùëÉ‚Ä≤
1 else ùëÉ‚Ä≤
2)
16: end if
17: else ifùëÉ = for ùëÑ do ùëÉ1 else ùëÉ2 then
18: if Solve(ùëä @ ‚ü®ùëÑ, ‚â•2, true‚ü©) = Unsat then
19: return (true, if ùëÑ then ùëÉ1 else ùëÉ2)
20: end if
21: (ùë†1, ùëÉ‚Ä≤
1) ‚ÜêTrimOnce(ùëÉ1, ùëä@ ‚ü®ùëÑ, ‚â•1, true‚ü©)
22: if ùëÉ‚Ä≤
1 = ùúñ then
23: return (true, if ùëÑ then ùúñ else ùëÉ2)
24: end if
25: if Solve(ùëä @ ‚ü®ùëÑ, = 0, true‚ü©) = Unsat then
26: ùë†2 ‚Üê(ùëÉ2 Ã∏= ùúñ)
27: ùëÉ‚Ä≤
2 ‚Üêùúñ
28: else
29: (ùë†2, ùëÉ‚Ä≤
2) ‚ÜêTrimOnce(ùëÉ2, ùëä@ ‚ü®ùëÑ, = 0, true‚ü©)
30: end if
31: return (ùë†1 ‚à®ùë†2, for ùëÑ do ùëÉ‚Ä≤
1 else ùëÉ‚Ä≤
2)
32: end if
33: end procedure
104
ùëì denotes the number offor-constructs inùëÉ, ùëñ denotes the number ofif-constructs
in ùëÉ, andùë† denotes the number of sequential queries inùëÉ:
B(ùúñ) = (0 , 0, 0)
B(ùëÑ ùëÉ) = ( ùëì1, ùëñ1, 1 + ùë†1) if B(ùëÉ) = (ùëì1, ùëñ1, ùë†1)
B(if ùëÑ then ùëÉ1 else ùëÉ2) = ( ùëì1 + ùëì2, 1 + ùëñ1 + ùëñ2, ùë†1 + ùë†2)
if B(ùëÉ1) = (ùëì1, ùëñ1, ùë†1), B(ùëÉ2) = (ùëì2, ùëñ2, ùë†2)
B(for ùëÑ do ùëÉ1 else ùëÉ2) = (1 + ùëì1 + ùëì2, ùëñ1 + ùëñ2, ùë†1 + ùë†2)
if B(ùëÉ1) = (ùëì1, ùëñ1, ùë†1), B(ùëÉ2) = (ùëì2, ùëñ2, ùë†2)
where ùëÉ, ùëÉ1, ùëÉ2 ‚ààProg, ùëÑ ‚ààQuery, andùëì1, ùëì2, ùëñ1, ùëñ2, ùë†1, ùë†2 ‚ààZ‚â•0.
Definition 4.2.2.We define a partial order onZ3
‚â•0 as follows:(ùëì1, ùëñ1, ùë†1) ‚â§(ùëì2, ùëñ2, ùë†2)
if ùëì1 ‚â§ùëì2, ùëì1 + ùëñ1 ‚â§ùëì2 + ùëñ2, andùëì1 + ùëñ1 + ùë†1 ‚â§ùëì2 + ùëñ2 + ùë†2.
Proof of partial order.(1) Reflexivity: For any 3-tuple(ùëì, ùëñ, ùë†) ‚ààZ3
‚â•0, we haveùëì ‚â§
ùëì, ùëì + ùëñ ‚â§ ùëì + ùëñ, and ùëì + ùëñ + ùë† ‚â§ ùëì + ùëñ + ùë†. (2) Antisymmetry: For any 3-
tuples (ùëì1, ùëñ1, ùë†1), (ùëì2, ùëñ2, ùë†2) ‚ààZ3
‚â•0 such that(ùëì1, ùëñ1, ùë†1) ‚â§(ùëì2, ùëñ2, ùë†2) and (ùëì2, ùëñ2, ùë†2) ‚â§
(ùëì1, ùëñ1, ùë†1), we haveùëì1 = ùëì2, ùëì1 +ùëñ1 = ùëì2 +ùëñ2, andùëì1 +ùëñ1 +ùë†1 = ùëì2 +ùëñ2 +ùë†2. (3) Transi-
tivity: For any 3-tuples(ùëì1, ùëñ1, ùë†1), (ùëì2, ùëñ2, ùë†2), (ùëì3, ùëñ3, ùë†3) ‚ààZ3
‚â•0 such that(ùëì1, ùëñ1, ùë†1) ‚â§
(ùëì2, ùëñ2, ùë†2) and (ùëì2, ùëñ2, ùë†2) ‚â§(ùëì3, ùëñ3, ùë†3), we haveùëì1 ‚â§ùëì2 ‚â§ùëì3, ùëì1 +ùëñ1 ‚â§ùëì2 +ùëñ2 ‚â§ùëì3 +ùëñ3,
and ùëì1 + ùëñ1 + ùë†1 ‚â§ùëì2 + ùëñ2 + ùë†2 ‚â§ùëì3 + ùëñ3 + ùë†3.
Informally, this partial order compares the code complexity of two programs. The
first comparison,ùëì1 ‚â§ùëì2, compares the number of loop constructs in the programs.
The second comparison, ùëì1 + ùëñ1 ‚â§ùëì2 + ùëñ2, compares the total number of control
constructs in the programs. The third comparison, ùëì1 + ùëñ1 + ùë†1 ‚â§ ùëì2 + ùëñ2 + ùë†2,
compares the total number of queries in the programs.
Proposition 4.2.3.For any strictly decreasing sequence of branch complexity tuples
(ùëì1, ùëñ1, ùë†1), (ùëì2, ùëñ2, ùë†2), . . .‚ààZ3
‚â•0 such that (ùëìùëò+1, ùëñùëò+1, ùë†ùëò+1) < (ùëìùëò, ùëñùëò, ùë†ùëò) for all ùëò =
1, 2, . . ., the length of the sequence is finite.
Proof. Since ùëì1+ùëñ1+ùë†1 is finite, there is only a finite number of 3-tuples(ùëì, ùëñ, ùë†) ‚ààZ3
‚â•0
such that(0, 0, 0) < (ùëì, ùëñ, ùë†) < (ùëì1, ùëñ1, ùë†1).
105
Lemma4.2.4. For any programùëÉ ‚ààProg and path constraintùëä, ifTrimOnce(ùëÉ, ùëä) =
(false, ùëÉ‚Ä≤) then ùëÉ‚Ä≤= ùëÉ.
Proof. This proof is by induction on the derivation ofùëÉ.
Case 1: ùëÉ = ùúñ.
By Algorithm 8, execution enters the branch on line 2.ùëÉ‚Ä≤= ùúñ = ùëÉ.
Case 2: ùëÉ is of the form ‚ÄúSeq‚Äù.ùëÉ expands to ‚ÄúùëÑ ùëÉ1‚Äù, where ùëÑ corresponds to the
Query symbol andùëÉ1 corresponds to the Prog symbol.
By Algorithm 8, execution enters the branch on line 3. Since
TrimOnce(ùëÉ, ùëä) = (false, ùëÉ‚Ä≤),
ùë†1 = false and ùëÉ‚Ä≤= ùëÑ ùëÉ‚Ä≤
1. By the induction hypothesis, ifùë†1 = false then
ùëÉ‚Ä≤
1 = ùëÉ1. Hence, ùëÉ‚Ä≤= ùëÑ ùëÉ‚Ä≤
1 = ùëÑ ùëÉ1 = ùëÉ.
Case 3: ùëÉ is of the form ‚ÄúIf‚Äù. ùëÉ expands to ‚Äúif ùëÑ then ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol.
By Algorithm 8, execution enters the branch on line 6. Since
TrimOnce(ùëÉ, ùëä) = (false, ùëÉ‚Ä≤),
execution must not enter the branches on lines 7 or 8. Execution continues
after line 9. By the induction hypothesis, ifùë†1 = false then ùëÉ‚Ä≤
1 = ùëÉ1. Also, if
ùë†2 = false then ùëÉ‚Ä≤
2 = ùëÉ2. Execution must enter the branch on line 14. Since
ùë†1 ‚à®ùë†2 = false, ùë†1 = ùë†2 = false. Hence, ùëÉ‚Ä≤ = if ùëÑ then ùëÉ‚Ä≤
1 else ùëÉ‚Ä≤
2 =
if ùëÑ then ùëÉ1 else ùëÉ2 = ùëÉ.
Case 4: ùëÉ is of the form ‚ÄúFor‚Äù. ùëÉ expands to ‚Äúfor ùëÑ do ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
106
and ùëÉ2 corresponds to the second Prog symbol. The proof is similar to the
proof of Case 3.
Lemma4.2.5. For any programùëÉ ‚ààProg and path constraintùëä, ifTrimOnce(ùëÉ, ùëä) =
(true, ùëÉ‚Ä≤) then B(ùëÉ‚Ä≤) < B(ùëÉ).
Proof. This proof is by induction on the derivation ofùëÉ.
Case 1: ùëÉ = ùúñ.
ByAlgorithm8, executionentersthebranchonline2. Henceitisnotpossible
to haveTrimOnce(ùëÉ, ùëä) = (true, ùëÉ‚Ä≤).
Case 2: ùëÉ is of the form ‚ÄúSeq‚Äù.ùëÉ expands to ‚ÄúùëÑ ùëÉ1‚Äù, where ùëÑ corresponds to the
Query symbol andùëÉ1 corresponds to the Prog symbol.
By Algorithm 8, execution enters the branch on line 3. Since
TrimOnce(ùëÉ, ùëä) = (true, ùëÉ‚Ä≤),
ùë†1 = true and ùëÉ‚Ä≤ = ùëÑ ùëÉ‚Ä≤
1. By the induction hypothesis, if ùë†1 = true
then B(ùëÉ‚Ä≤
1) < B(ùëÉ1). By Definition 4.2.1 and Definition 4.2.2,B(ùëÑ ùëÉ‚Ä≤
1) <
B(ùëÑ ùëÉ1). Hence, B(ùëÉ‚Ä≤) < B(ùëÉ).
Case 3: ùëÉ is of the form ‚ÄúIf‚Äù. ùëÉ expands to ‚Äúif ùëÑ then ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol.
By Algorithm 8, execution enters the branch on line 6.
Let ùëì1, ùëì2, ùëñ1, ùëñ2, ùë†1, ùë†2 ‚àà Z‚â•0 such that B(ùëÉ1) = ( ùëì1, ùëñ1, ùë†1) and B(ùëÉ2) =
(ùëì2, ùëñ2, ùë†2).
Case 3.1: Execution enters the branch on line 7.
107
By Definition 4.2.1,B(ùëÑ ùëÉ2) = (ùëì2, ùëñ2, 1 + ùë†2). Also,
B(if ùëÑ then ùëÉ1 else ùëÉ2) = (ùëì1 + ùëì2, 1 + ùëñ1 + ùëñ2, ùë†1 + ùë†2).
By Definition 4.2.2,(ùëì2, ùëñ2, 1 + ùë†2) < (ùëì1 + ùëì2, 1 + ùëñ1 + ùëñ2, ùë†1 + ùë†2).
SinceTrimOnce(ùëÉ, ùëä) = (true, ùëÉ‚Ä≤), ùëÉ‚Ä≤= ùëÑ ùëÉ2. Hence,B(ùëÉ‚Ä≤) =
B(ùëÑ ùëÉ2) < B(if ùëÑ then ùëÉ1 else ùëÉ2) = B(ùëÉ).
Case 3.2: Execution enters the branch on line 8. The proof is similar to the
proof of Case 3.1.
Case 3.3: Execution continues after line 9.
By the induction hypothesis, ifùë†1 = true then B(ùëÉ‚Ä≤
1) < B(ùëÉ1).
Also, if ùë†2 = true then B(ùëÉ‚Ä≤
2) < B(ùëÉ2). By Lemma 4.2.4, if
ùë†1 = false thenB(ùëÉ‚Ä≤
1) = B(ùëÉ1). Also, ifùë†2 = false thenB(ùëÉ‚Ä≤
2) =
B(ùëÉ2). Hence, B(ùëÉ‚Ä≤
1) ‚â§B(ùëÉ1) and B(ùëÉ‚Ä≤
2) ‚â§B(ùëÉ2) always hold.
If execution enters the branch on 12, sinceTrimOnce(ùëÉ, ùëä) =
(true, ùëÉ‚Ä≤), we have ùëÉ‚Ä≤ = ùëÑ ùëÉ‚Ä≤
1. Let ùëì‚Ä≤
1, ùëñ‚Ä≤
1, ùë†‚Ä≤
1 ‚ààZ‚â•0 such that
B(ùëÉ‚Ä≤
1) = (ùëì‚Ä≤
1, ùëñ‚Ä≤
1, ùë†‚Ä≤
1). By Definition 4.2.1,B(ùëÑ ùëÉ‚Ä≤
1) = (ùëì‚Ä≤
1, ùëñ‚Ä≤
1, 1 +ùë†‚Ä≤
1).
Also, B(if ùëÑ then ùëÉ1 else ùëÉ2) = ( ùëì1 + ùëì2, 1 + ùëñ1 + ùëñ2, ùë†1 + ùë†2).
Since B(ùëÉ‚Ä≤
1) ‚â§B(ùëÉ1), (ùëì‚Ä≤
1, ùëñ‚Ä≤
1, ùë†‚Ä≤
1) ‚â§(ùëì1, ùëñ1, ùë†1). By Definition 4.2.2,
(ùëì‚Ä≤
1, ùëñ‚Ä≤
1, 1 + ùë†‚Ä≤
1) < (ùëì1 + ùëì2, 1 + ùëñ1 + ùëñ2, ùë†1 + ùë†2). Hence, B(ùëÉ‚Ä≤) =
B(ùëÑ ùëÉ‚Ä≤
1) < B(if ùëÑ then ùëÉ1 else ùëÉ2) = B(ùëÉ).
If execution enters the branch on 14, sinceTrimOnce(ùëÉ, ùëä) =
(true, ùëÉ‚Ä≤), wehaveùë†1‚à®ùë†2 = true andùëÉ‚Ä≤= if ùëÑ then ùëÉ‚Ä≤
1 else ùëÉ‚Ä≤
2.
Hence, at least one ofB(ùëÉ‚Ä≤
1) < B(ùëÉ1) or B(ùëÉ‚Ä≤
2) < B(ùëÉ2) holds. By
Definition 4.2.1 and Definition 4.2.2,B(if ùëÑ then ùëÉ‚Ä≤
1 else ùëÉ‚Ä≤
2) <
B(if ùëÑ then ùëÉ1 else ùëÉ2). Hence, B(ùëÉ‚Ä≤) < B(ùëÉ).
Case 4: ùëÉ is of the form ‚ÄúFor‚Äù. ùëÉ expands to ‚Äúfor ùëÑ do ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol. The proof is similar to the
108
proof of Case 3.
Theorem 6 (Trim Terminates). For any program ùëÉ ‚àà Prog, the execution of
Trim(ùëÉ) terminates.
Proof. By Lemma 4.2.5,B(ùëÉ‚Ä≤) < B(ùëÉ) on line 3 as long asùë† = true. Hence, the
value of B(ùëÉ) strictly decreases in each iteration of the loop as long asùë† = true.
By Proposition 4.2.3, after a finite number of iterations, it is no longer possible to
have B(ùëÉ‚Ä≤) < B(ùëÉ). At this time,ùë† = false by Lemma 4.2.5. Execution enters the
branch on line 4. The algorithm then terminates.
Proposition 4.2.6.For any programùëÉ ‚ààProg, Trim(Trim(ùëÉ)) = Trim(ùëÉ).
Proof. For any program ùëÉ0 ‚ààProg, let ùëÉ1 = Trim(ùëÉ0). In the last iteration of
the loop in Algorithm 7, variableùë† = false on line 3. By Lemma 4.2.4, variable
ùëÉ‚Ä≤= ùëÉ at this time. Since the algorithm returnsùëÉ1, we haveTrimOnce(ùëÉ1, Nil) =
(false, ùëÉ1). Let ùëÉ2 = Trim(ùëÉ1). In the first iteration of the loop in Algorithm 7,
variable ùë† = false and ùëÉ‚Ä≤= ùëÉ = ùëÉ1 on line 3. Hence, the return valueùëÉ2 = ùëÉ1. In
other words,Trim(Trim(ùëÉ0)) = Trim(ùëÉ0).
4.2.2 Soundness of Trim
To show thatTrim produces an equivalent program, we show that each recursive
call toTrimOnce rewrites each subprogram into a corresponding subprogram that
is equivalent with respect to a path constraint.
Definition4.2.7. Wedefinethe observational equivalencerelationonProgasfollows:
ùëÉ1 ‚â°ùëÉ2 if for any contextùúé ‚ààContext, ùúé(ùëÉ1) = ùúé(ùëÉ2).
Proof of equivalence relation.(1) Reflexivity: For any programùëÉ ‚ààProg, ùúé(ùëÉ) =
ùúé(ùëÉ) for allùúé ‚ààContext. (2) Symmetry: For any programsùëÉ1, ùëÉ2 ‚ààProg such that
ùëÉ1 ‚â°ùëÉ2, ùúé(ùëÉ2) = ùúé(ùëÉ1) for all ùúé ‚ààContext. (3) Transitivity: For any programs
ùëÉ1, ùëÉ2, ùëÉ3 ‚ààProg such thatùëÉ1 ‚â°ùëÉ2 and ùëÉ2 ‚â°ùëÉ3, ùúé(ùëÉ1) = ùúé(ùëÉ2) = ùúé(ùëÉ3) for all
ùúé ‚ààContext.
109
Proposition 4.2.8.For any programsùëÉ1, ùëÉ2 ‚ààProg, ifùëÉ1 ‚â°ùëÉ2 then Infer( ùëÉ1 ) =
Infer( ùëÉ2 ).
Proof. By Definition 4.2.7,ùúé(ùëÉ1) = ùúé(ùëÉ2) for any contextùúé ‚ààContext. By Defini-
tion 3.4.8, for anyùúé we haveExecute( ùëÉ1 , ùúé) = Execute( ùëÉ2 , ùúé). By Algorithm 1,
Infer( ùëÉ1 ) = Infer( ùëÉ2 ).
Definition 4.2.9.For any path constraintùëä, we define a relation on Prog as follows:
ùëÉ1 ‚â°ùëä,ùëå1,ùëå2 ùëÉ2 if for any contextùúé ‚ààContext that satisfiesùëä, ùúé(ùëÉ‚Ä≤
1) = ùúé(ùëÉ2), where
ùëÉ‚Ä≤
1 is the program obtained fromùëÉ1 after replacing all occurrences of variables inùëå1
with their counterparts inùëå2.
Proposition 4.2.10. For any programs ùëÉ1, ùëÉ2 ‚àà Prog and list of variables ùëå ‚àà
Variable, ùëÉ1 ‚â°Nil,Nil,Nil ùëÉ2 if and only ifùëÉ1 ‚â°Nil,ùëå,ùëå ùëÉ2.
Proof. By definition.
Proposition 4.2.11.For any programsùëÉ1, ùëÉ2 ‚ààProg, ùëÉ1 ‚â°Nil,Nil,Nil ùëÉ2 if and only if
ùëÉ1 ‚â°ùëÉ2.
Proof. By definition.
Proposition 4.2.12.For any programsùëÉ1, ùëÉ2 ‚ààProg, path constraintùëä, and lists
of variablesùëå1, ùëå2 ‚ààVariable, ifùëÉ1
.=ùëä,ùëå1,ùëå2 ùëÉ2 then ùëÉ1 ‚â°ùëä,ùëå1,ùëå2 ùëÉ2.
Proof. By induction on the derivation ofùëÉ1, ùëÉ2, using Definition 3.4.24 and Figure 4-
1.
Proposition 4.2.13.For any programsùëÉ1, ùëÉ2 ‚ààProg, ifùëÉ1
.= ùëÉ2 then ùëÉ1 ‚â°ùëÉ2.
Proof. By Proposition 4.2.11 and Proposition 4.2.12.
Lemma4.2.14. For any programùëÉ ‚ààProg and path constraintùëä, ifTrimOnce(ùëÉ, ùëä) =
(ùë†, ùëÉ‚Ä≤) then ùëÉ‚Ä≤‚â°ùëä,Nil,Nil ùëÉ.
Proof. This proof is by induction on the derivation ofùëÉ.
110
Case 1: ùëÉ = ùúñ.
By Algorithm 8, execution enters the branch on line 2. Hence,ùëÉ‚Ä≤= ùúñ = ùëÉ.
By Definition 4.2.9,ùëÉ‚Ä≤‚â°ùëä,Nil,Nil ùëÉ.
Case 2: ùëÉ is of the form ‚ÄúSeq‚Äù.ùëÉ expands to ‚ÄúùëÑ ùëÉ1‚Äù, where ùëÑ corresponds to the
Query symbol andùëÉ1 corresponds to the Prog symbol.
By Algorithm 8, execution enters the branch on line 3. By the induction
hypothesis, variableùëÉ‚Ä≤
1 satisfies ùëÉ‚Ä≤
1 ‚â°ùëä,Nil,Nil ùëÉ1. For any contextùúé ‚ààContext
that satisfiesùëä, let ùúé1 = ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ)]. Since ùúé1 only adds the mapping
of a new variableùëÑ.ùë¶ which does not appear inùëä, ùúé1 also satisfiesùëä. By
Definition 4.2.9,ùúé1(ùëÉ‚Ä≤
1) = ùúé1(ùëÉ1). By Figure 3-17,ùúé(ùëÑ ùëÉ‚Ä≤
1) = ùúé(ùëÑ ùëÉ1). By
Definition 4.2.9, ùëÑ ùëÉ‚Ä≤
1 ‚â°ùëä,Nil,Nil ùëÑ ùëÉ1. Since TrimOnce(ùëÉ, ùëä) = ( ùë†, ùëÉ‚Ä≤),
ùëÉ‚Ä≤= ùëÑ ùëÉ‚Ä≤
1. Hence, ùëÉ‚Ä≤‚â°ùëä,Nil,Nil ùëÉ.
Case 3: ùëÉ is of the form ‚ÄúIf‚Äù. ùëÉ expands to ‚Äúif ùëÑ then ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol.
By Algorithm 8, execution enters the branch on line 6.
Case 3.1: Solve(ùëä @ ‚ü®ùëÑ, ‚â•1, false‚ü©) is unsatisfiable.
Execution enters the branch on line 7. By Proposition 4.1.6, for
any context ùúé ‚àà Context that satisfies ùëä, ùúé(ùëÑ) = ‚àÖbecause
|ùúé(ùëÑ)|‚â• 1 is impossible. Hence,ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ)] = ùúé. By Figure 3-
17, ùúé(ùëÑ ùëÉ2) = ùúé(if ùëÑ then ùëÉ1 else ùëÉ2). By Definition 4.2.9,
ùëÑ ùëÉ2 ‚â°ùëä,Nil,Nil if ùëÑ then ùëÉ1 else ùëÉ2. Since TrimOnce(ùëÉ, ùëä) =
(ùë†, ùëÉ‚Ä≤), ùëÉ‚Ä≤= ùëÑ ùëÉ2. Hence, ùëÉ‚Ä≤‚â°ùëä,Nil,Nil ùëÉ.
Case 3.2: Solve(ùëä @ ‚ü®ùëÑ, = 0, false‚ü©) is unsatisfiable.
Execution enters the branch on line 8. The proof is similar to the
proof of Case 3.1.
Case 3.3: BothSolve(ùëä @ ‚ü®ùëÑ, ‚â•1, false‚ü©)and Solve(ùëä @ ‚ü®ùëÑ, = 0, false‚ü©)
are satisfiable.
111
Execution continues after line 9. By the induction hypothesis,
variables ùëÉ‚Ä≤
1 and ùëÉ‚Ä≤
2 satisfy
ùëÉ‚Ä≤
1 ‚â°ùëä @ ‚ü®ùëÑ,‚â•1,false‚ü©,Nil,Nil ùëÉ1,
ùëÉ‚Ä≤
2 ‚â°ùëä @ ‚ü®ùëÑ,=0,false‚ü©,Nil,Nil ùëÉ2.
For any contextùúé ‚ààContext that satisfiesùëä, only one of|ùúé(ùëÑ)|=
0 and |ùúé(ùëÑ)|‚â• 1 holds.
Case 3.3.1: If |ùúé(ùëÑ)|= 0, ùúé satisfies ùëä @ ‚ü®ùëÑ, = 0, false‚ü©.
By Definition 4.2.9,ùúé(ùëÉ‚Ä≤
2) = ùúé(ùëÉ2). Since ùúé(ùëÑ) = ‚àÖ,
ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ)] = ùúé. By Figure 3-17,
ùúé(if ùëÑ then ùëÉ‚Ä≤
1 else ùëÉ‚Ä≤
2) = ùúé(if ùëÑ then ùëÉ1 else ùëÉ2).
Case 3.3.2: If |ùúé(ùëÑ)|‚â• 1, ùúé satisfies ùëä @ ‚ü®ùëÑ, ‚â•1, false‚ü©.
Let ùúé1 = ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ)]. Sinceùúé1 only adds the map-
pingofanewvariable ùëÑ.ùë¶ whichdoesnotappearin ùëä,
ùúé1 alsosatisfiesthepathconstraint ùëä @ ‚ü®ùëÑ, ‚â•1, false‚ü©.
By Definition 4.2.9,ùúé1(ùëÉ‚Ä≤
1) = ùúé1(ùëÉ1). By Figure 3-17,
ùúé(if ùëÑ then ùëÉ‚Ä≤
1 else ùëÉ‚Ä≤
2) = ùúé(if ùëÑ then ùëÉ1 else ùëÉ2).
Either case, we have
ùúé(if ùëÑ then ùëÉ‚Ä≤
1 else ùëÉ‚Ä≤
2) = ùúé(if ùëÑ then ùëÉ1 else ùëÉ2).
ByDefinition4.2.9, if ùëÑ then ùëÉ‚Ä≤
1 else ùëÉ‚Ä≤
2 ‚â°ùëä,Nil,Nil if ùëÑ then ùëÉ1 else ùëÉ2.
Next, consider ifùëÉ‚Ä≤
1 and ùëÉ‚Ä≤
2 are identical except for equivalent vari-
ables.
Case 3.3.1: If ùëÉ‚Ä≤
1
.=ùëä,Nil,Nil ùëÉ‚Ä≤
2, execution enters the branch on line
12. By Proposition 4.2.12,ùëÉ‚Ä≤
1 ‚â°ùëä,Nil,Nil ùëÉ‚Ä≤
2. By Defini-
112
tion 4.2.9 and Figure 3-17, we have
if ùëÑ then ùëÉ‚Ä≤
1 else ùëÉ‚Ä≤
1 ‚â°ùëä,Nil,Nil if ùëÑ then ùëÉ‚Ä≤
1 else ùëÉ‚Ä≤
2.
Since TrimOnce(ùëÉ, ùëä) = (ùë†, ùëÉ‚Ä≤), ùëÉ‚Ä≤= ùëÑ ùëÉ‚Ä≤
1. Clearly
ùëÑ ùëÉ‚Ä≤
1 ‚â°ùëä,Nil,Nil if ùëÑ then ùëÉ‚Ä≤
1 else ùëÉ‚Ä≤
1. By Defini-
tion 4.2.9,ùëÉ‚Ä≤‚â°ùëä,Nil,Nil ùëÉ.
Case 3.3.2: If ùëÉ‚Ä≤
1 Ã∏.=ùëä,Nil,Nil ùëÉ‚Ä≤
2, execution enters the branch on line
14. Since TrimOnce(ùëÉ, ùëä) = ( ùë†, ùëÉ‚Ä≤), we haveùëÉ‚Ä≤ =
if ùëÑ then ùëÉ‚Ä≤
1 else ùëÉ‚Ä≤
2. Hence, ùëÉ‚Ä≤‚â°ùëä,Nil,Nil ùëÉ.
Case 4: ùëÉ is of the form ‚ÄúFor‚Äù. ùëÉ expands to ‚Äúfor ùëÑ do ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol. The proof is similar to the
proof of Case 3.
Lemma 4.2.15. For any programùëÉ ‚ààProg, if TrimOnce(ùëÉ, Nil) = ( ùë†, ùëÉ‚Ä≤) then
ùëÉ‚Ä≤‚â°ùëÉ.
Proof. By Lemma 4.2.14,ùëÉ‚Ä≤‚â°Nil,Nil,Nil ùëÉ. By Proposition 4.2.11,ùëÉ‚Ä≤‚â°ùëÉ.
Theorem7 (Trim PreservesSemantics). Foranyprogram ùëÉ ‚ààProg, Trim(ùëÉ) ‚â°ùëÉ.
Proof. By Lemma 4.2.15,ùëÉ‚Ä≤ ‚â°ùëÉ on line 3 in each iteration of the loop. By Theo-
rem 6, the loop terminates. By Definition 4.2.7, the final programùëÉ‚Ä≤ preserves the
semantics of the initial program.
We next outline the reachability properties of the simplified program. Intuitively,
sinceTrimOnce discardsunreachablebranches, theremainingbranchesareallreach-
able.
Proposition 4.2.16.For any programùëÉ ‚ààProg and path constraintùëä, if
TrimOnce(ùëÉ, ùëä) = (false, ùëÉ‚Ä≤)
113
then the following hold forùëÉ‚Ä≤:
‚Ä¢ For any queryùëÑ ‚ààQuery inùëÉ‚Ä≤, there exists a contextùúé ‚ààContext such that
ùëÑ is used while evaluatingùúé(ùëÉ‚Ä≤).
‚Ä¢ For anyif-construct ‚Äúif ùëÑ . . .‚Äù in ùëÉ‚Ä≤, there exists a contextùúé ‚ààContext such
that ùëÑ is used while evaluatingùúé(ùëÉ‚Ä≤) and the corresponding row countùëü ‚â•1.
‚Ä¢ For anyif-construct ‚Äúif ùëÑ . . .‚Äù in ùëÉ‚Ä≤, there exists a contextùúé ‚ààContext such
that ùëÑ is used while evaluatingùúé(ùëÉ‚Ä≤) and the corresponding row countùëü = 0.
‚Ä¢ For any for-construct ‚Äúfor ùëÑ . . .‚Äù in ùëÉ‚Ä≤, there exists a contextùúé ‚ààContext
such that ùëÑ is used while evaluatingùúé(ùëÉ‚Ä≤) and the corresponding row count
ùëü ‚â•2.
Rationale. By induction on the derivation ofùëÉ‚Ä≤, using Proposition 4.1.6.
Proposition 4.2.17(Reachability). For any programùëÉ ‚ààProg, the following hold:
‚Ä¢ For any queryùëÑ ‚ààQuery inTrim(ùëÉ), there exists a contextùúé ‚ààContext such
that ùëÑ is used while evaluatingùúé(Trim(ùëÉ)).
‚Ä¢ For anyif-construct ‚Äúif ùëÑ . . .‚Äù inTrim(ùëÉ), there exists a contextùúé ‚ààContext
such that ùëÑ is used while evaluatingùúé(Trim(ùëÉ)) and the corresponding row
count ùëü ‚â•1.
‚Ä¢ For anyif-construct ‚Äúif ùëÑ . . .‚Äù inTrim(ùëÉ), there exists a contextùúé ‚ààContext
such that ùëÑ is used while evaluatingùúé(Trim(ùëÉ)) and the corresponding row
count ùëü = 0.
‚Ä¢ For any for-construct ‚Äúfor ùëÑ . . .‚Äù in Trim(ùëÉ), there exists a context ùúé ‚àà
Context suchthat ùëÑ isusedwhileevaluating ùúé(Trim(ùëÉ)) andthecorresponding
row countùëü ‚â•2.
Rationale. In the last iteration of the loop in Algorithm 7, variableùë† = false on line
3. The rest of the proof follows from Proposition 4.2.16.
114
4.3 Source Code Characteristics
This section defines the functionsT(¬∑), R(¬∑), and D(¬∑), which we introduce in Sec-
tion 3.3 to define theKonure DSL. To present theKonure DSL restrictions for-
mally, we define the following characteristics for describing the source code of a pro-
gram in Prog.
Definition 4.3.1.For any programùëÉ ‚ààProg, functionF(ùëÉ) returns the first query
of ùëÉ if ùëÉ is nonempty or Nil ifùëÉ is empty:
F(ùúñ) = Nil
F(ùëÑ ùëÉ) = ùëÑ
F(if ùëÑ then ùëÉ1 else ùëÉ2) = ùëÑ
F(for ùëÑ do ùëÉ1 else ùëÉ2) = ùëÑ
where ùëÉ, ùëÉ1, ùëÉ2 ‚ààProg andùëÑ ‚ààQuery.
Definition 4.3.2.Let SQuery be the set of skeleton queries (Appendix??). For any
program ùëÉ ‚ààProg andùëû ‚ààSQuery‚à™{Nil}, functionC(ùëû, ùëÉ) returns the number of
queries inùëÉ that share the skeletonùëû:
C(Nil, ùëÉ) = 0
C(ùëû, ùúñ) = 0
C(ùëû, ùëÑ ùëÉ) =
‚éß
‚é™‚é®
‚é™‚é©
1 + C(ùëû, ùëÉ) if ùúãSùëÑ = ùëû
C(ùëû, ùëÉ) otherwise
, (ùëû Ã∏= Nil)
C(ùëû, if ùëÑ then ùëÉ1 else ùëÉ2) =
‚éß
‚é™‚é®
‚é™‚é©
1 + C(ùëû, ùëÉ1) + C(ùëû, ùëÉ2) if ùúãSùëÑ = ùëû
C(ùëû, ùëÉ1) + C(ùëû, ùëÉ2) otherwise
, (ùëû Ã∏= Nil)
C(ùëû, for ùëÑ do ùëÉ1 else ùëÉ2) =
‚éß
‚é™‚é®
‚é™‚é©
1 + C(ùëû, ùëÉ1) + C(ùëû, ùëÉ2) if ùúãSùëÑ = ùëû
C(ùëû, ùëÉ1) + C(ùëû, ùëÉ2) otherwise
, (ùëû Ã∏= Nil)
where ùëÉ, ùëÉ1, ùëÉ2 ‚ààProg, ùëÑ ‚ààQuery, andùëû ‚ààSQuery‚à™{Nil}.
115
Definition 4.3.3. For any program ùëÉ ‚àà Prog, function R(ùëÉ) returns the set of
all queries inùëÉ whose immediate subsequent query on the nonempty branch shares
skeleton with other subsequent queries:
R(ùúñ) = ‚àÖ
R(ùëÑ ùëÉ) =
‚éß
‚é™‚é®
‚é™‚é©
{ùëÑ.ùë¶}‚à™R(ùëÉ) if C(ùúãSF(ùëÉ), ùëÉ) ‚â•2
R(ùëÉ) otherwise
R(if ùëÑ then ùëÉ1 else ùëÉ2) =
‚éß
‚é™‚é®
‚é™‚é©
{ùëÑ.ùë¶}‚à™R(ùëÉ1) ‚à™R(ùëÉ2) if C(ùúãSF(ùëÉ1), ùëÉ1) ‚â•2
R(ùëÉ1) ‚à™R(ùëÉ2) otherwise
R(for ùëÑ do ùëÉ1 else ùëÉ2) =
‚éß
‚é™‚é®
‚é™‚é©
{ùëÑ.ùë¶}‚à™R(ùëÉ1) ‚à™R(ùëÉ2) if C(ùúãSF(ùëÉ1), ùëÉ1) ‚â•2
R(ùëÉ1) ‚à™R(ùëÉ2) otherwise
where ùëÉ, ùëÉ1, ùëÉ2 ‚ààProg andùëÑ ‚ààQuery.
Definition 4.3.4. For any program ùëÉ ‚àà Prog and context ùúé ‚àà Context, Tùúé(ùëÉ)
denotes the set of queries that each returns at least two rows when executingùëÉ using
ùúé:
Tùúé(ùúñ) = ‚àÖ
Tùúé(ùëÑ ùëÉ) =
‚éß
‚é™‚é®
‚é™‚é©
{ùëÑ.ùë¶}‚à™Tùúé[ùëÑ.ùë¶‚Ü¶‚Üíùúé(ùëÑ)](ùëÉ) if |ùúé(ùëÑ)|‚â• 2
Tùúé[ùëÑ.ùë¶‚Ü¶‚Üíùúé(ùëÑ)](ùëÉ) otherwise
Tùúé(if ùëÑ then ùëÉ1 else ùëÉ2) =
‚éß
‚é™‚é™‚é™‚é™‚é™‚é®
‚é™‚é™‚é™‚é™‚é™‚é©
{ùëÑ.ùë¶}‚à™Tùúé[ùëÑ.ùë¶‚Ü¶‚Üíùúé(ùëÑ)](ùëÉ1) if |ùúé(ùëÑ)|‚â• 2
Tùúé[ùëÑ.ùë¶‚Ü¶‚Üíùúé(ùëÑ)](ùëÉ1) if |ùúé(ùëÑ)|= 1
Tùúé(ùëÉ2) otherwise
Tùúé(for ùëÑ do ùëÉ1 else ùëÉ2) =
‚éß
‚é™‚é™‚é™‚é™‚é™‚é®
‚é™‚é™‚é™‚é™‚é™‚é©
{ùëÑ.ùë¶}‚à™‚ãÉÔ∏Äùëü
ùëñ=1 Tùúé[ùëÑ.ùë¶‚Ü¶‚Üíùúé(ùëÑ)[ùëñ]](ùëÉ1) if |ùúé(ùëÑ)|= ùëü ‚â•2
Tùúé[ùëÑ.ùë¶‚Ü¶‚Üíùúé(ùëÑ)](ùëÉ1) if |ùúé(ùëÑ)|= 1
Tùúé(ùëÉ2) otherwise
116
where ùëÉ, ùëÉ1, ùëÉ2 ‚ààProg, ùëÑ ‚ààQuery, ùë¶ ‚ààVariable, andùëü ‚ààZ‚â•0.
Definition 4.3.5. For any program ùëÉ ‚àà Prog, function T(ùëÉ) returns the set of
queries in ùëÉ that may retrieve at least two rows during any execution: T(ùëÉ) =
‚ãÉÔ∏Ä
ùúé‚ààContext Tùúé(ùëÉ).
Definition 4.3.6.For any programùëÉ ‚ààProg, predicateD(ùëÉ) is true if and only if
the two branches of any conditional statement inùëÉ start with queries with different
skeletons:
D(ùúñ) = true
D(ùëÑ ùëÉ) = D(ùëÉ)
D(if ùëÑ then ùëÉ1 else ùëÉ2) =
‚éß
‚é™‚é®
‚é™‚é©
true if ùëÉ1 = ùëÉ2 = ùúñ
ùúãSF(ùëÉ1) Ã∏= ùúãSF(ùëÉ2) ‚àßD(ùëÉ1) ‚àßD(ùëÉ2) otherwise
D(for ùëÑ do ùëÉ1 else ùëÉ2) =
‚éß
‚é™‚é®
‚é™‚é©
true if ùëÉ1 = ùëÉ2 = ùúñ
D(ùëÉ1) ‚àßD(ùëÉ2) otherwise
where ùëÉ, ùëÉ1, ùëÉ2 ‚ààProg andùëÑ ‚ààQuery.
4.4 Soundness of DetectLoops
We show that the outcome ofDetectLoops (Algorithm 3) is consistent with the
loop layout tree obtained from the source code (Theorem 1). To facilitate discussion
we define an auxiliary procedure,DetectLoopsAux (Algorithm 9). This procedure
is the same asDetectLoops except for two additional variables,ùëÉ and ùúé, which
are used in the proof but do not affect the results of the algorithm.
Lemma 4.4.1.For any programùëÉ0 ‚ààK and contextùúé0 ‚ààContext if ùúé0 ‚ä¢ùëÉ0 ‚áìexec
ùëí0, during the calculation ofDetectLoopsAux(ùëí0, ùëÉ0, ùúé0), if the parameters of a
recursive call DetectLoopsAux(ùëí, ùëÉ, ùúé) satisfy ùúé ‚ä¢ùëÉ ‚áìexec ùëí and Algorithm 9
enters line 5 then:
1. F(ùëÉ) = ùëÑ1,
117
2. |ùúé(ùëÑ1)|= ùëü1, and
3. if ùëü1 ‚â•2 then ùëÑ1.ùë¶ ‚ààT(ùëÉ0).
Proof. This proof is by induction on the derivation ofùëÉ.
Case 1: ùëÉ = ùúñ. Since ùúé ‚ä¢ùëÉ ‚áìexec ùëí, by Figure 4-2,ùëí = Nil. Algorithm 9 returns
before line 5.
Case 2: ùëÉ is of the form ‚ÄúSeq‚Äù.ùëÉ expands to ‚ÄúùëÑ ùëÉ1‚Äù, where ùëÑ corresponds to the
Query symbol andùëÉ1 corresponds to the Prog symbol. Sinceùúé ‚ä¢ùëÉ ‚áìexec ùëí,
by Figure 4-2, ùëÑ1 = ùëÑ and ùëü1 = |ùúé(ùëÑ)|= |ùúé(ùëÑ1)|. By Definition 4.3.1,
F(ùëÉ) = ùëÑ = ùëÑ1. By Definition 4.3.4, if ùëü1 ‚â•2 then ùëÑ1.ùë¶ ‚ààTùúé(ùëÉ) and
ùëÑ1.ùë¶ ‚ààTùúé0 (ùëÉ0). By Definition 4.3.5,ùëÑùë¶.ùë¶ ‚ààT(ùëÉ0).
Case 3: ùëÉ is of the form ‚ÄúIf‚Äù. ùëÉ expands to ‚Äúif ùëÑ then ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol. The proof is similar to the
proof of Case 2.
Case 4: ùëÉ is of the form ‚ÄúFor‚Äù. ùëÉ expands to ‚Äúfor ùëÑ do ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol. The proof is similar to the
proof of Case 2.
Lemma 4.4.2.For any programùëÉ0 ‚ààK and contextùúé0 ‚ààContext if ùúé0 ‚ä¢ùëÉ0 ‚áìexec
ùëí0, during the calculation ofDetectLoopsAux(ùëí0, ùëÉ0, ùúé0), if the parameters of a
recursive callDetectLoopsAux(ùëí, ùëÉ, ùúé) satisfy ùúé ‚ä¢ùëÉ ‚áìexec ùëí and ùúé ‚ä¢ùëÉ ‚áìloops ùëô
then DetectLoopsAux(ùëí, ùëÉ, ùúé) = ùëô.
Proof. This proof is by induction on the derivation ofùëÉ.
Case 1: ùëÉ = ùúñ. Since ùúé ‚ä¢ùëÉ ‚áìexec ùëí, by Figure 4-2,ùëí = Nil. Since ùúé ‚ä¢ùëÉ ‚áìloops ùëô, by
Figure 4-3,ùëô = Nil. By Algorithm 9,DetectLoopsAux(Nil, ùëÉ, ùúé) = Nil.
118
Case 2: ùëÉ is of the form ‚ÄúSeq‚Äù.ùëÉ expands to ‚ÄúùëÑ ùëÉ1‚Äù, where ùëÑ corresponds to the
Query symbol andùëÉ1 corresponds to the Prog symbol.
Let ùëü = |ùúé(ùëÑ)|and ùúé1 = ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ)].
Since ùúé ‚ä¢ùëÉ ‚áìexec ùëí, by Figure 4-2, there exists a list of query-result pairs
ùëí1 such that ùëí = ( ùëÑ, ùëü) @ ùëí1 and ùúé1 ‚ä¢ùëÉ1 ‚áìexec ùëí1. By Lemma 4.4.1, ùëí =
(ùëÑ1, ùëü1) @ ùëí1.
Since ùúé ‚ä¢ùëÉ ‚áìloops ùëô, by Figure 4-3, there exists a loop layout treeùëô1 such
that ùëô = (ùëÑ, ùëü) %ùëô1 and ùúé1 ‚ä¢ùëÉ1 ‚áìloops ùëô1. By Lemma 4.4.1,ùëô = (ùëÑ1, ùëü1) %ùëô1.
Case 2.1: ùëü ‚â§1. In Algorithm 9, execution enters the branch on line 12.
Case 2.2: ùëü ‚â•2. By Lemma 4.4.1,ùëÑ.ùë¶ ‚ààT(ùëÉ0). By Definition 3.3.4,ùëÑ.ùë¶ Ã∏‚àà
R(ùëÉ0). By Definition 4.3.3, C(ùúãSF(ùëÉ1), ùëÉ1) ‚â§1. By Figure 4-2,
ùúãSF(ùëÉ1) appears at most once inùëí1. In Algorithm 9, the branch
on line 8 never executes, so the length ofùëé in the procedure remains
zero. Execution enters the branch on line 12.
In both cases, by Lemma 4.4.1, variableùúé‚Ä≤= ùë†ùëñùëîùëöùëé1. Also, variablesùëí‚Ä≤= ùëí1
and ùëÉ‚Ä≤ = ùëÉ1. Algorithm 9 recursively calls DetectLoopsAux(ùëí1, ùëÉ1, ùúé1)
on line 20, which returnsùëô1 by the induction hypothesis. Hence
DetectLoopsAux(ùëí, ùëÉ, ùúé) = (ùëÑ1, ùëü1) %DetectLoopsAux(ùëí1, ùëÉ1, ùúé1)
= (ùëÑ, ùëü) %ùëô1
= ùëô.
Case 3: ùëÉ is of the form ‚ÄúIf‚Äù. ùëÉ expands to ‚Äúif ùëÑ then ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol.
Case 3.1: ùúé(ùëÑ) = ‚àÖ.
119
Since ùúé ‚ä¢ùëÉ ‚áìexec ùëí, by Figure 4-2, there exists a list of query-
result pairsùëí2 such thatùëí = (ùëÑ, 0) @ ùëí2 and ùúé ‚ä¢ùëÉ2 ‚áìexec ùëí2. By
Lemma 4.4.1,ùëí = (ùëÑ1, ùëü1) @ ùëí2.
Since ùúé ‚ä¢ùëÉ ‚áìloops ùëô, by Figure 4-3, there exists a loop layout tree
ùëô2 such thatùëô = (ùëÑ, 0) %ùëô2 and ùúé ‚ä¢ùëÉ2 ‚áìloops ùëô2. By Lemma 4.4.1,
ùëô = (ùëÑ1, ùëü1) %ùëô2.
By Lemma 4.4.1, ùëü1 = |ùúé(ùëÑ)|= 0 . In Algorithm 9, execution
enters the branch on line 12. By Definition 3.4.4, variableùúé‚Ä≤= ùúé.
Also, variables ùëí‚Ä≤ = ùëí2 and ùëÉ‚Ä≤ = ùëÉ2. Algorithm 9 recursively
calls DetectLoopsAux(ùëí2, ùëÉ2, ùúé) on line 20, which returnsùëô2 by
the induction hypothesis. Hence DetectLoopsAux(ùëí, ùëÉ, ùúé) =
(ùëÑ1, ùëü1) %DetectLoopsAux(ùëí2, ùëÉ2, ùúé) = (ùëÑ, 0) %ùëô2 = ùëô.
Case 3.2: ùúé(ùëÑ) Ã∏= ‚àÖ. The proof is similar to the proof of Case 2.
Case 4: ùëÉ is of the form ‚ÄúFor‚Äù. ùëÉ expands to ‚Äúfor ùëÑ do ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol.
Case 4.1: ùúé(ùëÑ) = ‚àÖ. The proof is similar to the proof of Case 3.1.
Case 4.2: |ùúé(ùëÑ)|= 1. The proof is similar to the proof of Case 2.
Case 4.3: |ùúé(ùëÑ)|= ùëü ‚â•2.
Let ùë•1, . . . , ùë•ùëü be the rows ofùúé(ùëÑ), ùúé(ùëÑ) = ( ùë•1, . . . , ùë•ùëü). For ùëñ =
1, . . . , ùëü, letùúéùëñ = ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùë•ùëñ].
Since ùúé ‚ä¢ùëÉ ‚áìexec ùëí, by Figure 4-2, there exists lists of query-
result pairsùëí1, . . . , ùëíùëü such thatùëí = (ùëÑ, ùëü) @ ùëí1 @ . . .@ ùëíùëü and ùúéùëñ ‚ä¢
ùëÉ1 ‚áìexec ùëíùëñ for each ùëñ = 1 , . . . , ùëü. By Lemma 4.4.1, ùëü = ùëü1 and
ùëí = (ùëÑ1, ùëü1) @ ùëí1 @ . . .@ ùëíùëü1 .
Since ùúé ‚ä¢ùëÉ ‚áìloops ùëô, by Figure 4-3, there exists loop layout trees
ùëô1, . . . , ùëôùëü such thatùëô = (ùëÑ, ùëü) ‚ü≥(ùëô1, . . . , ùëôùëü) and ùúéùëñ ‚ä¢ùëÉ1 ‚áìloops ùëôùëñ for
each ùëñ = 1, . . . , ùëü.
120
Since ùëü ‚â•2, by Lemma 4.4.1,ùëÑ.ùë¶ ‚ààT(ùëÉ0). By Definition 3.3.4,
ùëÑ.ùë¶ Ã∏‚ààR(ùëÉ0). By Definition 4.3.3,C(ùúãSF(ùëÉ1), ùëÉ1) ‚â§1.
By Definition 3.3.4 and Algorithm 8,ùëÉ1 Ã∏= ùúñ. By Definition 4.3.2,
C(ùúãSF(ùëÉ1), ùëÉ1) ‚â•1. Hence, C(ùúãSF(ùëÉ1), ùëÉ1) = 1.
By Figure 4-2, ùúãSF(ùëÉ1) appears in the first query-result pair in
each ùëíùëñ (ùëñ = 1 , . . . , ùëü1) and not in any other query-result pairs.
In Algorithm 9, the branch on line 8 executes if and only if the
query under inspection comes from the first query-result pair of
any ùëíùëñ (ùëñ = 1, . . . , ùëü1). Hence, the length ofùëé equals ùëü1 on line 12.
Execution does not enter the branch on this line.
Execution continues to the loop on line 24. In theùëñ-th iteration
of this loop, variableùëè is the index of the first query-result pair
of ùëíùëñ and variableùëê is the index of the last query-result pair ofùëíùëñ
(ùëñ = 1, . . . , ùëü1). By Lemma 4.4.1, variableùúé‚Ä≤= ùúé[ùëÑ1.ùë¶ ‚Ü¶‚Üíùë•ùëñ] = ùúéùëñ.
Also, variablesùëí‚Ä≤ = ùëíùëñ and ùëÉ‚Ä≤ = ùëÉ1. Algorithm 9 recursively calls
DetectLoopsAux(ùëíùëñ, ùëÉ1, ùúéùëñ) on line 30, which returnsùëôùëñ by the
induction hypothesis. Hence
DetectLoopsAux(ùëí, ùëÉ, ùúé)
= ( ùëÑ1, ùëü1) ‚ü≥(DetectLoopsAux(ùëí1, ùëÉ1, ùúé1), . . . ,
DetectLoopsAux(ùëíùëü, ùëÉ1, ùúéùëü1 ))
= ( ùëÑ, ùëü) ‚ü≥(ùëô1, . . . , ùëôùëü)
= ùëô.
Theorem 1(Loop Detection). For any programùëÉ ‚ààK and contextùúé ‚ààContext, if
ùúé ‚ä¢ùëÉ ‚áìexec ùëí and ùúé ‚ä¢ùëÉ ‚áìloops ùëô then DetectLoops(ùëí) = ùëô.
Proof. By Lemma 4.4.2, DetectLoopsAux(ùëí, ùëÉ, ùúé) = ùëô. Since Algorithm 9 and
Algorithm 3 differ only in the auxiliary variables,DetectLoops(ùëí) = ùëô.
121
Algorithm 9Loop detection algorithm (Algorithm 3) with auxiliary variables
Input: ùëí is either Nil or a nonempty list of query-result pairs(ùëÑ1, ùëü1) , . . . ,(ùëÑùëõ, ùëüùëõ).
Input: ùëÉ ‚ààProg is an auxiliary variable used only in the soundness proof.
Input: ùúé ‚ààContext is an auxiliary variable used only in the soundness proof.
Output: Loop layout tree constructed fromùëí.
1: procedure DetectLoopsAux(ùëí, ùëÉ, ùúé)
2: if ùëí = Nil then
3: return Nil
4: end if
5: (ùëÑ1, ùëü1) , . . . ,(ùëÑùëõ, ùëüùëõ) ‚Üêùëí
6: ùëé ‚Üêempty list
7: for ùëó ‚Üê2, 3, . . . , ùëõdo ‚óÅ Identify repetitions
8: if ùúãSùëÑùëó = ùúãSùëÑ2 then
9: Append ùëó to ùëé
10: end if
11: end for
12: if ùëü1 ‚â§1 or ùëü1 Ã∏= len(ùëé) then ‚óÅ Did not find repetitions caused by any loops that
iterate overùëÑ1
13: ùëí‚Ä≤‚Üê(ùëÑ2, ùëü2) , . . . ,(ùëÑùëõ, ùëüùëõ)
14: ùúé‚Ä≤‚Üêùúé[ùëÑ1.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ1)]
15: if ùëü1 = 0then
16: ùëÉ‚Ä≤‚ÜêSubprogram ofùëÉ in the empty branch
17: else
18: ùëÉ‚Ä≤‚ÜêSubprogram ofùëÉ in the nonempty branch
19: end if
20: ùëô ‚ÜêDetectLoopsAux(ùëí‚Ä≤, ùëÉ‚Ä≤, ùúé‚Ä≤)
21: return (ùëÑ1, ùëü1) %ùëô
22: else ‚óÅ Found a loop that iterates overùëÑ1
23: Append ùëõ + 1to ùëé
24: for ùëó ‚Üê1, 2, . . . , ùëü1 do
25: ùëè ‚Üêùëé[ùëó]
26: ùëê ‚Üêùëé[ùëó + 1]‚àí1
27: ùëí‚Ä≤‚Üê(ùëÑùëè, ùëüùëè) , . . . ,(ùëÑùëê, ùëüùëê)
28: ùúé‚Ä≤‚Üêùúé[ùëÑ1.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ1)[ùëó]]
29: ùëÉ‚Ä≤‚ÜêSubprogram ofùëÉ in the nonempty branch
30: ùëôùëó ‚ÜêDetectLoopsAux(ùëí‚Ä≤, ùëÉ‚Ä≤, ùúé‚Ä≤)
31: end for
32: return (ùëÑ1, ùëü1) ‚ü≥(ùëô1, . . . , ùëôùëü1 )
33: end if
34: end procedure
122
4.5 Soundness of GetTrace
We show that the outcome ofMatchPathcorresponds to a path through the pro-
gram‚Äôs abstract syntax tree and corresponds to a path through the loop layout tree
(Lemma 4.5.9). We then show the soundness ofGetTrace (Theorem 2).
To facilitate discussion we first introduce notation for reasoning about subtrees of
the program AST (Section 4.5.1) and subtrees of the loop layout tree (Section 4.5.2).
4.5.1 Traversing the Program AST
Proposition 4.5.1.For any programsùëÉ1, ùëÉ2, ùëÉ3 ‚ààProg and annotated tracesùë°1, ùë°2:
1. if ùëÉ1
ùë°1
‚àí ‚ÜíùëÉ2 and ùëÉ2
ùë°2
‚àí ‚ÜíùëÉ3 then ùëÉ1
ùë°1 @ ùë°2
‚àí‚àí‚àí‚ÜíùëÉ3.
2. if ùëÉ1
ùë°1
‚àí ‚ÜíùëÉ2 and ùëÉ1
ùë°1 @ ùë°2
‚àí‚àí‚àí‚ÜíùëÉ3 then ùëÉ2
ùë°2
‚àí ‚ÜíùëÉ3.
Proof. By induction on the length ofùë°1 and the derivation ofùëÉ1.
Remark. Note that the reverse direction of subtraction does not hold. IfùëÉ2
ùë°2
‚àí ‚ÜíùëÉ3
and ùëÉ1
ùë°1 @ ùë°2
‚àí‚àí‚àí‚ÜíùëÉ3, ùëÉ1
ùë°1
‚àí ‚ÜíùëÉ2 may not hold. Consider the following programs:
ùëÉ1 = ùëÑ1 ùëÑ2
ùëÉ2 = if ùëÑ2 then ùëÑ3 else ùúñ
ùëÉ3 = ùúñ
Let ùë°1 = ‚ü®ùëÑ1, 0, NotLoop‚ü©and ùë°2 = ‚ü®ùëÑ2, 0, NotLoop‚ü©. By Figure 4-4, ùëÉ2
ùë°2
‚àí ‚Üíùúñ,
ùëÉ1
ùë°1 @ ùë°2
‚àí‚àí‚àí‚Üíùúñ, andùëÉ1
ùë°1
‚àí ‚ÜíùëÑ2. However,ùëÑ2 Ã∏= ùëÉ2.
Proposition 4.5.2.For any programsùëÉ1, ùëÉ2 ‚ààProg and annotated tracesùë°1, ùë°2, if
ùëÉ1
ùë°1 @ ùë°2
‚àí‚àí‚àí‚ÜíùëÉ2 then there exists programùëÉ3 ‚ààProg such thatùëÉ1
ùë°1
‚àí ‚ÜíùëÉ3.
Proof. The proof is by induction on the length ofùë°1 and the derivation ofùëÉ1.
Case 1: ùë°1 = Nil. Let ùëÉ3 = ùëÉ1. By Figure 4-4,ùëÉ1
Nil
‚àí‚ÜíùëÉ1.
Case 2: ùë°1 = ‚ü®ùëÑ‚Ä≤, ùëü, ùúÜ‚ü©@ ùë°‚Ä≤
1. We haveùë°1 @ ùë°2 = ‚ü®ùëÑ‚Ä≤, ùëü, ùúÜ‚ü©@ ùë°‚Ä≤
1 @ ùë°2.
123
Case 2.1: ùëÉ1 = ùúñ. Since ùë°1 @ ùë°2 Ã∏= Nil, it is not possible to haveùëÉ1
ùë°1 @ ùë°2
‚àí‚àí‚àí‚ÜíùëÉ2
by Figure 4-4.
Case 2.2: ùëÉ1 is of the form ‚ÄúSeq‚Äù.ùëÉ1 expands to ‚ÄúùëÑ ùëÉ‚Ä≤
1‚Äù, whereùëÑ corresponds
to the Query symbol andùëÉ‚Ä≤
1 corresponds to the Prog symbol.
Since ùëÉ1
ùë°1 @ ùë°2
‚àí‚àí‚àí‚ÜíùëÉ2, by Figure 4-4,ùëÑ .= ùëÑ‚Ä≤ and ùëÉ‚Ä≤
1
ùë°‚Ä≤
1 @ ùë°2
‚àí‚àí‚àí‚ÜíùëÉ2. By
the induction hypothesis, there exists program ùëÉ3 ‚àà Prog such
that ùëÉ‚Ä≤
1
ùë°‚Ä≤
1
‚àí ‚ÜíùëÉ3. By Figure 4-4,ùëÉ1
‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©
‚àí‚àí‚àí‚àí‚ÜíùëÉ‚Ä≤
1. By Proposition 4.5.1,
ùëÉ1
ùë°1
‚àí ‚ÜíùëÉ3.
Case 2.3: ùëÉ is of the form ‚ÄúIf‚Äù.ùëÉ expands to ‚Äúif ùëÑ then ùëÉ‚Ä≤
1 else ùëÉ‚Ä≤
2‚Äù, where
ùëÑ corresponds to the Query symbol,ùëÉ‚Ä≤
1 corresponds to the first
Prog symbol, andùëÉ‚Ä≤
2 corresponds to the second Prog symbol.
Case 2.3.1: ùëü >0. The proof is similar to the proof of Case 2.2.
Case 2.3.2: ùëü = 0.
SinceùëÉ1
ùë°1 @ ùë°2
‚àí‚àí‚àí‚ÜíùëÉ2, byFigure4-4, ùëÑ .= ùëÑ‚Ä≤andùëÉ‚Ä≤
2
ùë°‚Ä≤
1 @ ùë°2
‚àí‚àí‚àí‚Üí
ùëÉ2.
Bytheinductionhypothesis, thereexistsprogram ùëÉ3 ‚àà
Prog such thatùëÉ‚Ä≤
2
ùë°‚Ä≤
1
‚àí ‚ÜíùëÉ3. By Figure 4-4,ùëÉ1
‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©
‚àí‚àí‚àí‚àí‚ÜíùëÉ‚Ä≤
2.
By Proposition 4.5.1,ùëÉ1
ùë°1
‚àí ‚ÜíùëÉ3.
Case 2.4: ùëÉ is of the form ‚ÄúFor‚Äù. ùëÉ expands to ‚Äúfor ùëÑ do ùëÉ1 else ùëÉ2‚Äù,
where ùëÑ corresponds to the Query symbol,ùëÉ1 corresponds to the
first Prog symbol, andùëÉ2 corresponds to the second Prog symbol.
The proof is similar to the proof of Case 2.3.
Proposition 4.5.3.For any programùëÉ ‚ààProg, context ùúé ‚ààContext, loop layout
tree ùëô such thatùúé ‚ä¢ùëÉ ‚áìloops ùëô, and annotated traceùë° ‚ààGetAnnotatedTrace(ùëô),
we haveùëÉ
ùë°
‚àí ‚Üíùúñ.
Proof. This proof is by induction on the derivation ofùëÉ.
124
Case 1: ùëÉ = ùúñ.
By Figure 4-3,ùúé ‚ä¢ùëÉ ‚áìloops Nil. By Algorithm 4,
GetAnnotatedTrace(Nil) = {Nil}.
Hence ùë° = Nil. By Figure 4-4,ùúñ
Nil
‚àí‚Üíùúñ.
Case 2: ùëÉ is of the form ‚ÄúSeq‚Äù.ùëÉ expands to ‚ÄúùëÑ ùëÉ1‚Äù, where ùëÑ corresponds to the
Query symbol andùëÉ1 corresponds to the Prog symbol.
Let ùúé1 = ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ)] and ùëü = |ùúé(ùëÑ)|.
Since ùúé ‚ä¢ùëÉ ‚áìloops ùëô, by Figure 4-3, there exists a loop layout treeùëô1 such
that ùëô = (ùëÑ, ùëü) %ùëô1 and ùúé1 ‚ä¢ùëÉ1 ‚áìloops ùëô1. By Algorithm 4,
GetAnnotatedTrace(ùëô)
= {‚ü®ùëÑ, ùëü,NotLoop‚ü©@ ùë°‚Ä≤|ùë°‚Ä≤‚ààGetAnnotatedTrace(ùëô1) }.
Since ùë° ‚ààGetAnnotatedTrace(ùëô), there exists
ùë°‚Ä≤‚ààGetAnnotatedTrace(ùëô1)
such thatùë° = ‚ü®ùëÑ, ùëü,NotLoop‚ü©@ ùë°‚Ä≤.
By the induction hypothesis,ùëÉ1
ùë°‚Ä≤
‚àí ‚Üíùúñ. By Figure 4-4,ùëÉ
ùë°
‚àí ‚Üíùúñ.
Case 3: ùëÉ is of the form ‚ÄúIf‚Äù. ùëÉ expands to ‚Äúif ùëÑ then ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol. The proof is similar to the
proof of Case 2.
Case 4: ùëÉ is of the form ‚ÄúFor‚Äù. ùëÉ expands to ‚Äúfor ùëÑ do ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol.
125
Case 4.1: |ùúé(ùëÑ)|‚â§ 1. The proof is similar to the proof of Case 2.
Case 4.2: |ùúé(ùëÑ)|= ùëü ‚â•2.
Let ùë•1, . . . , ùë•ùëü be the rows ofùúé(ùëÑ), ùúé(ùëÑ) = (ùë•1, . . . , ùë•ùëü). Let ùúéùëñ =
ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùë•ùëñ] for eachùëñ = 1, . . . , ùëü.
Since ùúé ‚ä¢ùëÉ ‚áìloops ùëô, by Figure 4-3, there exists loop layout trees
ùëô1, . . . , ùëôùëü such thatùëô = (ùëÑ, ùëü) ‚ü≥(ùëô1, . . . , ùëôùëü) and ùúéùëñ ‚ä¢ùëÉ1 ‚áìloops ùëôùëñ for
each ùëñ = 1, . . . , ùëü. By Algorithm 4,GetAnnotatedTrace(ùëô) =
‚à™ùëü
ùëñ=1{‚ü®ùëÑ, ùëü, ùëñ‚ü©@ ùë°‚Ä≤|ùë°‚Ä≤‚ààGetAnnotatedTrace(ùëôùëñ) }.
Since ùë° ‚àà GetAnnotatedTrace(ùëô), there exists integer ùëñ ‚àà
{1, . . . , ùëü} and ùë°‚Ä≤ ‚àà GetAnnotatedTrace(ùëôùëñ) such that ùë° =
‚ü®ùëÑ, ùëü, ùëñ‚ü©@ ùë°‚Ä≤.
By the induction hypothesis,ùëÉ1
ùë°‚Ä≤
‚àí ‚Üíùúñ. By Figure 4-4,ùëÉ
ùë°
‚àí ‚Üíùúñ.
4.5.2 Traversing the Loop Layout Tree
Proposition 4.5.4.For any loop layout treesùëô1, ùëô2, ùëô3 and annotated tracesùë°1, ùë°2:
1. if ùëô1
ùë°1
Àì‚àí ‚Üíùëô2 and ùëô2
ùë°2
Àì‚àí ‚Üíùëô3 then ùëô1
ùë°1 @ ùë°2
Àì‚àí‚àí‚àí‚Üíùëô3.
2. if ùëô1
ùë°1
Àì‚àí ‚Üíùëô2 and ùëô1
ùë°1 @ ùë°2
Àì‚àí‚àí‚àí‚Üíùëô3 then ùëô2
ùë°2
Àì‚àí ‚Üíùëô3.
Proof. By induction on the length ofùë°1 and the derivation ofùëô1.
Remark. Note that the reverse direction of subtraction does not hold. Ifùëô2
ùë°2
Àì‚àí ‚Üíùëô3 and
ùëô1
ùë°1 @ ùë°2
Àì‚àí‚àí‚àí‚Üíùëô3, ùëô1
ùë°1
Àì‚àí ‚Üíùëô2 may not hold. Consider the following loop layout trees:
ùëô1 = (ùëÑ1, 0) % (ùëÑ2, 2) ‚ü≥( (ùëÑ3, 0) %Nil, (ùëÑ3, 3) %Nil)
ùëô2 = (ùëÑ2, 2) ‚ü≥( (ùëÑ3, 0) %Nil, (ùëÑ3, 1) %Nil)
ùëô3 = (ùëÑ3, 0) %Nil
Let ùë°1 = ‚ü®ùëÑ1, 0, NotLoop‚ü©and ùë°2 = ‚ü®ùëÑ2, 2, 1‚ü©. By Figure 4-5, ùëô2
ùë°2
Àì‚àí ‚Üíùëô3, ùëô1
ùë°1 @ ùë°2
Àì‚àí‚àí‚àí‚Üíùëô3,
and ùëô1
ùë°1
Àì‚àí ‚Üíùëô‚Ä≤
2 where ùëô‚Ä≤
2 = (ùëÑ2, 2) ‚ü≥( (ùëÑ3, 0) %Nil, (ùëÑ3, 3) %Nil). However,ùëô2 Ã∏= ùëô‚Ä≤
2.
126
Proposition 4.5.5. For any loop layout treesùëô1, ùëô2 and annotated traces ùë°1, ùë°2, if
ùëô1
ùë°1 @ ùë°2
Àì‚àí‚àí‚àí‚Üíùëô2 then there exists loop layout treeùëô3 such thatùëô1
ùë°1
Àì‚àí ‚Üíùëô3.
Proof. The proof is by induction on the length ofùë°1 and the derivation ofùëô1.
Case 1: ùë°1 = Nil. Let ùëô3 = ùëô1. By Figure 4-5,ùëô1
Nil
Àì‚àí‚Üíùëô1.
Case 2: ùë°1 = ‚ü®ùëÑ‚Ä≤, ùëü, ùúÜ‚ü©@ ùë°‚Ä≤
1. We haveùë°1 @ ùë°2 = ‚ü®ùëÑ‚Ä≤, ùëü, ùúÜ‚ü©@ ùë°‚Ä≤
1 @ ùë°2.
Case 2.1: ùëô1 = Nil. Since ùë°1 @ ùë°2 Ã∏= Nil, it is not possible to haveùëô1
ùë°1 @ ùë°2
Àì‚àí‚àí‚àí‚Üíùëô2
by Figure 4-5.
Case 2.2: ùëô1 = (ùëÑ, ùëü) %ùëô‚Ä≤
1.
Since ùëô1
ùë°1 @ ùë°2
Àì‚àí‚àí‚àí‚Üíùëô2, by Figure 4-5, ùëÑ .= ùëÑ‚Ä≤, ùúÜ = NotLoop, and
ùëô‚Ä≤
1
ùë°‚Ä≤
1 @ ùë°2
Àì‚àí‚àí‚àí‚Üíùëô2. By the induction hypothesis, there exists loop lay-
out tree ùëô3 such that ùëô‚Ä≤
1
ùë°‚Ä≤
1
Àì‚àí ‚Üíùëô3. By Figure 4-5, ùëô1
‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©
Àì‚àí‚àí‚àí‚àí‚Üíùëô‚Ä≤
1. By
Proposition 4.5.4,ùëô1
ùë°1
Àì‚àí ‚Üíùëô3.
Case 2.3: ùëô1 = (ùëÑ‚Ä≤, ùëü) ‚ü≥(ùëô‚Ä≤
1, . . . , ùëô‚Ä≤
ùëü).
Since ùëô1
ùë°1 @ ùë°2
Àì‚àí‚àí‚àí‚Üíùëô2, by Figure 4-5,ùëÑ .= ùëÑ‚Ä≤, 1 ‚â§ùúÜ ‚â§ùëü, andùëô‚Ä≤
ùúÜ
ùë°‚Ä≤
1 @ ùë°2
Àì‚àí‚àí‚àí‚Üí
ùëô2. Bytheinductionhypothesis, thereexistslooplayouttree ùëô3 such
that ùëô‚Ä≤
ùúÜ
ùë°‚Ä≤
1
Àì‚àí ‚Üíùëô3. By Figure 4-5,ùëô1
‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©
Àì‚àí‚àí‚àí‚àí‚Üíùëô‚Ä≤
ùúÜ. By Proposition 4.5.4,
ùëô1
ùë°1
Àì‚àí ‚Üíùëô3.
Proposition 4.5.6.For any loop layout treeùëô and annotated traceùë°, we haveùë° ‚àà
GetAnnotatedTrace(ùëô) if and only ifùëô
ùë°
Àì‚àí ‚ÜíNil.
Proof. By induction on the length ofùë°.
4.5.3 Consistency with Program AST, Path Constraint, and
Loop Layout Tree
Lemma 4.5.7.For any programùëÉ ‚ààProg, path constraintùëä that is derived fromùëÉ,
context ùúé ‚ààContext that satisfiesùëä, ifùúé ‚ä¢ùëÉ ‚áìloops ùëô then there exists an annotated
traceùë° ‚ààGetAnnotatedTrace(ùëô) such thatùë° ‚àºùëä.
127
Proof Sketch.The proof is by induction on the derivation ofùëÉ.
Case 1: ùëÉ = ùúñ.
By Figure 4-3, ùëô = Nil. By Algorithm 4, GetAnnotatedTrace(ùëô) =
{Nil}.
Let ùë° = Nil, thenùë° ‚ààGetAnnotatedTrace(ùëô).
Case 1.1: ùëä = Nil.
By Definition 3.4.26,ùë° ‚àºùëä.
Case 1.2: ùëä = ‚ü®ùëÑ‚Ä≤, ùëü‚Ä≤, ùë†‚Ä≤‚ü©.
By Definition 4.3.1,F(ùëÉ) = Nil. By Definition 4.1.4, this case is
not possible.
Case 1.3: ùëä = (‚ü®ùëÑ‚Ä≤
1, ùëü‚Ä≤
1, ùë†‚Ä≤
1‚ü©, . . . ,‚ü®ùëÑ‚Ä≤
ùëö, ùëü‚Ä≤
ùëö, ùë†‚Ä≤
ùëö‚ü©), whereùëö ‚â•2.
By Definition 4.1.4, there exists an annotated traceùë°‚Ä≤ such that
ùëÉ
ùë°‚Ä≤
‚àí ‚Üíùúñ and ùë°‚Ä≤‚àºùëä‚Ä≤, where
ùëä‚Ä≤=
(Ô∏Ä
‚ü®ùëÑ‚Ä≤
1, ùëü‚Ä≤
1, ùë†‚Ä≤
1‚ü©, . . . ,
‚ü®Ô∏Ä
ùëÑ‚Ä≤
ùëö‚àí1, ùëü‚Ä≤
ùëö‚àí1, ùë†‚Ä≤
ùëö‚àí1
‚ü©Ô∏Ä
, ‚ü®ùëÑ‚Ä≤
ùëö, ùëü‚Ä≤, ùë†‚Ä≤
ùëö‚ü©
)Ô∏Ä
for some row constraintùëü‚Ä≤. By Figure 4-4, ùë°‚Ä≤ = Nil. By Defini-
tion 3.4.26, this case is not possible.
Case 2: ùëÉ is of the form ‚ÄúSeq‚Äù.ùëÉ expands to ‚ÄúùëÑ ùëÉ1‚Äù, where ùëÑ corresponds to the
Query symbol andùëÉ1 corresponds to the Prog symbol.
Let ùúé‚Ä≤ = ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ)]. By Figure 4-5, there exists a loop layout treeùëô‚Ä≤
such thatùëô = (ùëÑ, |ùúé(ùëÑ)|) %ùëô‚Ä≤ and ùúé‚Ä≤‚ä¢ùëÉ1 ‚áìloops ùëô‚Ä≤.
Case 2.1: ùëä = Nil.
By Algorithm 4, GetAnnotatedTrace(ùëô‚Ä≤) Ã∏= ‚àÖ. Hence there
exists an annotated trace ùë°‚Ä≤ ‚ààGetAnnotatedTrace(ùëô‚Ä≤). Let
ùë° = ‚ü®ùëÑ, |ùúé(ùëÑ)|, NotLoop‚ü©@ ùë°‚Ä≤. By Algorithm 4,
ùë° ‚ààGetAnnotatedTrace(ùëô).
128
By Definition 3.4.26,ùë° ‚àºùëä.
Case 2.2: ùëä = ‚ü®ùëÑ‚Ä≤, ùëü‚Ä≤, ùë†‚Ä≤‚ü©.
By Definition 3.4.20,|ùúé(ùëÑ‚Ä≤)|‚âÉ ùëü‚Ä≤. By Definition 4.3.1,F(ùëÉ) = ùëÑ.
By Definition 4.1.4,ùëÑ‚Ä≤ .=Nil,Nil,Nil ùëÑ. By Definition 3.4.24, Defini-
tion 3.4.22, and Definition 3.4.4,ùúé(ùëÑ) = ùúé(ùëÑ‚Ä≤). Hence|ùúé(ùëÑ)|‚âÉ ùëü‚Ä≤.
By Algorithm 4, GetAnnotatedTrace(ùëô‚Ä≤) Ã∏= ‚àÖ. Hence there
exists an annotated trace ùë°‚Ä≤ ‚ààGetAnnotatedTrace(ùëô‚Ä≤). Let
ùë° = ‚ü®ùëÑ, |ùúé(ùëÑ)|, NotLoop‚ü©@ ùë°‚Ä≤. By Algorithm 4,
ùë° ‚ààGetAnnotatedTrace(ùëô).
By Definition 3.4.26,ùë° ‚àºùëä.
Case 2.3: ùëä = (‚ü®ùëÑ‚Ä≤
1, ùëü‚Ä≤
1, ùë†‚Ä≤
1‚ü©, . . . ,‚ü®ùëÑ‚Ä≤
ùëö, ùëü‚Ä≤
ùëö, ùë†‚Ä≤
ùëö‚ü©), whereùëö ‚â•2.
By Definition 4.1.4, there exists an annotated traceùë°‚Ä≤ such that
ùëÉ
ùë°‚Ä≤
‚àí ‚Üíùúñ and ùë°‚Ä≤‚àºùëä‚Ä≤, where
ùëä‚Ä≤=
(Ô∏Ä
‚ü®ùëÑ‚Ä≤
1, ùëü‚Ä≤
1, ùë†‚Ä≤
1‚ü©, . . . ,
‚ü®Ô∏Ä
ùëÑ‚Ä≤
ùëö‚àí1, ùëü‚Ä≤
ùëö‚àí1, ùë†‚Ä≤
ùëö‚àí1
‚ü©Ô∏Ä
, ‚ü®ùëÑ‚Ä≤
ùëö, ùëü‚Ä≤, ùë†‚Ä≤
ùëö‚ü©
)Ô∏Ä
for some row constraintùëü‚Ä≤.
Let ùë°‚Ä≤ = ‚ü®ùëÑ‚Ä≤‚Ä≤, ùëü‚Ä≤‚Ä≤, ùúÜ‚Ä≤‚Ä≤‚ü©@ ùë°‚Ä≤‚Ä≤. By Definition 3.4.26,ùëÑ‚Ä≤‚Ä≤ .=Nil,Nil,Nil ùëÑ‚Ä≤
1.
Also, ùëü‚Ä≤‚Ä≤‚âÉùëü‚Ä≤
1. By Figure 4-4,ùëÑ‚Ä≤‚Ä≤ .=Nil,Nil,Nil ùëÑ.
Hence ùëÑ‚Ä≤
1
.=Nil,Nil,Nil ùëÑ. By Definition 3.4.24, Definition 3.4.22, and
Definition 3.4.4,ùúé(ùëÑ) = ùúé(ùëÑ‚Ä≤
1).
Since ùúé satisfies ùëä, by Definition 3.4.20, there exists a sequence
of contexts ùúé1, . . . , ùúéùëö ‚ààContext that are updated according to
the evaluation of the queriesùëÑ‚Ä≤
1, . . . , ùëÑ‚Ä≤
ùëö in ùúé and |ùúéùëñ(ùëÑ‚Ä≤
ùëñ)|‚âÉ ùëü‚Ä≤
ùëñ for
all ùëñ = 1, . . . , ùëö. Since ùúé1 = ùúé, we haveùúé(ùëÑ) = ùúé1(ùëÑ‚Ä≤
1). Hence
|ùúé(ùëÑ)|‚âÉ ùëü‚Ä≤
1.
Since ùëÉ
ùë°‚Ä≤
‚àí ‚Üíùúñ, by Figure 4-4,ùëÉ1
ùë°‚Ä≤‚Ä≤
‚àí ‚Üíùúñ.
Let ùëä‚Ä≤‚Ä≤ =
(Ô∏Ä
‚ü®ùëÑ‚Ä≤
2, ùëü‚Ä≤
2, ùë†‚Ä≤
2‚ü©, . . . ,
‚ü®Ô∏Ä
ùëÑ‚Ä≤
ùëö‚àí1, ùëü‚Ä≤
ùëö‚àí1, ùë†‚Ä≤
ùëö‚àí1
‚ü©Ô∏Ä
, ‚ü®ùëÑ‚Ä≤
ùëö, ùëü‚Ä≤, ùë†‚Ä≤
ùëö‚ü©
)Ô∏Ä
. By
129
Definition 3.4.26,ùë°‚Ä≤‚Ä≤‚àºùëä‚Ä≤‚Ä≤.
Let ùëä‚Ä≤‚Ä≤‚Ä≤ = ( ‚ü®ùëÑ‚Ä≤
2, ùëü‚Ä≤
2, ùë†‚Ä≤
2‚ü©, . . . ,‚ü®ùëÑ‚Ä≤
ùëö, ùëü‚Ä≤
ùëö, ùë†‚Ä≤
ùëö‚ü©). By Definition 4.1.4,
ùëä‚Ä≤‚Ä≤‚Ä≤ is derived fromùëÉ1.
By Definition 3.4.20, ùúé2 satisfies ùëä‚Ä≤‚Ä≤‚Ä≤. Also, ùúé2 = ùúé1[ùëÑ‚Ä≤
1.ùë¶ ‚Ü¶‚Üí
ùúé1(ùëÑ‚Ä≤
1)] = ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ)] = ùúé‚Ä≤. Hence ùúé‚Ä≤ satisfies ùëä‚Ä≤‚Ä≤‚Ä≤.
Since ùúé‚Ä≤ ‚ä¢ùëÉ1 ‚áìloops ùëô‚Ä≤, by the induction hypothesis, there exists
an annotated trace ùë°‚Ä≤‚Ä≤‚Ä≤ ‚àà GetAnnotatedTrace(ùëô‚Ä≤) such that
ùë°‚Ä≤‚Ä≤‚Ä≤‚àºùëä‚Ä≤‚Ä≤‚Ä≤.
Let ùë° = ‚ü®ùëÑ, |ùúé(ùëÑ)|, NotLoop‚ü©@ ùë°‚Ä≤‚Ä≤‚Ä≤. Since ùëô = ( ùëÑ, |ùúé(ùëÑ)|) %ùëô‚Ä≤, by
Algorithm 4,ùë° ‚ààGetAnnotatedTrace(ùëô).
Since |ùúé(ùëÑ)|‚âÉ ùëü‚Ä≤
1, by Definition 3.4.26,ùë° ‚àºùëä.
Case 3: ùëÉ is of the form ‚ÄúIf‚Äù. ùëÉ expands to ‚Äúif ùëÑ then ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol.
Case 3.1: |ùúé(ùëÑ)|‚â• 1.
Let ùúé‚Ä≤= ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ)]. By Figure 4-5, there exists a loop layout
tree ùëô‚Ä≤ such thatùëô = (ùëÑ, |ùúé(ùëÑ)|) %ùëô‚Ä≤ and ùúé‚Ä≤‚ä¢ùëÉ1 ‚áìloops ùëô‚Ä≤.
Case 3.1.1: ùëä = Nil. The proof is similar to the proof of Case 2.1.
Case 3.1.2: ùëä = ‚ü®ùëÑ‚Ä≤, ùëü‚Ä≤, ùë†‚Ä≤‚ü©. The proof is similar to the proof of
Case 2.2.
Case 3.1.3: ùëä = (‚ü®ùëÑ‚Ä≤
1, ùëü‚Ä≤
1, ùë†‚Ä≤
1‚ü©, . . . ,‚ü®ùëÑ‚Ä≤
ùëö, ùëü‚Ä≤
ùëö, ùë†‚Ä≤
ùëö‚ü©), whereùëö ‚â•2. .
The proof is similar to the proof of Case 2.3. The main
modification is the proof ofùëÉ1
ùë°‚Ä≤‚Ä≤
‚àí ‚Üíùúñ: Since|ùúé(ùëÑ)|‚â• 1,
by Definition 3.4.19,ùëü‚Ä≤
1 = (‚â•1) or ùëü‚Ä≤
1 = (‚â•2). Either
case, sinceùëü‚Ä≤‚Ä≤ ‚âÉùëü‚Ä≤
1, we haveùëü‚Ä≤‚Ä≤ ‚â•1. Since ùëÉ
ùë°‚Ä≤
‚àí ‚Üíùúñ, by
Figure 4-4,ùëÉ1
ùë°‚Ä≤‚Ä≤
‚àí ‚Üíùúñ.
Case 3.2: |ùúé(ùëÑ)|= 0. The proof is similar to the proof of Case 3.1.
130
Case 4: ùëÉ is of the form ‚ÄúFor‚Äù. ùëÉ expands to ‚Äúfor ùëÑ do ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol.
Case 4.1: |ùúé(ùëÑ)|‚â• 2.
Let ùúé(ùëÑ) = (ùë•1, . . . , ùë•ùëü), whereùëü = |ùúé(ùëÑ)|‚â• 2. Let ùúé‚Ä≤
ùëñ = ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üí
ùë•ùëñ] for each ùëñ = 1, . . . , ùëü. By Figure 4-3, there exists loop layout
trees ùëô‚Ä≤
1, . . . , ùëô‚Ä≤
ùëü such thatùëô = (ùëÑ, ùëü) ‚ü≥(ùëô‚Ä≤
1, . . . , ùëô‚Ä≤
ùëü) and ùúé‚Ä≤
ùëñ ‚ä¢ùëÉ1 ‚áìloops
ùëô‚Ä≤
ùëñ for allùëñ = 1, . . . , ùëü.
Case 4.1.1: ùëä = Nil. The proof is similar to the proof of Case 2.1.
Case 4.1.2: ùëä = ‚ü®ùëÑ‚Ä≤, ùëü‚Ä≤, ùë†‚Ä≤‚ü©. The proof is similar to the proof of
Case 2.2.
Case 4.1.3: ùëä = (‚ü®ùëÑ‚Ä≤
1, ùëü‚Ä≤
1, ùë†‚Ä≤
1‚ü©, . . . ,‚ü®ùëÑ‚Ä≤
ùëö, ùëü‚Ä≤
ùëö, ùë†‚Ä≤
ùëö‚ü©), whereùëö ‚â•2.
The proof is similar to the proof of Case 3.1.3. The
mainmodificationsarethereasoningafterdefining ùëä‚Ä≤‚Ä≤‚Ä≤:
By Definition 4.1.4,ùë†‚Ä≤
1 = true. By Definition 3.4.20,
there exists integerùëò1 such that1 ‚â§ùëò1 ‚â§|ùúé1(ùëÑ‚Ä≤
1)|=
|ùúé(ùëÑ)|= ùëü andùúé2 = ùúé1[ùëÑ‚Ä≤
1.ùë¶ ‚Ü¶‚Üíùúé1(ùëÑ‚Ä≤
1)[ùëò1]] = ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üí
ùë•ùëò1 ] = ùúé‚Ä≤
ùëò1 . Hence ùúé‚Ä≤
ùëò1 satisfies ùëä‚Ä≤‚Ä≤‚Ä≤.
Since ùúé‚Ä≤
ùëò1 ‚ä¢ùëÉ1 ‚áìloops ùëô‚Ä≤
ùëò1 , by the induction hypothesis,
there exists an annotated trace
ùë°‚Ä≤‚Ä≤‚Ä≤‚ààGetAnnotatedTrace(ùëô‚Ä≤
ùëò1 )
such thatùë°‚Ä≤‚Ä≤‚Ä≤‚àºùëä‚Ä≤‚Ä≤‚Ä≤.
Let ùë° = ‚ü®ùëÑ, ùëü, ùëò1‚ü©@ ùë°‚Ä≤‚Ä≤‚Ä≤. Since ùëô = (ùëÑ, ùëü) ‚ü≥(ùëô‚Ä≤
1, . . . , ùëô‚Ä≤
ùëü),
by Algorithm 4,ùë° ‚ààGetAnnotatedTrace(ùëô).
Since ùëü = |ùúé(ùëÑ)|‚âÉ ùëü‚Ä≤
1, by Definition 3.4.26,ùë° ‚àºùëä.
Case 4.2: |ùúé(ùëÑ)|= 1. The proof is similar to the proof of Case 3.1.
Case 4.3: |ùúé(ùëÑ)|= 0. The proof is similar to the proof of Case 3.1.
131
In this proof sketch we reuse the notation in Definition 3.4.26 when stating
‚Äúùë°‚Ä≤‚Ä≤ ‚àºùëä‚Ä≤‚Ä≤‚Äù in Case 2.3. To complete the proof, we slightly revise this expression,
as well as the expression ‚Äúùë° ‚àºùëä‚Äù in the induction hypothesis, as follows. Generalize
Definition 3.4.26 to work with subprograms. Specifically, define what it means for
a suffix of an annotated trace to be consistent with a suffix of a path constraint,
with respect to a prefix of the path constraint. This prefix of the path constraint
specifies the path through the program to reach the subprogram that generates the
trace suffix. Passing along this prefix of the path constraint is straightforward, as we
have done systematically in Figure 4-1, Algorithm 8, and Lemma 4.2.14. This prefix
of the path constraint is useful for reasoning about the equivalence of the queries in
ùë°‚Ä≤‚Ä≤ and ùëä‚Ä≤‚Ä≤.
Lemma 4.5.8. For any programùëÉ ‚ààProg, path constraintùëä that is derived from
ùëÉ, context ùúé ‚àà Context that satisfies ùëä, if ùúé ‚ä¢ ùëÉ ‚áìloops ùëô and ùëô Ã∏= Nil then
MatchPath(ùëô, ùëä) Ã∏= Nil.
Proof. Case 1: ùëä = Nil.
Since ùëô Ã∏= Nil, by Algorithm 4, there exists an annotated trace
ùë° ‚ààGetAnnotatedTrace(ùëô)
such thatùë° Ã∏= Nil. By Definition 3.4.26,ùë° ‚àºNil. In Algorithm 4, execution
enters the branch on line 6 withùë° Ã∏= Nil.
Case 2: ùëä = (‚ü®ùëÑ‚Ä≤
1, ùëü‚Ä≤
1, ùë†‚Ä≤
1‚ü©, . . . ,‚ü®ùëÑ‚Ä≤
ùëö, ùëü‚Ä≤
ùëö, ùë†‚Ä≤
ùëö‚ü©) and ùëö ‚â•1.
By Lemma 4.5.7, there exists an annotated trace
ùë°‚Ä≤‚ààGetAnnotatedTrace(ùëô)
suchthat ùë°‚Ä≤‚àºùëä. Sinceùëö ‚â•1, byDefinition3.4.26, ùë°‚Ä≤Ã∏= Nil. InAlgorithm4,
execution eventually enters the branch on line 6 with variableùë° Ã∏= Nil.
132
Lemma 4.5.9. For any programùëÉ ‚ààProg, path constraintùëä that is derived from
ùëÉ, contextùúé ‚ààContext that satisfiesùëä, loop layout treeùëô such thatùúé ‚ä¢ùëÉ ‚áìloops ùëô,
and annotated traceùë° = MatchPath(ùëô, ùëä):
1. ùë° ‚àºùëä.
2. ùëÉ
ùë°
‚àí ‚Üíùúñ.
3. ùëô
ùë°
Àì‚àí ‚ÜíNil.
Proof. Case 1: ùëô = Nil.
By Figure 4-3,ùëÉ = ùúñ. By Algorithm 4,GetAnnotatedTrace(ùëô) = {Nil}.
In Algorithm 4, execution never enters line 6 and thus returns Nil on line 10.
Hence ùë° = MatchPath(ùëô, ùëä) = Nil. By Figure 4-4,ùëÉ
ùë°
‚àí ‚Üíùúñ. By Figure 4-5,
ùëô
ùë°
Àì‚àí ‚ÜíNil.
By Definition 4.1.4,ùëä = Nil. By Definition 3.4.26,ùë° ‚àºùëä.
Case 2: ùëô Ã∏= Nil.
By Lemma 4.5.8,ùë° = MatchPath(ùëô, ùëä) Ã∏= Nil. In Algorithm 4, execution
must not return on line 10. Since GetAnnotatedTrace(ùëô) contains a
finite number of annotated traces, the execution must return on line 7. Hence
ùë° ‚ààGetAnnotatedTrace(ùëô) and ùë° ‚àºùëä.
By Proposition 4.5.3,ùëÉ
ùë°
‚àí ‚Üíùúñ. By Proposition 4.5.6,ùëô
ùë°
Àì‚àí ‚ÜíNil.
Theorem 2(Trace-Code Correspondence). For any programùëÉ ‚ààK, path constraint
ùëä that is derived fromùëÉ, contextùúé ‚ààContext that satisfiesùëä, and annotated trace
ùë°, ifùë° = GetTrace( ùëÉ , ùëä, ùúé) then there exists a loop layout treeùëô‚Ä≤ such that:
1. ùúé ‚ä¢ùëÉ ‚áìloops ùëô‚Ä≤,
2. ùë° ‚àºùëä,
133
3. ùëÉ
ùë°
‚àí ‚Üíùúñ,
4. ùëô‚Ä≤ ùë°
Àì‚àí ‚ÜíNil, and
5. ùëô‚Ä≤ and the variableùëô are identical except for equivalent variables.
Proof. Let ùëí‚Ä≤ be a list of query-result pairs such thatùúé ‚ä¢ùëÉ ‚áìexec ùëí‚Ä≤. By Proposi-
tion 4.1.7, the variableùëí in Algorithm 2 andùëí‚Ä≤ are identical except for equivalent
variables.
Let ùëô‚Ä≤ = DetectLoops(ùëí‚Ä≤). Since the variable ùëô = DetectLoops(ùëí), ùëô and ùëô‚Ä≤
are also identical except for equivalent variables. By Theorem 1,ùúé ‚ä¢ùëÉ ‚áìloops ùëô‚Ä≤.
Let ùë°‚Ä≤= MatchPath(ùëô‚Ä≤, ùëä). Since the variableùë° = MatchPath(ùëô, ùëä), ùë° and ùë°‚Ä≤
are also identical except for equivalent variables. By Lemma 4.5.9,ùë°‚Ä≤ ‚àºùëä, ùëÉ
ùë°‚Ä≤
‚àí ‚Üíùúñ,
and ùëô‚Ä≤ ùë°‚Ä≤
Àì‚àí ‚ÜíNil.
By Figure 4-4,ùëÉ
ùë°
‚àí ‚Üíùúñ. By Definition 3.4.26,ùë° ‚àºùëä. By Figure 4-5,ùëô‚Ä≤ ùë°
Àì‚àí ‚ÜíNil.
4.6 Soundness of the Core Inference Algorithm
To help characterize the execution of the core inference algorithmInferProg, we
first present a notation for reasoning about context updates (Section 4.6.1). We then
present the soundness proof ofInferProg in Section 4.6.2. We conclude with the
soundness proof ofInfer in Section 4.6.3.
4.6.1 Updating the Context while Traversing the Program
AST
Figure 4-6 presents the definition of simultaneously updating the context, traversing
a program ùëÉ ‚ààProg, and traversing a loop layout tree, by following an annotated
trace.
Proposition4.6.1. Foranyprograms ùëÉ1, ùëÉ2, ùëÉ3 ‚ààProg, contextsùúé1, ùúé2, ùúé3 ‚ààContext,
loop layout treesùëô1, ùëô2, ùëô3, and annotated tracesùë°1, ùë°2:
134
1. if
[Ô∏Åùúé1
ùëÉ1
ùëô1
]Ô∏Å
ùë°1
‚àí ‚Üí ‚Üí
[Ô∏Åùúé2
ùëÉ2
ùëô2
]Ô∏Å
and
[Ô∏Åùúé2
ùëÉ2
ùëô2
]Ô∏Å
ùë°2
‚àí ‚Üí ‚Üí
[Ô∏Åùúé3
ùëÉ3
ùëô3
]Ô∏Å
then
[Ô∏Åùúé1
ùëÉ1
ùëô1
]Ô∏Å
ùë°1 @ ùë°2
‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Åùúé3
ùëÉ3
ùëô3
]Ô∏Å
.
2. if
[Ô∏Åùúé1
ùëÉ1
ùëô1
]Ô∏Å
ùë°1
‚àí ‚Üí ‚Üí
[Ô∏Åùúé2
ùëÉ2
ùëô2
]Ô∏Å
and
[Ô∏Åùúé1
ùëÉ1
ùëô1
]Ô∏Å
ùë°1 @ ùë°2
‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Åùúé3
ùëÉ3
ùëô3
]Ô∏Å
then
[Ô∏Åùúé2
ùëÉ2
ùëô2
]Ô∏Å
ùë°2
‚àí ‚Üí ‚Üí
[Ô∏Åùúé3
ùëÉ3
ùëô3
]Ô∏Å
.
Proof. By induction on the length ofùë°1 and the derivation ofùëÉ1.
Remark. Note that the reverse direction of subtraction does not hold. If
[Ô∏Åùúé2
ùëÉ2
ùëô2
]Ô∏Å
ùë°2
‚àí ‚Üí ‚Üí[Ô∏Åùúé3
ùëÉ3
ùëô3
]Ô∏Å
and
[Ô∏Åùúé1
ùëÉ1
ùëô1
]Ô∏Å
ùë°1 @ ùë°2
‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Åùúé3
ùëÉ3
ùëô3
]Ô∏Å
,
[Ô∏Åùúé1
ùëÉ1
ùëô1
]Ô∏Å
ùë°1
‚àí ‚Üí ‚Üí
[Ô∏Åùúé2
ùëÉ2
ùëô2
]Ô∏Å
may not hold. Counter examples are
similar to that of Sections 4.5.1 and 4.5.2.
Proposition 4.6.2.For any programsùëÉ, ùëÉ‚Ä≤ ‚ààProg, contextsùúé, ùúé‚Ä≤ ‚ààContext, loop
layout treesùëô, ùëô‚Ä≤, annotated traceùë°, if
[Ô∏Å ùúé
ùëÉ
ùëô
]Ô∏Å
ùë°
‚àí ‚Üí ‚Üí
[Ô∏Å ùúé‚Ä≤
ùëÉ‚Ä≤
ùëô‚Ä≤
]Ô∏Å
then ùëÉ
ùë°
‚àí ‚ÜíùëÉ‚Ä≤ and ùëô
ùë°
Àì‚àí ‚Üíùëô‚Ä≤.
Proof. By induction on the derivation ofùëÉ.
Proposition 4.6.3. For any programs ùëÉ, ùëÉ‚Ä≤ ‚àà Prog, context ùúé ‚àà Context, loop
layout treesùëô, ùëô‚Ä≤, and annotated query tuple‚ü®ùëÑ‚Ä≤, ùëü, ùúÜ‚ü©:
1. if ùúé ‚ä¢ùëÉ ‚áìloops ùëô, ùëÉ
‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©
‚àí‚àí‚àí‚àí‚ÜíùëÉ‚Ä≤, andùëô
‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©
Àì‚àí‚àí‚àí‚àí‚Üíùëô‚Ä≤, then there existsùúé‚Ä≤‚ààContext
such that
[Ô∏Å ùúé
ùëÉ
ùëô
]Ô∏Å ‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©
‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Å ùúé‚Ä≤
ùëÉ‚Ä≤
ùëô‚Ä≤
]Ô∏Å
.
2. for any contextùúé‚Ä≤ ‚ààContext, if ùúé ‚ä¢ùëÉ ‚áìloops ùëô and
[Ô∏Å ùúé
ùëÉ
ùëô
]Ô∏Å ‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©
‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Å ùúé‚Ä≤
ùëÉ‚Ä≤
ùëô‚Ä≤
]Ô∏Å
then
ùúé‚Ä≤‚ä¢ùëÉ‚Ä≤ ‚áìloops ùëô‚Ä≤.
Proof. 1. By induction on the derivation ofùëÉ.
2. This proof is by induction on the derivation ofùëÉ.
Case 1: ùëÉ = ùúñ.
By Figure 4-6, it is not possible to have
[Ô∏Å ùúé
ùëÉ
ùëô
]Ô∏Å ‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©
‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Å ùúé‚Ä≤
ùëÉ‚Ä≤
ùëô‚Ä≤
]Ô∏Å
.
Case 2: ùëÉ is of the form ‚ÄúSeq‚Äù.ùëÉ expands to ‚ÄúùëÑ ùëÉ1‚Äù, whereùëÑ corresponds to
the Query symbol andùëÉ1 corresponds to the Prog symbol.
By Figure 4-6, ùëü = |ùúé(ùëÑ)|, ùúé‚Ä≤ = ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üíùúé(ùëÑ)], ùëÉ‚Ä≤ = ùëÉ1, and ùëô =
(ùëÑ, ùëü) %ùëô‚Ä≤.
Since ùúé ‚ä¢ùëÉ ‚áìloops ùëô, by Figure 4-3,ùúé‚Ä≤‚ä¢ùëÉ‚Ä≤ ‚áìloops ùëô‚Ä≤.
135
Case 3: ùëÉ is of the form ‚ÄúIf‚Äù. ùëÉ expands to ‚Äúif ùëÑ then ùëÉ1 else ùëÉ2‚Äù, where
ùëÑ corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog
symbol, and ùëÉ2 corresponds to the second Prog symbol. The proof is
similar to the proof for Case 2.
Case 4: ùëÉ is of the form ‚ÄúFor‚Äù.ùëÉ expands to ‚Äúfor ùëÑ do ùëÉ1 else ùëÉ2‚Äù, where
ùëÑ corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog
symbol, andùëÉ2 corresponds to the second Prog symbol.
Case 4.1: |ùúé(ùëÑ)|‚â§ 1. The proof is similar to the proof for Case 2.
Case 4.2: |ùúé(ùëÑ)|‚â• 2.
Let (ùë•1, . . . , ùë•ùëü) = ùúé(ùëÑ).
By Figure 4-6,ùëü = |ùúé(ùëÑ)|‚â• 2, ùúÜ ‚àà{1, . . . , ùëü}, ùúé‚Ä≤= ùúé[ùëÑ.ùë¶ ‚Ü¶‚Üí
ùë•ùúÜ], ùëÉ‚Ä≤ = ùëÉ1, and ùëô‚Ä≤ = ùëôùúÜ. Also, there exists ùëô1, . . . , ùëôùëü such
that ùëô = (ùëÑ, ùëü) ‚ü≥(ùëô1, . . . , ùëôùëü).
Since ùúé ‚ä¢ùëÉ ‚áìloops ùëô, by Figure 4-3,ùúé‚Ä≤‚ä¢ùëÉ‚Ä≤ ‚áìloops ùëô‚Ä≤.
Proposition 4.6.4. For any programs ùëÉ, ùëÉ‚Ä≤ ‚àà Prog, context ùúé ‚àà Context, loop
layout treesùëô, ùëô‚Ä≤, and annotated traceùë°:
1. if ùúé ‚ä¢ùëÉ ‚áìloops ùëô, ùëÉ
ùë°
‚àí ‚ÜíùëÉ‚Ä≤, andùëô
ùë°
Àì‚àí ‚Üíùëô‚Ä≤, then there existsùúé‚Ä≤‚ààContext such that[Ô∏Å ùúé
ùëÉ
ùëô
]Ô∏Å
ùë°
‚àí ‚Üí ‚Üí
[Ô∏Å ùúé‚Ä≤
ùëÉ‚Ä≤
ùëô‚Ä≤
]Ô∏Å
.
2. for any contextùúé‚Ä≤ ‚ààContext, if ùúé ‚ä¢ùëÉ ‚áìloops ùëô and
[Ô∏Å ùúé
ùëÉ
ùëô
]Ô∏Å
ùë°
‚àí ‚Üí ‚Üí
[Ô∏Å ùúé‚Ä≤
ùëÉ‚Ä≤
ùëô‚Ä≤
]Ô∏Å
then ùúé‚Ä≤ ‚ä¢
ùëÉ‚Ä≤ ‚áìloops ùëô‚Ä≤.
Proof. 1. This proof is by induction on the length ofùë°.
Case 1: ùë° = Nil.
By Figure 4-4,ùëÉ‚Ä≤= ùëÉ. By Figure 4-5,ùëô‚Ä≤= ùëô. By Figure 4-6,
[Ô∏Å ùúé
ùëÉ
ùëô
]Ô∏Å
Nil
‚àí‚Üí ‚Üí[Ô∏Å ùúé
ùëÉ
ùëô
]Ô∏Å
.
Case 2: ùë° = ‚ü®ùëÑ‚Ä≤, ùëü, ùúÜ‚ü©@ ùë°‚Ä≤‚Ä≤.
136
By Proposition 4.5.2, there existsùëÉ‚Ä≤‚Ä≤ ‚ààProg such thatùëÉ
‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©
‚àí‚àí‚àí‚àí‚ÜíùëÉ‚Ä≤‚Ä≤.
By Proposition 4.5.5, there existsùëô‚Ä≤‚Ä≤such thatùëô
‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©
Àì‚àí‚àí‚àí‚àí‚Üíùëô‚Ä≤‚Ä≤. By Proposi-
tion 4.6.3, there existsùúé‚Ä≤‚Ä≤‚ààContext such that
[Ô∏Å ùúé
ùëÉ
ùëô
]Ô∏Å ‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©
‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Å ùúé‚Ä≤‚Ä≤
ùëÉ‚Ä≤‚Ä≤
ùëô‚Ä≤‚Ä≤
]Ô∏Å
. By
Proposition 4.6.3,ùúé‚Ä≤‚Ä≤‚ä¢ùëÉ‚Ä≤‚Ä≤ ‚áìloops ùëô‚Ä≤‚Ä≤.
Since ùëÉ
ùë°
‚àí ‚ÜíùëÉ‚Ä≤, we haveùëÉ
‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©@ ùë°‚Ä≤‚Ä≤
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíùëÉ‚Ä≤. By Proposition 4.5.1,ùëÉ‚Ä≤‚Ä≤ ùë°‚Ä≤‚Ä≤
‚àí ‚Üí
ùëÉ‚Ä≤.
Since ùëô
ùë°
Àì‚àí ‚Üíùëô‚Ä≤, we haveùëô
‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©@ ùë°‚Ä≤‚Ä≤
Àì‚àí ‚àí‚àí‚àí‚àí‚àí‚àí ‚Üíùëô‚Ä≤. By Proposition 4.5.4,ùëô‚Ä≤‚Ä≤ ùë°‚Ä≤‚Ä≤
Àì‚àí ‚Üíùëô‚Ä≤.
By the induction hypothesis, there exists ùúé‚Ä≤‚Ä≤‚Ä≤ ‚àà Context such that[Ô∏Å ùúé‚Ä≤‚Ä≤
ùëÉ‚Ä≤‚Ä≤
ùëô‚Ä≤‚Ä≤
]Ô∏Å
ùë°‚Ä≤‚Ä≤
‚àí ‚Üí ‚Üí
[Ô∏Åùúé‚Ä≤‚Ä≤‚Ä≤
ùëÉ‚Ä≤
ùëô‚Ä≤
]Ô∏Å
. Since
[Ô∏Å ùúé
ùëÉ
ùëô
]Ô∏Å ‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©
‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Å ùúé‚Ä≤‚Ä≤
ùëÉ‚Ä≤‚Ä≤
ùëô‚Ä≤‚Ä≤
]Ô∏Å
, by Proposition 4.6.1,
[Ô∏Å ùúé
ùëÉ
ùëô
]Ô∏Å ‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©@ ùë°‚Ä≤‚Ä≤
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Åùúé‚Ä≤‚Ä≤‚Ä≤
ùëÉ‚Ä≤
ùëô‚Ä≤
]Ô∏Å
.
Hence
[Ô∏Å ùúé
ùëÉ
ùëô
]Ô∏Å
ùë°
‚àí ‚Üí ‚Üí
[Ô∏Åùúé‚Ä≤‚Ä≤‚Ä≤
ùëÉ‚Ä≤
ùëô‚Ä≤
]Ô∏Å
.
2. This proof is by induction on the length ofùë°.
Case 1: ùë° = Nil.
By Figure 4-6, ùúé‚Ä≤ = ùúé, ùëÉ‚Ä≤ = ùëÉ, and ùëô‚Ä≤ = ùëô. Since ùúé ‚ä¢ùëÉ ‚áìloops ùëô,
ùúé‚Ä≤‚ä¢ùëÉ‚Ä≤ ‚áìloops ùëô‚Ä≤.
Case 2: ùë° = ‚ü®ùëÑ‚Ä≤, ùëü, ùúÜ‚ü©@ ùë°‚Ä≤‚Ä≤.
By Proposition 4.6.2,ùëÉ
ùë°
‚àí ‚ÜíùëÉ‚Ä≤ and ùëô
ùë°
Àì‚àí ‚Üíùëô‚Ä≤. By Proposition 4.5.2, there
exists ùëÉ‚Ä≤‚Ä≤ ‚ààProg such thatùëÉ
‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©
‚àí‚àí‚àí‚àí‚ÜíùëÉ‚Ä≤‚Ä≤. By Proposition 4.5.5, there
exists ùëô‚Ä≤‚Ä≤ such thatùëô
‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©
Àì‚àí‚àí‚àí‚àí‚Üíùëô‚Ä≤‚Ä≤.
Since ùúé ‚ä¢ùëÉ ‚áìloops ùëô, by Proposition 4.6.3, there existsùúé‚Ä≤‚Ä≤ such that[Ô∏Å ùúé
ùëÉ
ùëô
]Ô∏Å ‚ü®ùëÑ‚Ä≤,ùëü,ùúÜ‚ü©
‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Å ùúé‚Ä≤‚Ä≤
ùëÉ‚Ä≤‚Ä≤
ùëô‚Ä≤‚Ä≤
]Ô∏Å
. By Proposition 4.6.3,ùúé‚Ä≤‚Ä≤‚ä¢ùëÉ‚Ä≤‚Ä≤ ‚áìloops ùëô‚Ä≤‚Ä≤.
Since
[Ô∏Å ùúé
ùëÉ
ùëô
]Ô∏Å
ùë°
‚àí ‚Üí ‚Üí
[Ô∏Å ùúé‚Ä≤
ùëÉ‚Ä≤
ùëô‚Ä≤
]Ô∏Å
, by Proposition 4.6.1,
[Ô∏Å ùúé‚Ä≤‚Ä≤
ùëÉ‚Ä≤‚Ä≤
ùëô‚Ä≤‚Ä≤
]Ô∏Å
ùë°‚Ä≤‚Ä≤
‚àí ‚Üí ‚Üí
[Ô∏Å ùúé‚Ä≤
ùëÉ‚Ä≤
ùëô‚Ä≤
]Ô∏Å
.
By the induction hypothesis,ùúé‚Ä≤‚ä¢ùëÉ‚Ä≤ ‚áìloops ùëô‚Ä≤.
137
[Ô∏Å ùúé
ùëÉ
ùëô
]Ô∏Å Nil
‚àí‚àí‚Üí ‚Üí
[Ô∏Å ùúé
ùëÉ
ùëô
]Ô∏Å (nil)
|ùúé(ùëÑ)|= ùëü
[Ô∏Åùúé[ùëÑ.ùë¶‚Ü¶‚Üíùúé(ùëÑ)]
ùëÉ
ùëô
]Ô∏Å ùë°
‚àí ‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤
ùëÉ‚Ä≤
ùëô‚Ä≤
]Ô∏Ç
ùëÑ .= ùëÑ‚Ä≤
[Ô∏Å ùúé
ùëÑ ùëÉ
(ùëÑ,ùëü)%ùëô
]Ô∏Å ‚ü®ùëÑ‚Ä≤,ùëü,NotLoop‚ü©@ ùë°
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤
ùëÉ‚Ä≤
ùëô‚Ä≤
]Ô∏Ç (seq)
|ùúé(ùëÑ)|= ùëü >0
[Ô∏Ç
ùúé[ùëÑ.ùë¶‚Ü¶‚Üíùúé(ùëÑ)]
ùëÉ1
ùëô
]Ô∏Ç
ùë°
‚àí ‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤
ùëÉ‚Ä≤
1
ùëô‚Ä≤
]Ô∏Ç
ùëÑ .= ùëÑ‚Ä≤
[Ô∏Å ùúé
if ùëÑ then ùëÉ1 else ùëÉ2
(ùëÑ,ùëü)%ùëô
]Ô∏Å ‚ü®ùëÑ‚Ä≤,ùëü,NotLoop‚ü©@ ùë°
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤
ùëÉ‚Ä≤
1
ùëô‚Ä≤
]Ô∏Ç (if-1)
|ùúé(ùëÑ)|= 0
[Ô∏Å ùúé
ùëÉ2
ùë°
]Ô∏Å ùëô
‚àí ‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤
ùëÉ‚Ä≤
2
ùëô‚Ä≤
]Ô∏Ç
ùëÑ .= ùëÑ‚Ä≤
[Ô∏Å ùúé
if ùëÑ then ùëÉ1 else ùëÉ2
(ùëÑ,0)%ùëô
]Ô∏Å ‚ü®ùëÑ‚Ä≤,0,NotLoop‚ü©@ ùë°
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤
ùëÉ‚Ä≤
2
ùëô‚Ä≤
]Ô∏Ç (if-2)
ùúé(ùëÑ) = (ùë•1, . . . , ùë•ùëü) ùëü ‚â•2
[Ô∏Ç
ùúé[ùëÑ.ùë¶‚Ü¶‚Üíùë•ùëñ]
ùëÉ1
ùëôùëñ
]Ô∏Ç
ùë°
‚àí ‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤
ùëÉ‚Ä≤
1
ùëô‚Ä≤
]Ô∏Ç
ùëÑ .= ùëÑ‚Ä≤
[Ô∏Å ùúé
for ùëÑ do ùëÉ1 else ùëÉ2
(ùëÑ,ùëü)‚ü≥(ùëô1,...,ùëôùëü)
]Ô∏Å ‚ü®ùëÑ‚Ä≤,ùëü,ùëñ‚ü©@ ùë°
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤
ùëÉ‚Ä≤
1
ùëô‚Ä≤
]Ô∏Ç (for-1a)
|ùúé(ùëÑ)|= 1
[Ô∏Ç
ùúé[ùëÑ.ùë¶‚Ü¶‚Üíùúé(ùëÑ)]
ùëÉ1
ùëô
]Ô∏Ç
ùë°
‚àí ‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤
ùëÉ‚Ä≤
1
ùëô‚Ä≤
]Ô∏Ç
ùëÑ .= ùëÑ‚Ä≤
[Ô∏Å ùúé
for ùëÑ do ùëÉ1 else ùëÉ2
(ùëÑ,1)%ùëô
]Ô∏Å ‚ü®ùëÑ‚Ä≤,1,NotLoop‚ü©@ ùë°
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤
ùëÉ‚Ä≤
1
ùëô‚Ä≤
]Ô∏Ç (for-1b)
|ùúé(ùëÑ)|= 0
[Ô∏Å ùúé
ùëÉ2
ùëô
]Ô∏Å ùë°
‚àí ‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤
ùëÉ‚Ä≤
2
ùëô‚Ä≤
]Ô∏Ç
ùëÑ .= ùëÑ‚Ä≤
[Ô∏Å ùúé
for ùëÑ for ùëÉ1 else ùëÉ2
(ùëÑ,0)%ùëô
]Ô∏Å ‚ü®ùëÑ‚Ä≤,0,NotLoop‚ü©@ ùë°
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤
ùëÉ‚Ä≤
2
ùëô‚Ä≤
]Ô∏Ç (for-2)
ùëÉ, ùëÉ1, ùëÉ2, ùëÉ‚Ä≤, ùëÉ‚Ä≤
1, ùëÉ‚Ä≤
2 ‚ààProg, ùëÑ, ùëÑ‚Ä≤‚ààQuery, ùëü, ùëñ ‚ààZ‚â•0
Figure 4-6: Traverse a program and a corresponding loop layout tree by following an
annotated trace, updating the context
138
4.6.2 Soundness of InferProg
To facilitate discussion we define an alternative implementation ofInferProg in
Algorithm 10. This version is equivalent to Algorithm 6 and uses annotated traces
more explicitly. We first present a detailed case-by-case discussion on the properties
of the variables in Algorithm 10 by line 16. We then conclude with the proof of
Theorem 3.
Proposition 4.6.5.Consider any programsùëÉ ‚ààProg and ùëÉ‚Ä≤ ‚ààK and annotated
traces ùë°, ùë°‚Ä≤ such thatùë° Ã∏= Nil, ùë°‚Ä≤Ã∏= Nil, ùëÉ‚Ä≤ ùë°‚Ä≤
‚àí ‚ÜíùëÉ, andùëÉ
ùë°
‚àí ‚Üíùúñ. During the execution of
InferProg( ùëÉ‚Ä≤, ùë°‚Ä≤, ùë°), for eachùëñ = 0, 1, 2, the variableùëäùëñ on line 9 of Algorithm 10
is derived fromùëÉ‚Ä≤.
Proof. By Proposition 4.5.1,ùëÉ‚Ä≤ ùë°‚Ä≤ @ ùë°
‚àí‚àí‚Üíùúñ. By Definition 3.4.26, Definition 4.1.4, and
the definition ofMakePathConstraint, ùëäùëñ is derived fromùëÉ‚Ä≤.
Lemma 4.6.6. Consider any programsùëÉ ‚ààProg andùëÉ‚Ä≤ ‚ààK and annotated traces
ùë°, ùë°‚Ä≤ such that ùë° Ã∏= Nil, ùë°‚Ä≤ Ã∏= Nil, ùëÉ‚Ä≤ ùë°‚Ä≤
‚àí ‚ÜíùëÉ, and ùëÉ
ùë°
‚àí ‚Üíùúñ. During the execution of
InferProg( ùëÉ‚Ä≤, ùë°‚Ä≤, ùë°), let ùúé‚Ä≤
ùëñ be the context variable in SolveAndGetTrace on
line 10 of Algorithm 10 for each integerùëñ ‚àà{0, 1, 2}. If variable ùëìùëñ = true on line
16, then there existsùúéùëñ, ùúé‚Ä≤‚Ä≤
ùëñ , ùëÉ‚Ä≤‚Ä≤, ùëôùëñ, ùëô‚Ä≤
ùëñ, ùëô‚Ä≤‚Ä≤
ùëñ such that
[Ô∏Ç
ùúé‚Ä≤
ùëñ
ùëÉ‚Ä≤
ùëô‚Ä≤
ùëñ
]Ô∏Ç
‚ü®ùëÑ1,ùëüùëñ,1,ùúÜùëñ,1‚ü©,...,‚ü®ùëÑùëò,ùëüùëñ,ùëò,ùúÜùëñ,ùëò‚ü©‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Åùúéùëñ
ùëÉ
ùëôùëñ
]Ô∏Å
and
[Ô∏Åùúéùëñ
ùëÉ
ùëôùëñ
]Ô∏Å ‚ü®ùëÑùëò+1,ùëüùëñ,ùëò+1,ùúÜùëñ,ùëò+1‚ü©‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤‚Ä≤
ùëñ
ùëÉ‚Ä≤‚Ä≤
ùëô‚Ä≤‚Ä≤
ùëñ
]Ô∏Ç
.
Proof. In Algorithm 10, variablesùë†1 = ùë°‚Ä≤ and ùë†2 = ùë°. By Proposition 4.6.5, ùëäùëñ is
derived fromùëÉ‚Ä≤.
Since ùëìùëñ = true, by Algorithm 5, variable ùë°ùëñ = GetTrace( ùëÉ‚Ä≤, ùëäùëñ, ùúé‚Ä≤
ùëñ). By
Theorem 2, there exists a loop layout treeùëô‚Ä≤
ùëñ such that:
ùúé‚Ä≤
ùëñ ‚ä¢ùëÉ‚Ä≤ ‚áìloops ùëô‚Ä≤
ùëñ (4.1)
ùë°ùëñ ‚àºùëäùëñ (4.2)
ùëÉ‚Ä≤ ùë°ùëñ
‚àí ‚Üíùúñ (4.3)
ùëô‚Ä≤
ùëñ
ùë°ùëñ
Àì‚àí ‚ÜíNil (4.4)
139
Since ùëìùëñ = true, variablesùë°ùëñ,1 and ùë°ùëñ,2 are defined on line 16 and satisfy:
ùë°ùëñ = ùë°ùëñ,1 @ ùë°ùëñ,2 (4.5)
Since ùë°‚Ä≤Ã∏= Nil, variableùëò ‚â•1 on line 6. Letùë°‚Ä≤
ùëñ,1 = ‚ü®ùëÑ1, ùëüùëñ,1, ùúÜùëñ,1‚ü©, . . . ,‚ü®ùëÑùëò, ùëüùëñ,ùëò, ùúÜùëñ,ùëò‚ü©,
then:
ùë°ùëñ,1 = ùë°‚Ä≤
ùëñ,1 @ ‚ü®ùëÑùëò+1, ùëüùëñ,ùëò+1, ùúÜùëñ,ùëò+1‚ü© (4.6)
By (4.4), (4.5), (4.6), and Proposition 4.5.5, there existsùëôùëñ, ùëô‚Ä≤‚Ä≤
ùëñ such that:
ùëô‚Ä≤
ùëñ
ùë°‚Ä≤
ùëñ,1
Àì‚àí‚Üíùëôùëñ (4.7)
ùëôùëñ
‚ü®ùëÑùëò+1,ùëüùëñ,ùëò+1,ùúÜùëñ,ùëò+1‚ü©
Àì‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üíùëô‚Ä≤‚Ä≤
ùëñ (4.8)
For allùëó = 1, . . . , ùëò, by (4.2), variableùëüùëñ,ùëó = 0 if and only if variableùëüùëó = 0. Hence,
traversing a program by followingùë°‚Ä≤or ùë°‚Ä≤
ùëñ,1 will use the same rules in Figure 4-4. Since
ùëÉ‚Ä≤ ùë°‚Ä≤
‚àí ‚ÜíùëÉ,
ùëÉ‚Ä≤ ùë°‚Ä≤
ùëñ,1
‚àí ‚àí ‚ÜíùëÉ (4.9)
By (4.1), (4.9), (4.7), and Proposition 4.6.4, there existsùúéùëñ such that:
[Ô∏Ç
ùúé‚Ä≤
ùëñ
ùëÉ‚Ä≤
ùëô‚Ä≤
ùëñ
]Ô∏Ç
ùë°‚Ä≤
ùëñ,1
‚àí ‚àí ‚Üí ‚Üí
[Ô∏Åùúéùëñ
ùëÉ
ùëôùëñ
]Ô∏Å
(4.10)
By (4.3), (4.5), (4.6), (4.9), and Proposition 4.5.1,
ùëÉ ‚ü®ùëÑùëò+1,ùëüùëñ,ùëò+1,ùúÜùëñ,ùëò+1‚ü©@ ùë°ùëñ,2
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üíùúñ (4.11)
By (4.11) and Proposition 4.5.2, there existsùëÉ‚Ä≤‚Ä≤ such that:
ùëÉ ‚ü®ùëÑùëò+1,ùëüùëñ,ùëò+1,ùúÜùëñ,ùëò+1‚ü©‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíùëÉ‚Ä≤‚Ä≤ (4.12)
140
By (4.1), (4.10), and Proposition 4.6.4,
ùúéùëñ ‚ä¢ùëÉ ‚áìloops ùëôùëñ (4.13)
By (4.13), (4.12), (4.8), and Proposition 4.6.4, there existsùúé‚Ä≤‚Ä≤
ùëñ such that
[Ô∏Åùúéùëñ
ùëÉ
ùëôùëñ
]Ô∏Å ‚ü®ùëÑùëò+1,ùëüùëñ,ùëò+1,ùúÜùëñ,ùëò+1‚ü©‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤‚Ä≤
ùëñ
ùëÉ‚Ä≤‚Ä≤
ùëô‚Ä≤‚Ä≤
ùëñ
]Ô∏Ç
.
Lemma 4.6.7. Consider any programsùëÉ ‚ààProg andùëÉ‚Ä≤ ‚ààK and annotated traces
ùë°, ùë°‚Ä≤ such thatùë° Ã∏= Nil, ùëÉ‚Ä≤ ùë°‚Ä≤
‚àí ‚ÜíùëÉ, andùëÉ
ùë°
‚àí ‚Üíùúñ. During the execution of
InferProg( ùëÉ‚Ä≤, ùë°‚Ä≤, ùë°),
if variable ùëì2 = true on line 16, then variableùúÜ2,ùëò+1 Ã∏= NotLoop if and only ifùëÉ is
of the form ‚ÄúFor‚Äù.
Proof. In Algorithm 10, variablesùë†1 = ùë°‚Ä≤ and ùë†2 = ùë°. By Proposition 4.6.5, ùëä2 is
derived fromùëÉ‚Ä≤.
Letùúé‚Ä≤
2 be the context variable inSolveAndGetTraceon line 10 forùëñ = 2. Since
ùëì2 = true, by Algorithm 5, variableùë°2 = GetTrace( ùëÉ‚Ä≤, ùëä2, ùúé‚Ä≤
2). By Theorem 2,
there exists a loop layout treeùëô‚Ä≤
2 such thatùúé‚Ä≤
2 ‚ä¢ùëÉ‚Ä≤ ‚áìloops ùëô‚Ä≤
2, ùë°2 ‚àºùëä2, andùëô‚Ä≤
2
ùë°2
Àì‚àí ‚ÜíNil.
Case 1: ùë°‚Ä≤= Nil.
Since ùëÉ‚Ä≤ ùë°‚Ä≤
‚àí ‚ÜíùëÉ, by Figure 4-4,ùëÉ‚Ä≤= ùëÉ.
Let ùúé2 = ùúé‚Ä≤
2, ùëô2 = ùëô‚Ä≤
2, thenùúé2 ‚ä¢ùëÉ ‚áìloops ùëô2.
Since ùë°‚Ä≤= Nil, variableùëò = 0 on line 6. Variableùë°2,1 = ‚ü®ùëÑ1, ùëü2,1, ùúÜ2,1‚ü©on line
16. Variableùë°2 = ùë°2,1 @ ùë°2,2 = ‚ü®ùëÑ1, ùëü2,1, ùúÜ2,1‚ü©@ ùë°2,2.
Since ùëô‚Ä≤
2
ùë°2
Àì‚àí ‚ÜíNil, by Proposition 4.5.5, there existsùëô‚Ä≤‚Ä≤
2 such thatùëô‚Ä≤
2
‚ü®ùëÑ1,ùëü2,1,ùúÜ2,1‚ü©
Àì‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí
ùëô‚Ä≤‚Ä≤
2. Hence, ùëô2
‚ü®ùëÑ1,ùëü2,1,ùúÜ2,1‚ü©
Àì‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üíùëô‚Ä≤‚Ä≤
2.
141
By the definition ofMakePathConstraint, the first query inùëä2 is the
first query in ùë°. By Definition 3.4.26, the first queries in ùë°2 and ùëä2 are
identical except for equivalent variables. In other words,ùëÑ1 and the first
query in ùë° are identical except for equivalent variables. SinceùëÉ
ùë°
‚àí ‚Üíùúñ and
ùë° Ã∏= Nil, by Figure 4-4, there existsùëÉ‚Ä≤‚Ä≤ such thatùëÉ
‚ü®ùëÑ1,ùëü2,1,ùúÜ2,1‚ü©
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíùëÉ‚Ä≤‚Ä≤.
By Proposition 4.6.3, there existsùúé‚Ä≤‚Ä≤ such that
[Ô∏Åùúé2
ùëÉ
ùëô2
]Ô∏Å ‚ü®ùëÑ1,ùëü2,1,ùúÜ2,1‚ü©
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤‚Ä≤
2
ùëÉ‚Ä≤‚Ä≤
ùëô‚Ä≤‚Ä≤
2
]Ô∏Ç
.
Case 2: ùë°‚Ä≤Ã∏= Nil.
By Lemma 4.6.6, there existsùúé2, ùúé‚Ä≤‚Ä≤
2 , ùëÉ‚Ä≤‚Ä≤, ùëô2, ùëô‚Ä≤‚Ä≤
2 such that
[Ô∏Ç
ùúé‚Ä≤
2
ùëÉ‚Ä≤
ùëô‚Ä≤
2
]Ô∏Ç
‚ü®ùëÑ1,ùëü2,1,ùúÜ2,1‚ü©,...,‚ü®ùëÑùëò,ùëü2,ùëò,ùúÜ2,ùëò‚ü©‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Åùúé2
ùëÉ
ùëô2
]Ô∏Å
and [Ô∏Åùúé2
ùëÉ
ùëô2
]Ô∏Å ‚ü®ùëÑùëò+1,ùëü2,ùëò+1,ùúÜ2,ùëò+1‚ü©‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤‚Ä≤
2
ùëÉ‚Ä≤‚Ä≤
ùëô‚Ä≤‚Ä≤
2
]Ô∏Ç
.
Either case, we have
[Ô∏Åùúé2
ùëÉ
ùëô2
]Ô∏Å ‚ü®ùëÑùëò+1,ùëü2,ùëò+1,ùúÜ2,ùëò+1‚ü©‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤‚Ä≤
2
ùëÉ‚Ä≤‚Ä≤
ùëô‚Ä≤‚Ä≤
2
]Ô∏Ç
.
The rest of the proof is by induction on the derivation ofùëÉ.
Case 1: ùëÉ = ùúñ.
Since ùëÉ
ùë°
‚àí ‚Üíùúñ, by Figure 4-4, it is not possible to haveùë° Ã∏= Nil. Hence the
proposition trivially holds.
Case 2: ùëÉ is of the form ‚ÄúSeq‚Äù.ùëÉ expands to ‚ÄúùëÑ ùëÉ1‚Äù, where ùëÑ corresponds to the
Query symbol andùëÉ1 corresponds to the Prog symbol.
Since
[Ô∏Åùúé2
ùëÉ
ùëô2
]Ô∏Å ‚ü®ùëÑùëò+1,ùëü2,ùëò+1,ùúÜ2,ùëò+1‚ü©‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤‚Ä≤
2
ùëÉ‚Ä≤‚Ä≤
ùëô‚Ä≤‚Ä≤
2
]Ô∏Ç
, by Figure 4-6,ùúÜ2,ùëò+1 = NotLoop.
Case 3: ùëÉ is of the form ‚ÄúIf‚Äù. ùëÉ expands to ‚Äúif ùëÑ then ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol. The proof is similar to the
proof of Case 2.
142
Case 4: ùëÉ is of the form ‚ÄúFor‚Äù. ùëÉ expands to ‚Äúfor ùëÑ do ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol.
Since ùë°2 ‚àºùëä2, by Definition 3.4.26 and the definition ofMakePathCon-
straint, ùëü2,ùëò+1 ‚â•2. Since
[Ô∏Åùúé2
ùëÉ
ùëô2
]Ô∏Å ‚ü®ùëÑùëò+1,ùëü2,ùëò+1,ùúÜ2,ùëò+1‚ü©‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí ‚Üí
[Ô∏Ç
ùúé‚Ä≤‚Ä≤
2
ùëÉ‚Ä≤‚Ä≤
ùëô‚Ä≤‚Ä≤
2
]Ô∏Ç
, by Figure 4-6,
ùúÜ2,ùëò+1 Ã∏= NotLoop.
Lemma 4.6.8.Consider any programsùëÉ ‚ààProg andùëÉ‚Ä≤‚ààK, whereùëÉ is of the form
‚ÄúSeq‚Äù, and any annotated tracesùë°, ùë°‚Ä≤ such that ùëÉ‚Ä≤ ùë°‚Ä≤
‚àí ‚ÜíùëÉ and ùëÉ
ùë°
‚àí ‚Üíùúñ. Let ùëÉ expand
to ‚ÄúùëÑ ùëÉ1‚Äù where ùëÑ corresponds to the Query symbol andùëÉ1 corresponds to the Prog
symbol. During the execution ofInferProg( ùëÉ‚Ä≤, ùë°‚Ä≤, ùë°), for any integerùëñ ‚àà{0, 1, 2},
if variableùëìùëñ = true on line 16 thenùëÉ‚Ä≤ ùë°ùëñ,1
‚àí ‚àí ‚ÜíùëÉ1 and ùëÉ1
ùë°ùëñ,2
‚àí ‚àí ‚Üíùúñ.
Proof. In Algorithm 10, variablesùë†1 = ùë°‚Ä≤ and ùë†2 = ùë°. By Proposition 4.6.5, ùëäùëñ is
derived fromùëÉ‚Ä≤.
Since ùëìùëñ = true, by Algorithm 5, variableùë°ùëñ = GetTrace( ùëÉ‚Ä≤, ùëäùëñ, ùúé‚Ä≤
ùëñ) for some
ùúé‚Ä≤
ùëñ. By Theorem 2,
ùë°ùëñ ‚àºùëäùëñ (4.14)
ùëÉ‚Ä≤ ùë°ùëñ
‚àí ‚Üíùúñ (4.15)
Since ùëÉ
ùë°
‚àí ‚Üíùúñ, by Figure 4-4,ùëÑ .= ùëÑùëò+1. Hence, by Figure 4-4,
ùëÉ ‚ü®ùëÑùëò+1,ùëüùëñ,ùëò+1,ùúÜùëñ,ùëò+1‚ü©‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíùëÉ1 (4.16)
Case 1: ùë°‚Ä≤= Nil.
Variable ùëò = 0 on line 6. Variableùë°ùëñ,1 = ‚ü®ùëÑ1, ùëüùëñ,1, ùúÜùëñ,1‚ü©on line 16. By (4.16),
ùëÉ
ùë°ùëñ,1
‚àí ‚àí ‚ÜíùëÉ1.
Since ùëÉ‚Ä≤ ùë°‚Ä≤
‚àí ‚ÜíùëÉ, by Figure 4-4,ùëÉ‚Ä≤= ùëÉ. By (4.15),ùëÉ
ùë°ùëñ
‚àí ‚Üíùúñ.
Since ùë°ùëñ = ùë°ùëñ,1 @ ùë°ùëñ,2, by Proposition 4.5.1,ùëÉ1
ùë°ùëñ,2
‚àí ‚àí ‚Üíùúñ.
143
Case 2: ùë°‚Ä≤Ã∏= Nil.
Variable ùëò ‚â•1 on line 6. Sinceùëìùëñ = true, variablesùë°ùëñ,1 and ùë°ùëñ,2 are defined
on line 16 and satisfy:
ùë°ùëñ = ùë°ùëñ,1 @ ùë°ùëñ,2 (4.17)
Let ùë°‚Ä≤
ùëñ,1 = ‚ü®ùëÑ1, ùëüùëñ,1, ùúÜùëñ,1‚ü©, . . . ,‚ü®ùëÑùëò, ùëüùëñ,ùëò, ùúÜùëñ,ùëò‚ü©, then:
ùë°ùëñ,1 = ùë°‚Ä≤
ùëñ,1 @ ‚ü®ùëÑùëò+1, ùëüùëñ,ùëò+1, ùúÜùëñ,ùëò+1‚ü© (4.18)
By (4.14), Definition 3.4.26, and the definition ofMakePathConstraint,
ùëüùëñ,ùëó = 0 if and only ifùëüùëó = 0 for anyùëó = 1, . . . , ùëò. Hence, traversing a program
by followingùë°‚Ä≤or by followingùë°‚Ä≤
ùëñ,1 will use the same rules in Figure 4-4. Since
ùëÉ‚Ä≤ ùë°‚Ä≤
‚àí ‚ÜíùëÉ,
ùëÉ‚Ä≤ ùë°‚Ä≤
ùëñ,1
‚àí ‚àí ‚ÜíùëÉ (4.19)
By (4.19), (4.16), (4.18), and Proposition 4.5.1,
ùëÉ‚Ä≤ ùë°ùëñ,1
‚àí ‚àí ‚ÜíùëÉ1 (4.20)
By (4.15), (4.20), (4.17), and Proposition 4.5.1,
ùëÉ1
ùë°ùëñ,2
‚àí ‚àí ‚Üíùúñ (4.21)
Lemma 4.6.9. Consider any programsùëÉ ‚ààProg and ùëÉ‚Ä≤ ‚ààK, where ùëÉ is of the
form ‚ÄúSeq‚Äù, and any annotated tracesùë°, ùë°‚Ä≤ such that ùëÉ‚Ä≤ ùë°‚Ä≤
‚àí ‚ÜíùëÉ and ùëÉ
ùë°
‚àí ‚Üíùúñ. During
the execution ofInferProg( ùëÉ‚Ä≤, ùë°‚Ä≤, ùë°), if variablesùëì0 = ùëì1 = true on line 16, then
either ùë°0,2 = ùë°1,2 = Nil, orùë°0,2 Ã∏= Nil andùë°1,2 Ã∏= Nil andùúãSùëÑ0,ùëò+2 = ùúãSùëÑ1,ùëò+2.
Proof. Let ùëÉ expand to ‚ÄúùëÑ ùëÉ1‚Äù, where ùëÑ corresponds to the Query symbol andùëÉ1
corresponds to the Prog symbol. By Lemma 4.6.8,ùëÉ1
ùë°ùëñ,2
‚àí ‚àí ‚Üíùúñ for eachùëñ = 0, 1. The
rest of the proof is by induction on the derivation ofùëÉ1.
144
Case 1: ùëÉ1 = ùúñ.
By Figure 4-4,ùë°ùëñ,2 = Nil for eachùëñ = 0, 1.
Case 2: ùëÉ1 is of the form ‚ÄúSeq‚Äù.ùëÉ1 expands to ‚ÄúùëÑ‚Ä≤ ùëÉ2‚Äù, whereùëÑ‚Ä≤ corresponds to the
Query symbol andùëÉ2 corresponds to the Prog symbol.
By Figure 4-4, for eachùëñ = 0, 1 we haveùë°ùëñ,2 Ã∏= Nil and ùëÑùëñ,ùëò+2
.= ùëÑ‚Ä≤. Hence
ùúãSùëÑ0,ùëò+2 = ùúãSùëÑ1,ùëò+2 = ùúãSùëÑ‚Ä≤.
Case 3: ùëÉ1 is of the form ‚ÄúIf‚Äù. The proof is similar to the proof of Case 2.
Case 4: ùëÉ1 is of the form ‚ÄúFor‚Äù. The proof is similar to the proof of Case 2.
Lemma 4.6.10. Consider any programsùëÉ ‚ààProg andùëÉ‚Ä≤ ‚ààK, where ùëÉ is of the
form ‚ÄúIf‚Äù, and any annotated tracesùë°, ùë°‚Ä≤ such thatùëÉ‚Ä≤ ùë°‚Ä≤
‚àí ‚ÜíùëÉ and ùëÉ
ùë°
‚àí ‚Üíùúñ. LetùëÉ expand
to ‚Äúif ùëÑ then ùëÉ1 else ùëÉ2‚Äù, whereùëÑ corresponds to the Query symbol,ùëÉ1 corresponds
to the first Prog symbol, andùëÉ2 corresponds to the second Prog symbol. During the
execution ofInferProg( ùëÉ‚Ä≤, ùë°‚Ä≤, ùë°):
1. if variableùëì0 = true on line 16 thenùëÉ‚Ä≤ ùë°0,1
‚àí‚àí‚ÜíùëÉ2 and ùëÉ2
ùë°0,2
‚àí‚àí‚Üíùúñ.
2. if variableùëì1 = true on line 16 thenùëÉ‚Ä≤ ùë°1,1
‚àí‚àí‚ÜíùëÉ1 and ùëÉ1
ùë°1,2
‚àí‚àí‚Üíùúñ.
Proof. 1. By Proposition 4.6.5,ùëä0 is derived fromùëÉ‚Ä≤. Since ùëì0 = true, by Al-
gorithm 5, variableùë°0 = GetTrace( ùëÉ‚Ä≤, ùëä0, ùúé‚Ä≤
0) for someùúé‚Ä≤
0. By Theorem 2,
ùë°0 ‚àºùëä0. By the definition ofMakePathConstraint, ùëü0,ùëò+1 = 0 on line 16.
The rest of the proof is similar to the proof of Lemma 4.6.8.
2. The proof is similar to the proof of 1.
Lemma 4.6.11. Consider any programsùëÉ ‚ààProg andùëÉ‚Ä≤ ‚ààK, where ùëÉ is of the
form ‚ÄúFor‚Äù, and any annotated tracesùë°, ùë°‚Ä≤such thatùëÉ‚Ä≤ ùë°‚Ä≤
‚àí ‚ÜíùëÉ and ùëÉ
ùë°
‚àí ‚Üíùúñ. LetùëÉ expand
to ‚Äúfor ùëÑ do ùëÉ1 else ùëÉ2‚Äù, whereùëÑ corresponds to the Query symbol,ùëÉ1 corresponds
145
to the first Prog symbol, andùëÉ2 corresponds to the second Prog symbol. During the
execution ofInferProg( ùëÉ‚Ä≤, ùë°‚Ä≤, ùë°):
1. if variableùëì0 = true on line 16 thenùëÉ‚Ä≤ ùë°0,1
‚àí‚àí‚ÜíùëÉ2 and ùëÉ2
ùë°0,2
‚àí‚àí‚Üíùúñ.
2. if variableùëì2 = true on line 16 thenùëÉ‚Ä≤ ùë°2,1
‚àí‚àí‚ÜíùëÉ1 and ùëÉ1
ùë°2,2
‚àí‚àí‚Üíùúñ.
Proof. The proof is similar to the proof of Lemma 4.6.10.
Theorem 3(Core Recursion). For any programsùëÉ ‚ààProg andùëÉ‚Ä≤ ‚ààK and anno-
tated tracesùë°, ùë°‚Ä≤, ifùëÉ‚Ä≤ ùë°‚Ä≤
‚àí ‚ÜíùëÉ and ùëÉ
ùë°
‚àí ‚Üíùúñ then ùëÉ .= InferProg( ùëÉ‚Ä≤, ùë°‚Ä≤, ùë°).
Proof. This proof is by induction on the derivation ofùëÉ.
Case 1: ùëÉ = ùúñ.
By Figure 4-4,ùë° = Nil. By Algorithm 10,InferProg( ùëÉ‚Ä≤, ùë°‚Ä≤, Nil) = ùúñ.
Case 2: ùëÉ is of the form ‚ÄúSeq‚Äù.ùëÉ expands to ‚ÄúùëÑ ùëÉ1‚Äù, where ùëÑ corresponds to the
Query symbol andùëÉ1 corresponds to the Prog symbol.
By Lemma 4.6.7, ifùëì2 = true then ùúÜ2,ùëò+1 = NotLoop, so execution does not
enter the branch on line 17. By Lemma 4.6.9, execution does not enter the
branch on line 23. Hence, execution enters the branch on line 27.
Since ùëÉ‚Ä≤ ùë°‚Ä≤
‚àí ‚ÜíùëÉ, by Figure 4-4,ùëÉ is a subprogram ofùëÉ‚Ä≤. HenceùëÑ is a query in
ùëÉ‚Ä≤. SinceùëÉ‚Ä≤‚ààK, by Definition 3.3.4 and Proposition 4.2.6,Trim(ùëÉ‚Ä≤) = ùëÉ‚Ä≤.
HenceùëÑ is a query inTrim(ùëÉ‚Ä≤). By Proposition 4.2.17, there exists a context
ùúé ‚ààContext such thatùëÑ is used while evaluatingùúé(ùëÉ‚Ä≤). So at least one of
the path constraintsùëä0, ùëä1 is satisfiable. By Proposition 4.1.6, at least one
of the variablesùëì0, ùëì1 is true.
If ùëìùëñ = true (ùëñ = 0, 1), by Lemma 4.6.8,ùëÉ‚Ä≤ ùë°ùëñ,1
‚àí ‚àí ‚ÜíùëÉ1 and ùëÉ1
ùë°ùëñ,2
‚àí ‚àí ‚Üíùúñ. By the
induction hypothesis, ùëÉ1
.= InferProg( ùëÉ‚Ä≤, ùë°ùëñ,1, ùë°ùëñ,2). Either case, ùëÉ1 and
variable ùëè on line 31 are identical except for equivalent variables.
Since ùëÉ
ùë°
‚àí ‚Üíùúñ, by Figure 4-4,ùëÑ .= ùëÑùëò+1.
146
Case 3: ùëÉ is of the form ‚ÄúIf‚Äù. ùëÉ expands to ‚Äúif ùëÑ then ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol.
By Lemma 4.6.7, ifùëì2 = true then ùúÜ2,ùëò+1 = NotLoop, so execution does not
enter the branch on line 17.
Since ùëÉ‚Ä≤ ùë°‚Ä≤
‚àí ‚ÜíùëÉ, by Figure 4-4,ùëÉ is a subprogram ofùëÉ‚Ä≤. HenceùëÑ is a query in
ùëÉ‚Ä≤. SinceùëÉ‚Ä≤‚ààK, by Definition 3.3.4 and Proposition 4.2.6,Trim(ùëÉ‚Ä≤) = ùëÉ‚Ä≤.
HenceùëÑ is a query inTrim(ùëÉ‚Ä≤). By Proposition 4.2.17, there exists a context
ùúé ‚ààContext such thatùëÑ is used while evaluatingùúé(ùëÉ‚Ä≤) and the corresonding
row count is zero (or positive). So both of the path constraintsùëä0, ùëä1 are
satisfiable. By Proposition 4.1.6, variablesùëì0 = ùëì1 = true.
Since Trim(ùëÉ‚Ä≤) = ùëÉ‚Ä≤ and ùëÉ is subprogram ofùëÉ‚Ä≤, by Algorithm 8, it is not
possible to have ùëÉ1 = ùëÉ2 = ùúñ. By Definition 3.3.4 and Definition 4.3.6,
ùúãSF(ùëÉ1) Ã∏= ùúãSF(ùëÉ2).
By Lemma 4.6.10,ùëÉ‚Ä≤ ùë°0,1
‚àí‚àí‚ÜíùëÉ2 and ùëÉ2
ùë°0,2
‚àí‚àí‚Üíùúñ. By Lemma 4.6.10, ùëÉ‚Ä≤ ùë°1,1
‚àí‚àí‚ÜíùëÉ1
and ùëÉ1
ùë°1,2
‚àí‚àí‚Üíùúñ.
Case 3.1: ùëÉ1 = ùúñ and ùëÉ2 Ã∏= ùúñ.
By Figure 4-4,ùë°1,2 = Nil andùë°0,2 Ã∏= Nil.
Case 3.2: ùëÉ1 Ã∏= ùúñ and ùëÉ2 = ùúñ.
By Figure 4-4,ùë°1,2 Ã∏= Nil andùë°0,2 = Nil.
Case 3.3: ùëÉ1 Ã∏= ùúñ and ùëÉ2 Ã∏= ùúñ.
By Figure 4-4,ùë°1,2 Ã∏= Nil andùë°0,2 Ã∏= Nil. ùëÑ0,ùëò+2
.= F(ùëÉ2). ùëÑ1,ùëò+2
.=
F(ùëÉ1). Since ùúãSF(ùëÉ1) Ã∏= ùúãSF(ùëÉ2), we haveùúãSùëÑ0,ùëò+2 Ã∏= ùúãSùëÑ1,ùëò+2.
In all of these cases, execution enters the branch on line 23.
By the induction hypothesis,ùëÉ2 and the variable
ùëèùëì = InferProg( ùëÉ‚Ä≤, ùë°0,1, ùë°0,2)
147
on line 26 are identical except for equivalent variables. Also, ùëÉ1 and the
variable ùëèùë° = InferProg( ùëÉ‚Ä≤, ùë°1,1, ùë°1,2) are identical except for equivalent
variables.
Since ùëÉ
ùë°
‚àí ‚Üíùúñ, by Figure 4-4,ùëÑ .= ùëÑùëò+1.
Case 4: ùëÉ is of the form ‚ÄúFor‚Äù. ùëÉ expands to ‚Äúfor ùëÑ do ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol.
Since ùëÉ‚Ä≤ ùë°‚Ä≤
‚àí ‚ÜíùëÉ, by Figure 4-4,ùëÉ is a subprogram ofùëÉ‚Ä≤. HenceùëÑ is a query in
ùëÉ‚Ä≤. SinceùëÉ‚Ä≤‚ààK, by Definition 3.3.4 and Proposition 4.2.6,Trim(ùëÉ‚Ä≤) = ùëÉ‚Ä≤.
HenceùëÑ is a query inTrim(ùëÉ‚Ä≤). By Proposition 4.2.17, there exists a context
ùúé ‚ààContext such thatùëÑ is used while evaluatingùúé(ùëÉ‚Ä≤) and the corresonding
row count is at least two. So the path constraint ùëä2 is satisfiable. By
Proposition 4.1.6, variableùëì2 = true.
By Lemma 4.6.7, variableùúÜ2,ùëò+1 Ã∏= NotLoop. Execution enters the branch
on line 17.
By Lemma 4.6.11,ùëÉ‚Ä≤ ùë°2,1
‚àí‚àí‚ÜíùëÉ1 and ùëÉ1
ùë°2,2
‚àí‚àí‚Üíùúñ. By the induction hypothesis,
ùëÉ1 and the variableùëèùë° = InferProg( ùëÉ‚Ä≤, ùë°2,1, ùë°2,2) on line 22 are identical
except for equivalent variables.
Case 4.1: ùëì0 = true.
By Lemma 4.6.11, ùëÉ‚Ä≤ ùë°0,1
‚àí‚àí‚ÜíùëÉ2 and ùëÉ2
ùë°0,2
‚àí‚àí‚Üíùúñ. By the induction
hypothesis, ùëÉ2 and the variableùëèùëì = InferProg( ùëÉ‚Ä≤, ùë°0,1, ùë°0,2) on
line 22 are identical except for equivalent variables.
Case 4.2: ùëì0 = false.
The path constraintùëä0 is unsatisfiable. SinceTrim(ùëÉ‚Ä≤) = ùëÉ‚Ä≤, by
Algorithm 8,ùëÉ2 = ùúñ. Hence ùëÉ2 = ùëèùëì on line 22.
Since ùëÉ
ùë°
‚àí ‚Üíùúñ, by Figure 4-4,ùëÑ .= ùëÑùëò+1.
148
Algorithm 10Recursively infer a subprogram (Algorithm 6) with more detail
Input: ùëÉ is the executable of a programùëÉ ‚ààK.
Input: ùë†1 is a prefix of an annotated trace.
Input: ùë†2 is a suffix of an annotated trace.
Output: Subprogram equivalent toùëÉ‚Äôs subprogram after traceùë†1.
1: procedure InferProg( ùëÉ , ùë†1, ùë†2)
2: if ùë†2 = Nil then returnùúñ ‚óÅ Prog := ùúñ
3: end if
4: ùëò ‚ÜêThe length ofùë†1
5: if ùëò >0 then ‚ü®ùëÑ1, ùëü1, ùúÜ1‚ü©, . . . ,‚ü®ùëÑùëò, ùëüùëò, ùúÜùëò‚ü©‚Üê ùë†1
6: end if
7: ‚ü®ùëÑùëò+1, ùëüùëò+1, ùúÜùëò+1‚ü©, . . . ,‚ü®ùëÑùëõ, ùëüùëõ, ùúÜùëõ‚ü©‚Üê ùë†2
8: for ùëñ = 0, 1, 2 do
9: ùëäùëñ ‚ÜêMakePathConstraint(ùë†1, ùëÑùëò+1, ùëñ)
10: (ùëìùëñ, ùë°ùëñ) ‚ÜêSolveAndGetTrace( ùëÉ , ùëäùëñ)
11: if ùëìùëñ then ‚óÅ Satisfiable
12: ‚ü®ùëÑ1, ùëüùëñ,1, ùúÜùëñ,1‚ü©, . . . ,‚ü®ùëÑùëò+1, ùëüùëñ,ùëò+1, ùúÜùëñ,ùëò+1‚ü©,
‚ü®ùëÑùëñ,ùëò+2, ùëüùëñ,ùëò+2, ùúÜùëñ,ùëò+2‚ü©, . . . ,‚ü®ùëÑùëñ,ùëöùëñ, ùëüùëñ,ùëöùëñ, ùúÜùëñ,ùëöùëñ‚ü©‚Üê ùë°ùëñ
13: ùë°ùëñ,1 ‚Üê‚ü®ùëÑ1, ùëüùëñ,1, ùúÜùëñ,1‚ü©, . . . ,‚ü®ùëÑùëò+1, ùëüùëñ,ùëò+1, ùúÜùëñ,ùëò+1‚ü© ‚óÅ New trace prefix
14: ùë°ùëñ,2 ‚Üê‚ü®ùëÑùëñ,ùëò+2, ùëüùëñ,ùëò+2, ùúÜùëñ,ùëò+2‚ü©, . . . ,‚ü®ùëÑùëñ,ùëöùëñ, ùëüùëñ,ùëöùëñ, ùúÜùëñ,ùëöùëñ‚ü© ‚óÅ New trace suffix
15: end if
16: end for
17: if ùëì2 and ùúÜ2,ùëò+1 Ã∏= NotLoop then
18: ùëèùë° ‚ÜêInferProg( ùëÉ , ùë°2,1, ùë°2,2)
19: if ùëì0 then ùëèùëì ‚ÜêInferProg( ùëÉ , ùë°0,1, ùë°0,2)
20: elseùëèùëì ‚Üêùúñ
21: end if
22: return ‚Äúfor ùëÑùëò+1 do ùëèùë° else ùëèùëì ‚Äù ‚óÅ Prog := For
23: else ifùëì0 and ùëì1 and ((ùë°0,2 = Nil and ùë°1,2 Ã∏= Nil) or (ùë°0,2 Ã∏= Nil and ùë°1,2 = Nil) or
(ùë°0,2 Ã∏= Nil and ùë°1,2 Ã∏= Nil and ùúãSùëÑ0,ùëò+2 Ã∏= ùúãSùëÑ1,ùëò+2)) then
24: ùëèùë° ‚ÜêInferProg( ùëÉ , ùë°1,1, ùë°1,2)
25: ùëèùëì ‚ÜêInferProg( ùëÉ , ùë°0,1, ùë°0,2)
26: return ‚Äúif ùëÑùëò+1 then ùëèùë° else ùëèùëì ‚Äù ‚óÅ Prog := If
27: else
28: if ùëì0 then ùëè ‚ÜêInferProg( ùëÉ , ùë°0,1, ùë°0,2)
29: elseùëè ‚ÜêInferProg( ùëÉ , ùë°1,1, ùë°1,2)
30: end if
31: return ‚ÄúùëÑùëò+1 ùëè‚Äù ‚óÅ Prog := Seq
32: end if
33: end procedure
149
4.6.3 Soundness of Infer
Theorem 4(Soundness of Inference). For any programùëÉ ‚ààK, ùëÉ .= Infer( ùëÉ ).
Proof. By Definition 3.4.20, the variableùúé in Algorithm 1 satisfies the trivial path
constraint Nil. By Figure 4-4, there exists an annotated traceùë°‚Ä≤ such that ùëÉ
ùë°‚Ä≤
‚àí ‚Üíùúñ.
By Definition 3.4.26,ùë°‚Ä≤ ‚àºNil. By Definition 4.1.4, the trivial path constraint Nil is
derived fromùëÉ.
Since ùëÉ ‚ààK, by Theorem 2, variableùë° satisfies ùëÉ
ùë°
‚àí ‚Üíùúñ. By Figure 4-4,ùëÉ
Nil
‚àí‚ÜíùëÉ.
By Theorem 3,ùëÉ .= InferProg( ùëÉ , Nil, ùë°).
Corollary 4.6.12.For any programsùëÉ1, ùëÉ2 ‚ààK, ifùëÉ1 ‚â°ùëÉ2 then ùëÉ1
.= ùëÉ2.
Proof. By Proposition 4.2.8,Infer( ùëÉ1 ) = Infer( ùëÉ2 ). Since ùëÉ1, ùëÉ2 ‚ààK, by The-
orem 4,ùëÉ1
.= Infer( ùëÉ1 ) and ùëÉ2
.= Infer( ùëÉ2 ).
Corollary 4.6.13.For any programsùëÉ1, ùëÉ2 ‚ààK, ùëÉ1 ‚â°ùëÉ2 if and only ifùëÉ1
.= ùëÉ2.
Proof. By Proposition 4.2.13 and Corollary 4.6.12.
4.7 Complexity
We show that the number of recursive calls to Algorithm 6 is linear in the size of the
given program.
Lemma 4.7.1.For any programsùëÉ ‚ààProg andùëÉ‚Ä≤‚ààK and annotated tracesùë°, ùë°‚Ä≤, if
ùëÉ‚Ä≤ ùë°‚Ä≤
‚àí ‚ÜíùëÉ and ùëÉ
ùë°
‚àí ‚Üíùúñ then the execution ofInferProg( ùëÉ‚Ä≤, ùë°‚Ä≤, ùë°) calls theInferProg
procedure at most(‚ÄñùëÉ‚Äñ‚àí1) times.
Proof. This proof is by induction on the derivation ofùëÉ.
Case 1: ùëÉ = ùúñ.
By Figure 4-4,ùë° = Nil. By Algorithm 6, the procedure returns immediately
without callingInferProg. By Definition 4.1.5,‚Äñùúñ‚Äñ= 1.
150
Case 2: ùëÉ is of the form ‚ÄúSeq‚Äù.ùëÉ expands to ‚ÄúùëÑ ùëÉ1‚Äù, where ùëÑ corresponds to the
Query symbol andùëÉ1 corresponds to the Prog symbol.
By the proof of Theorem 3, execution in Algorithm 6 enters the branch on
line 24. This branch calls theInferProg procedure once. At least one of
the variables ùëì0, ùëì1 is true. When ùëìùëñ = true (ùëñ = 0 , 1), by the induction
hypothesis, InferProg( ùëÉ‚Ä≤, ùë°ùëñ,1, ùë°ùëñ,2) recursively calls theInferProg pro-
cedure at most(‚ÄñùëÉ1‚Äñ‚àí1) times. Either case, InferProg is totally called
at most1 + (‚ÄñùëÉ1‚Äñ‚àí1) = ‚ÄñùëÉ1‚Äñtimes. By Definition 4.1.5,‚ÄñùëÉ‚Äñ= 1 + ‚ÄñùëÉ1‚Äñ.
Case 3: ùëÉ is of the form ‚ÄúIf‚Äù. ùëÉ expands to ‚Äúif ùëÑ then ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol.
By the proof of Theorem 3, execution in Algorithm 6 enters the branch on
line 20. This branch calls theInferProg procedure twice. By the induc-
tion hypothesis, InferProg( ùëÉ‚Ä≤, ùë°0,1, ùë°0,2) calls the InferProg procedure
at most(‚ÄñùëÉ2‚Äñ‚àí1) times andInferProg( ùëÉ‚Ä≤, ùë°1,1, ùë°1,2) calls theInferProg
procedure at most(‚ÄñùëÉ1‚Äñ‚àí1) times. Hence, InferProg is totally called at
most 2 + (‚ÄñùëÉ1‚Äñ‚àí1) + (‚ÄñùëÉ2‚Äñ‚àí1) = ‚ÄñùëÉ1‚Äñ+ ‚ÄñùëÉ2‚Äñtimes. By Definition 4.1.5,
‚ÄñùëÉ‚Äñ= 1 + ‚ÄñùëÉ1‚Äñ+ ‚ÄñùëÉ2‚Äñ.
Case 4: ùëÉ is of the form ‚ÄúFor‚Äù. ùëÉ expands to ‚Äúfor ùëÑ do ùëÉ1 else ùëÉ2‚Äù, where ùëÑ
corresponds to the Query symbol,ùëÉ1 corresponds to the first Prog symbol,
and ùëÉ2 corresponds to the second Prog symbol.
By the proof of Theorem 3, execution in Algorithm 6 enters the branch on
line 14. This branch calls theInferProg procedure at most twice. The rest
of the proof is similar to the proof of Case 3.
Theorem 5 (Complexity). For any programùëÉ ‚ààK, the execution ofInfer( ùëÉ )
calls theInferProg procedure at most‚ÄñùëÉ‚Äñtimes.
151
Proof. By the proof of Theorem 4, we haveùëÉ
Nil
‚àí‚ÜíùëÉ and ùëÉ
ùë°
‚àí ‚Üíùúñ for the variableùë° in
Algorithm 1. By Lemma 4.7.1, the execution ofInferProg( ùëÉ , Nil, ùë°) recursively
calls theInferProg procedure at most(‚ÄñùëÉ‚Äñ‚àí1) times. By Algorithm 1, the execu-
tion ofInfer( ùëÉ ) directly calls theInferProg procedure once. HenceInferProg
is totally called at most1 + (‚ÄñùëÉ‚Äñ‚àí1) = ‚ÄñùëÉ‚Äñtimes.
4.8 Remark on the Konure DSL
We next discuss the outcomes of usingKonure to infer programs that are not inK.
4.8.1 Programs in Konure DSL Grammar
Apart from the set of inferrable programsK (Definition 3.3.4) for which we designed
Konure, we also identify the following interesting sets of programs in Prog, where
we obtain a stronger result.
Definition 4.8.1.
ùêæ2 = {ùëÉ |ùëÉ ‚ààProg, ÃÉÔ∏ÄùëÉ ‚ààK}
ùêæ3 = {ùëÉ |ùëÉ ‚ààProg, ‚àÉùëÉ‚Ä≤‚ààK : ùëÉ ‚â°ùëÉ‚Ä≤}
ùêæ4 = {ùëÉ |ùëÉ ‚ààProg, Infer( ùëÉ ) ‚â°ùëÉ}
ùêæ2 representsthesetofprogramsinProgforwhichthe Trim transformationproduces
an equivalent program inK. ùêæ3 represents the set of programs in Prog that have an
equivalent program inK but theTrim transformation may not necessarily produce
the program inK. ùêæ4 represents the set of programs in Prog thatInfer is able to
infer correctly, although it is not designed to support these programs (because our
Konure DSL restrictions are conservative).
Corollary 4.8.2.For any programsùëÉ1, ùëÉ2 ‚ààùêæ2, ifùëÉ1 ‚â°ùëÉ2 then ÃÉÔ∏ÅùëÉ1
.= ÃÉÔ∏ÅùëÉ2.
Proof. By Definition 3.3.2 and Theorem 7,ÃÉÔ∏ÅùëÉ1 ‚â°ùëÉ1 and ÃÉÔ∏ÅùëÉ2 ‚â°ùëÉ2. By Definition 4.2.7,
ÃÉÔ∏ÅùëÉ1 ‚â°ÃÉÔ∏ÅùëÉ2. By the definition ofùêæ2, ÃÉÔ∏ÅùëÉ1, ÃÉÔ∏ÅùëÉ2 ‚ààK. By Corollary 4.6.12,ÃÉÔ∏ÅùëÉ1
.= ÃÉÔ∏ÅùëÉ2.
152
Corollary 4.8.3. For any programùëÉ ‚ààùêæ3, let ùëÉ‚Ä≤ ‚ààK such that ùëÉ ‚â°ùëÉ‚Ä≤, then
ùëÉ‚Ä≤ .= Infer( ùëÉ ).
Proof. By the definition ofùêæ3, such programùëÉ‚Ä≤ exists. Since ùëÉ ‚â°ùëÉ‚Ä≤, by Proposi-
tion 4.2.8,Infer( ùëÉ ) = Infer( ùëÉ‚Ä≤). By Theorem 4,ùëÉ‚Ä≤ .= Infer( ùëÉ‚Ä≤).
We distinguish the setsK, ùêæ2, ùêæ3, ùêæ4, and Prog as follows.
Proposition 4.8.4.K ‚äÇùêæ2.
Proof. 1. K ‚äÜùêæ2: For any program ùëÉ ‚ààK, by Definition 3.3.4, there exists
programùëÉ‚Ä≤‚ààProg such thatùëÉ = ÃÉÔ∏ÅùëÉ‚Ä≤. By Definition 3.3.2 and Proposition 4.2.6,
ÃÉÔ∏ÅÃÉÔ∏ÅùëÉ‚Ä≤= ÃÉÔ∏ÅùëÉ‚Ä≤. In other words,ÃÉÔ∏ÄùëÉ = ùëÉ ‚ààK. Hence, ùëÉ ‚ààùêæ2.
2. K Ã∏= ùêæ2: Consider the following example. Let queries ùëÑ1, ùëÑ2 ‚ààQuery such
that ùúãSùëÑ1 Ã∏= ùúãSùëÑ2 and that there exists contextsùúé, ùúé‚Ä≤‚ààContext such thatùëÑ1
retrieves nonempty data withùúé and retrieves empty data withùúé‚Ä≤. Let program
ùëÉ ‚ààProg be as follows:
ùëÉ = if ùëÑ1 then {if ùëÑ1 then ùëÑ2 else ùúñ}else ùúñ
By Definition 3.3.2,
ÃÉÔ∏ÄùëÉ = if ùëÑ1 then {ùëÑ1 ùëÑ2}else ùúñ
By Definition 3.3.4, ÃÉÔ∏ÄùëÉ ‚ààK. By the definition ofùêæ2, ùëÉ ‚ààùêæ2. Since ùëÉ Ã∏= ÃÉÔ∏ÄùëÉ,
by Proposition 4.2.6, there does not exist any programùëÉ‚Ä≤ ‚ààProg such that
ùëÉ = ÃÉÔ∏ÅùëÉ‚Ä≤. By Definition 3.3.4,ùëÉ Ã∏‚ààK.
Proposition 4.8.5.ùêæ2 ‚äÇùêæ3.
Proof. 1. ùêæ2 ‚äÜùêæ3: For any programùëÉ ‚ààùêæ2, by definition, ÃÉÔ∏ÄùëÉ ‚ààK. By Defini-
tion 3.3.2 and Theorem 7,ùëÉ ‚â°ÃÉÔ∏ÄùëÉ. Hence ùëÉ ‚ààùêæ3.
153
2. ùêæ2 Ã∏= ùêæ3: Consider the following example. Let queriesùëÑ1, ùëÑ2, ùëÑ3, ùëÑ4 ‚ààQuery
such that ùúãSùëÑ1, ùúãSùëÑ2, ùúãSùëÑ3, ùúãSùëÑ4 are distinct and that there exists contexts
ùúé, ùúé‚Ä≤ ‚ààContext such that ùëÑ1 retrieves nonempty data with ùúé and retrieves
empty data withùúé‚Ä≤. Let programsùëÉ1, ùëÉ2 ‚ààProg be as follows:
ùëÉ1 = ùëÑ1 ùëÑ2 if ùëÑ1 then ùëÑ3 else ùëÑ4
ùëÉ2 = if ùëÑ1 then {ùëÑ2 ùëÑ1 ùëÑ3}else {ùëÑ2 ùëÑ1 ùëÑ4}
By Definition 4.2.7,ùëÉ1 ‚â°ùëÉ2. By Definition 3.3.2, ÃÉÔ∏ÅùëÉ1 = ùëÉ1 and ÃÉÔ∏ÅùëÉ2 = ùëÉ2. By
Definition 3.3.4,ùëÉ1 ‚ààK and ùëÉ2 Ã∏‚ààK. Hence ùëÉ2 ‚ààùêæ3 and ùëÉ2 Ã∏‚ààùêæ2.
Proposition 4.8.6.ùêæ3 ‚äÇùêæ4.
Proof. 1. ùêæ3 ‚äÜùêæ4: For any programùëÉ ‚ààùêæ3, by definition, there exists program
ùëÉ‚Ä≤ ‚ààK such that ùëÉ ‚â°ùëÉ‚Ä≤. By Theorem 4, ùëÉ‚Ä≤ .= Infer( ùëÉ‚Ä≤). By Proposi-
tion 4.2.13,ùëÉ‚Ä≤‚â°Infer( ùëÉ‚Ä≤). By Definition 4.2.7,Infer( ùëÉ‚Ä≤) ‚â°ùëÉ.
2. ùêæ3 Ã∏= ùêæ4: Consider the following programùëÉ ‚ààProg.
if ùë¶1 ‚Üêselect * from t1 where t1 .val1 = ùë•1 {
ùë¶2 ‚Üêselect * from t2 where t2 .val1 = ùë¶1.t1 .val1
ùë¶3 ‚Üêselect * from t2 where t2 .id = ùë•1
if ùë¶4 ‚Üêselect * from t1 where t1 .val1 = ùë•1 ‚àß t1 .val2 = ùë•2 {
if ùë¶5 ‚Üêselect * from t1 where t1 .val1 = ùë•1 ‚àß t1 .val2 = ùë•3
{
for ùë¶6 ‚Üêselect * from t1 where t1 .val1 = ùë•1 {
ùë¶7 ‚Üêselect * from t2 where t2 .val1 = ùë¶6.t1 .val1
} else {}
} else {}
} else {}
} else {}
Variables ùë•1, ùë•2, ùë•3 are distinct input parameters. Tablet1 has columns val1
and val2. Tablet2 has columnsid and val1, whereid is the primary key.
154
By Definition 3.3.2, ÃÉÔ∏ÄùëÉ = ùëÉ. Since query ùë¶1 may return more than one row,
ùë¶1 ‚ààT( ÃÉÔ∏ÄùëÉ). Since queriesùë¶2 and ùë¶7 have the same skeleton,ùë¶1 ‚ààR( ÃÉÔ∏ÄùëÉ). Hence
T( ÃÉÔ∏ÄùëÉ) ‚à©R( ÃÉÔ∏ÄùëÉ) Ã∏= ‚àÖ. By Definition 3.3.4,ÃÉÔ∏ÄùëÉ Ã∏‚ààK. Hence ùëÉ Ã∏‚ààK and ùëÉ Ã∏‚ààùêæ2.
To show that ùëÉ ‚àà ùêæ4, we first show that the loop detection algorithm in
Algorithm 3 correctly identifies loops forùëÉ. Letùëüùëñ = |ùë¶ùëñ|be the number of rows
retrieved by queryùë¶ùëñ for eachùëñ = 1, 2, . . . ,7. When execution enters queryùë¶6,
we haveùëü1 > 0, ùëü4 > 0, and ùëü5 > 0. Hence ùë¶1 Ã∏= ‚àÖ, ùë¶4 Ã∏= ‚àÖ, and ùë¶5 Ã∏= ‚àÖ. Note
that the rows retrieved byùë¶4 and ùë¶5 are both subsets of the rows retrieved by
ùë¶1, that is,ùë¶4 ‚äÜùë¶1 and ùë¶5 ‚äÜùë¶1. Since ùë•2 and ùë•3 are distinct input parameters,
the Konure inference algorithm assigns them different values (Section 3.6).
Hence the rows retrieved byùë¶4 and ùë¶5 are disjoint, that is,ùë¶4 ‚à©ùë¶5 = ‚àÖ. Since
ùë¶4 and ùë¶5 are both nonempty, we haveùë¶4 ‚äÇùë¶1 and ùë¶5 ‚äÇùë¶1. Hence ùëü1 > ùëü4 > 0,
ùëü1 > ùëü5 > 0, andùëü1 ‚â•2. Since queriesùë¶1 and ùë¶6 are identical,ùëü1 = ùëü6 ‚â•2. Since
query ùë¶7 is repeatedùëü6 ‚â•2 times in the trace, the loop detection algorithm in
Algorithm 3 correctly identifies queryùë¶7 as iterations of a loop that iterates
over queryùë¶6.
We next discuss the two other sets of repetitive query skeletons:
(a) Queries ùë¶2 and ùë¶7 have the same skeleton. During execution, this skeleton
is repeated (ùëü6 + 1) times in the trace. Since ùëü6 + 1 = ùëü1 + 1 Ã∏= ùëü1, the
loop detection algorithm does not incorrectly identify queriesùë¶1 and ùë¶7 as
iterations of a loop that iterates over queryùë¶1.
(b) Queries ùë¶4 and ùë¶5 have the same skeleton. Since queryùë¶3 selects data by
the primary key, ùëü3 ‚â§1. Hence the loop detection algorithm does not
incorrectly identify queriesùë¶4 and ùë¶5 as iterations of a loop that iterates
over queryùë¶3.
For these reasons, theDetectLoops procedure is able to infer the correct loop
layout trees. The rest of theKonure inference algorithm producesInfer( ùëÉ ),
where ùëÉ .= Infer( ùëÉ ). By Proposition 4.2.13, ùëÉ ‚â° Infer( ùëÉ ). By the
definition ofùêæ4, ùëÉ ‚ààùêæ4.
155
To show that ùëÉ Ã∏‚àà ùêæ3, assume by way of contradiction that ùëÉ ‚àà ùêæ3. By
the definition ofùêæ3, there existsùëÉ‚Ä≤ ‚ààK such that ùëÉ ‚â°ùëÉ‚Ä≤. By Theorem 4,
ùëÉ‚Ä≤ .= Infer( ùëÉ‚Ä≤). SinceùëÉ ‚â°ùëÉ‚Ä≤, the black box programsùëÉ and ùëÉ‚Ä≤ are obser-
vationallyequivalent. HenceInfer( ùëÉ ) = Infer( ùëÉ‚Ä≤). SinceùëÉ .= Infer( ùëÉ ),
we haveùëÉ .= ùëÉ‚Ä≤. No matter how we alterùëÉ with different but equivalent origin
locations, the queryùë¶1 may still return more than one row and the queriesùë¶2
and ùë¶7 still have the same skeleton. HenceT(ùëÉ‚Ä≤) ‚à©R(ùëÉ‚Ä≤) Ã∏= ‚àÖ. Since ùëÉ‚Ä≤ ‚ààK,
we have the desired contradiction. HenceùëÉ Ã∏‚ààùêæ3.
Proposition 4.8.7.ùêæ4 ‚äÇProg.
Proof. 1. ùêæ4 ‚äÜProg: By definition.
2. ùêæ4 Ã∏= Prog: Consider the following example. Let queriesùëÑ1, ùëÑ2 ‚ààQuery such
that ùúãSùëÑ1 and ùúãSùëÑ2 are distinct and that there exists contextùúé ‚ààContext such
that ùëÑ1 retrieves two rows withùúé. Let programùëÉ ‚ààProg be as follows:
ùëÉ = ùëÑ1 ùëÑ2 ùëÑ2
The execution ofInfer( ùëÉ ) may fail because the loop detection algorithm in
Algorithm 3 may observeùëÑ1 retrieve two rows in an execution and mistakenly
identify the two subsequentùëÑ2 queries as two iterations of a loop. HenceùëÉ Ã∏‚àà
ùêæ4.
Proposition 4.8.4 states that the Trim transformation transforms certain pro-
grams that are not in theKonure DSL into equivalent programs in theKonure
DSL. Proposition 4.8.5 states that theTrim transformation does not transform all
of the potential programs into theKonure DSL. Proposition 4.8.6 states that the
restrictions in Definition 3.3.4 are conservative, that is, there are programs not ex-
pressible in the Konure DSL but still allows theKonure inference algorithm to
156
infer the correct program. Proposition 4.8.7 states that theKonure DSL syntax
alone is not sufficient for inferrability.
4.8.2 Programs Expressible in Konure DSL
Recall that two programs in Prog are observationally equivalent (Definition 4.2.7)
if they produce the same concrete trace (Definition 3.4.6) for all contexts. In other
words, when these programs are executed as black boxes (Definition 3.4.8), they
always produce the same list of SQL queries and the same retrieved rows. These
concrete traces are the only behavior directly observed byKonure in theExecute
procedure. We extend our results to black box programs that are not necessarily
written in theKonure DSL grammar but share the externally visible behavior of
some program inK.
Definition 4.8.8. ùëà denotes the black box executable for a program with an un-
known implementation. To executeùëà with a contextùúé ‚ààContext, we populate the
database, set the input parameters, and collect the concrete trace as in theExecute
procedure.
Definition 4.8.9. ùëà is expressible as program ùëÉ ‚ààProg if for all contextsùúé ‚àà
Context, executing ùëà with ùúé produces ùúé(ùëÉ). ùëà is expressible inK if there exists a
program ùëÉ ‚ààK such that ùëà is expressible asùëÉ.
Proposition 4.8.10.For any programùëÉ ‚ààùêæ3, ùëÉ is expressible inK.
Proof. By the definition ofùêæ3 (Definition 4.8.1), there exists programùëÉ‚Ä≤ ‚ààK such
that ùëÉ ‚â°ùëÉ‚Ä≤. By Definition 4.2.7, for any contextùúé ‚ààContext, ùúé(ùëÉ) = ùúé(ùëÉ‚Ä≤). By
Definition 3.4.8, executingùëÉ produces ùúé(ùëÉ‚Ä≤). By Definition 4.8.9,ùëÉ is expressible
as ùëÉ‚Ä≤ and is expressible inK.
Proposition 4.8.11. For any program ùëÉ ‚ààProg, if ùëà is expressible as ùëÉ then
Infer( ùëà ) = Infer( ùëÉ ).
Proof. By Definition 4.8.9, for any contextùúé ‚ààContext,
Execute( ùëà , ùúé) = Execute( ùëÉ , ùúé).
157
By Algorithm 1,Infer( ùëà ) = Infer( ùëÉ ).
Corollary 4.8.12. For any programùëÉ ‚ààK, if ùëà is expressible as ùëÉ then ùëÉ .=
Infer( ùëà ).
Proof. By Proposition 4.8.11 and Theorem 4.
Corollary 4.8.12 states that, as long as the program executable is expressible inK,
Konure infers it correctly. The program can be implemented in arbitrary languages
or programming styles.
Example programs that can be expressible in Konure DSL include the data
retrieval components of task managers, blogs, chat rooms, and inventory management
systems. In practice, most of the real-world programs, even if expressible in the
Konure DSL, are implemented in standard programming languages such as Java,
Ruby, and Python. Because of our black box approach,Konure can work with these
programs as long as their externally visible behavior conforms to theKonure DSL.
158
Chapter 5
Experimental Evaluation ofKonure
We evaluate our program inference technique with the following research questions:
‚Ä¢ RQ1: Ability to Infer and Regenerate Benchmark Programs. Can
Konure infer real-world applications that access databases?
We used Konure to infer the commands in several open-source database-
backed applications (Section 5.1). We present positive results, whereKonure
infers the commands in reasonable amounts of time, in Section 5.1.2 and discuss
limitations in Section 5.1.3.
‚Ä¢ RQ2: Scalability.Howdoesourtechniquescalewithmorecomplexprograms?
Our results indicate thatKonure scales well for most dimensions of program
complexity. The only dimension for whichKonure does not scale well is the
length of ambiguous long reference chains (Section 5.2).
‚Ä¢ RQ3: Active Learning Versus User Inputs.How does our active learning
technique compare with manual user inputs?
Our results indicate that, in contrast to our active learning approach, the man-
ual approach often misses infrequent corner cases (Section 5.3).
We performed experiments on a Ubuntu 16.04 virtual machine with 2 cores and
2 GB memory. The host machine uses a processor with 4 cores (3.4 GHz Intel Core
159
i5) and has 24 GB 1600 MHz DDR3 memory. OurKonure implementation uses
Python 3.5.3 (PyPy 6.0.0) and Z3 4.6.0.
5.1 RQ1: Ability to Infer and Regenerate Bench-
mark Programs
We implemented aKonure prototype and acquired five benchmark applications to
evaluatethisprototype. Eachapplicationhasmultiplecommandsthataccessdifferent
parts of the database. Each command takes input parameters, translates the inputs
into SQL queries against the relational database, and returns results extracted from
the results of the queries.
5.1.1 Benchmark Applications
Our benchmark applications include:
‚Ä¢ Fulcrum Task Manager:Fulcrum [3] is an open-source project planning tool,
built with Ruby on Rails, with over 1500 stars on GitHub. The source code
contains 3642 lines of JavaScript, Ruby, SASS, and HTML. Fulcrum maintains
multiple projects. Each project may contain multiple stories. Each story may
contain multiple notes. Fulcrum retrieves data from 5 relevant tables with
55 columns. Its commands enable users to navigate the contents of projects,
stories, and notes, as well as the users who created these contents.
‚Ä¢ Kandan Chat Room: Kandan [5] is an open-source chat room application,
built with Ruby on Rails, with over 2700 stars on GitHub. The source code
contains 8438 lines of JavaScript, CoffeeScript, SASS, CSS, Ruby, and HTML.
Kandan maintains multiple chat rooms (so-called channels) that users can ac-
cess. Kandan retrieves data from 4 relevant tables with 41 columns. Its com-
mands enable users to navigate chat rooms and messages (so-called activities)
and display relevant user information.
160
‚Ä¢ Enki Blogging Application:Enki [2] is an open-source blogging application,
built with Ruby on Rails, with over 800 stars and 280 forks on GitHub. The
source code contains 2589 lines of Ruby, HTML, JavaScript, CSS, and SASS.
Enki maintains multiple pages and posts, each of which may have comments.
Enki retrieves data from 5 relevant tables with 39 columns. Its commands
enable the author of the blog to navigate pages, posts, and comments.
‚Ä¢ Blog: The Blog application is an example obtained from the Ruby on Rails
website [4]. The source code contains 232 lines of HTML, Ruby, and JavaScript.
Blog maintains information about blog articles and blog comments. Blog re-
trieves data from 2 relevant tables with 11 columns. It implements a command
that retrieves all articles and a command that retrieves a specific article and its
associated comments.
‚Ä¢ Student Registration:The student registration application discussed in Sec-
tion 3.1. This application was adapted from an earlier version of a program
developed by the MITRE Corporation. The version was developed specifically
for studying the detection and nullification of SQL injection attacks. In the
test suite titled ‚ÄúIARPA STONESOUP Phase 1 - Injection for Java‚Äù [7], the
version ‚ÄúTC_Java_89_m100‚Äù is the most similar to the program that we used
and implements largely the same functionality. The application was written in
Java and interacts with a MySQL database [165] via JDBC [123]. The source
code contains 1264 lines of Java. It retrieves data from 5 relevant tables with
17 columns.
The Fulcrum, Enki, and Blog servers receive HTTP requests, interact with the
database accordingly, and respond the client with an HTML page that contains
the data retrieved. The Kandan server receives HTTP requests, interacts with the
database accordingly, and responds with JSON objects that contain data retrieved
and HTML templates to display the JSON data. For these applications, theKonure
prototype works with the retrieved database results after they are automatically ex-
tracted from the surrounding HTML/JSON code. Student Registration implements
161
a command-line interface that receives text commands, interacts with the database
accordingly, and responds with text output. A copy of the source code for these
benchmark applications is available at [10].
Application Selection Criteria. We choose our real world benchmark applica-
tions ‚Äî Fulcrum, Kandan, and Enki ‚Äî from the applications studied in a recent
survey paper [173]. We choose these three applications because their core functional-
ity shares a common pattern, as characterized by theKonure DSL. We omit other
applications in the survey mainly for three reasons:
‚Ä¢ In some applications, the control flow and the data flow are similar to that of
the Konure DSL. However, these applications perform computations that are
more complicated than theKonure DSL currently supports. Such computa-
tions often belong to standard domains such as string manipulation, aggregate
calculation, and date/time conversion. Example applications include task man-
agers, chat rooms, and blogs with more complicated features than Fulcrum,
Kandan, and Enki. To support these applications, we anticipate that the solver
for Konure would need to incorporate more knowledge to work productively
with a number of standard domains.
‚Ä¢ Some applications implement highly specialized calculations. For example, on-
line shopping applications perform specific numeric calculations specific to that
domain.
‚Ä¢ Insomeapplications, thecontrolflowdoesnotdependprimarilyontheresultsof
database queries. Example applications include file sharing applications whose
control logic relies heavily on the state of the file system. To support these
applications, we anticipate thatKonure would need to observe the file sys-
tem traffic and incorporate the file system operations into the active learning
algorithm.
The remaining benchmark applications ‚Äî Blog and Student ‚Äî implement interesting
core functionality that is expressible in theKonure DSL.
162
Based on our understanding and use of the applications, we identified data re-
trieval commands that these applications execute as part of their standard function-
ality. In general, these commands step through tables, typically using results from
earlier look-ups to access the correct data in current tables. As a command traverses
tables, it collects data to return to the user. Fulcrum uses five database tables, Kan-
dan uses four database tables, Enki uses five database tables, Blog uses two database
tables, and Student Registration uses five database tables. For Fulcrum, we identified
eight of 14 data retrieval commands as potential inference candidates. For Kandan,
we identified six of 11, for Enki, four of ten, for Blog, two of two, and for Student
Registration, one of one. The remaining commands in these applications often imple-
ment specialized data or control flow that are not expressible in theKonure DSL.
We discuss unsupported commands in Section 5.1.3.
5.1.2 Results
Webuiltvirtualmachinesforexecutingtheseapplications, thenconfiguredour Konure
prototype to operate properly in this context. Specifically, the Rails framework stores
password hashes in the database. Based on the Rails configuration, the Rails frame-
work uses these hashes to perform a password check at the start of specified com-
mands. We configured ourKonure prototype to generate databases and parameters
that, during inference, always pass the password check. We also support the insertion
of boilerplate password checking code into the regenerated code for specified com-
mands. We anticipate that the automated introduction of such boilerplate code will
be standard in many usage contexts. We then usedKonure to infer and regener-
ate the commands. The source code for the regenerated commands is available in
Appendix A and at [6].
Table 5.1 presents statistics from running theKonure prototype on the com-
mands. The first column (Command) presents the name of the command. The
second (Params) presents the number of input parameters for the command. The
third (App) presents the name of the application.
The next column (Runs) presents the number of executions thatKonure used to
163
Table 5.1: Inference effort and regenerated code size
Command Params App Runs Solves Time LoC SQL If For Output
get_home1 Fulcrum 5 43 8 mins 21 5 1 0 9
get_projects1 Fulcrum 5 43 8 mins 21 5 1 0 9
get_projects_id2 Fulcrum 12 124 29 mins 25 8 2 0 8
get_projects_id_stories2 Fulcrum 11 42 7 mins 31 8 3 0 11
get_projects_id_stories_id3 Fulcrum 12 50 8 mins 31 9 3 0 11
get_projects_id_stories_id_notes3 Fulcrum 11 41 8 mins 24 9 3 0 4
get_projects_id_stories_id_notes_id4 Fulcrum 13 46 10 mins 28 10 4 0 4
get_projects_id_users2 Fulcrum 12 124 30 mins 25 8 2 0 8
get_channels1 Kandan 21 125 105 mins 63 16 4 2 27
get_channels_id_activities2 Kandan 23 242 39 mins 49 16 6 0 13
get_channels_id_activities_id3 Kandan 14 18 7 mins 25 11 3 0 3
get_me1 Kandan 11 139 6 mins 44 8 3 0 25
get_users1 Kandan 15 236 9 mins 67 11 3 0 45
get_users_id2 Kandan 11 139 6 mins 44 8 3 0 25
get_admin_comments_id1 Enki 2 5 22 secs 10 1 0 0 5
get_admin_pages0 Enki 2 1 22 secs 13 2 1 0 4
get_admin_pages_id1 Enki 2 5 23 secs 9 1 0 0 4
get_admin_posts0 Enki 3 2 33 secs 16 3 1 1 3
get_articles0 Blog 2 11 21 secs 12 2 0 0 6
get_article_id1 Blog 6 29 42 secs 16 3 1 0 6
liststudentcourses2 Student 6 20 41 secs 24 5 3 1 3
164
infer the command. Each execution involves a set of generated input values presented
to the application working with generated database contents. All commands require
fewer than 30 executions to obtain a model for the command as expressed in the
Konure DSL. The next column (Solves) presents the number of invocations of the
Z3 SMT solver thatKonure executed to infer the model for the command. Because
Konure may invoke the SMT solver multiple times for each inference step, the
number of Z3 invocations is larger than the number of application executions. The
next column (Time) presents the wall-clock time required to infer the model for each
command. The times vary from less than a minute to about two hours. In general, the
times are positively correlated with the number of solves, the length of the programs,
and the number of potentially ambiguous origin locations. Most of the inference time
was spent on solving for alternative database contents to satisfy various constraints.
The inference time also includes the time required to set up, tear down, and execute
the applications (and their web servers) in theKonure environment.
The remaining columns present statistics from the regenerated Python implemen-
tations. The LoC, SQL, If, For, andOutput columns present the number of lines
of code, SQL statements, If statements, For statements, and the number of lines that
generate output.
Quality of the Regenerated Code.We recruited a software engineer with three
years of experience working with Ruby on Rails applications to evaluate theKonure
inference and regeneration by comparing the original Ruby on Rails and regenerated
Python versions of each command. Starting from a command URL, the software en-
gineer locates the relevant controller, models, and views in the original Ruby on Rails
application to form an understanding of the program functionality. The software
engineer mentally translates the Ruby on Rails abstractions into concrete actions
and compares them against the regenerated Python code. (1) One complication was
that the Ruby on Rails framework automatically generates a substantial amount of
database traffic that is not directly reflected in the Ruby on Rails code. This traffic
was explicitly reflected in the regenerated code. The software engineer was occasion-
165
ally surprised to see these queries in the regenerated code, but eventually understood
that they accurately reflect the low-level implementation of the high-level aspect ab-
stractions in Ruby on Rails. (2) Another complication was that the Ruby on Rails
implementation contains auxiliary functionality (such as session management) which
performs database queries and checks the query results against specific values (such
as checking if the user is an admin). OurKonure implementation captures these
database queries and includes them in the regenerated code, but does not currently
regenerate the associated conditional checks against the specific values. After taking
these phenomena into account, the software engineer determined that the regenerated
commands were consistent with the original Ruby on Rails implementations.
The evaluation also highlights how the Rails framework, specifically the ActiveRe-
cord object relational mapping abstraction, implicitly generates substantial database
traffic as it assembles the object state (including the state of objects on which it
depends) when initially loading the object. This code that generates this database
traffic is explicit and therefore directly visible in the regenerated Python code.
This comparison of the original Ruby on Rails code with the regenerated version
highlights two key properties of the regenerated version. (1) Understandability: Be-
cause the regenerated Python code performs database queries explicitly, we anticipate
that the regenerated code can help developers comprehend the program behavior at
the level of database queries. (2) Streamlined implementation: The regenerated code
contains only the core functionality as expressed in theKonure DSL and does not
need to implement the less common features that are required in comprehensive ab-
straction frameworks such as Ruby on Rails. As a result, the regenerated program is
often lighter weight than the original application.
Noisy Specifications. We note that the regenerated programs are free of SQL in-
jection attack vulnerabilities, asKonure regenerates programs using a standard SQL
library in Python that systematically eliminates the possibility of these attacks. How-
ever, these vulnerabilities are present in the original student registration application.
These vulnerabilities are rare corner cases that are not captured by theKonure DSL.
166
Thus, Konure omits them and infers only the common use cases of the program.
These results highlight the ability ofKonure to work with noisy specifications.
5.1.3 Commands Not Expressible in Konure DSL
In our experiments, we observed data-retrieval commands that are not fully express-
ible in theKonure DSL. For example, several Enki commands condition on whether
a retrieved value is ‚ÄúNULL‚Äù (undetected conditionals). Several other Enki commands
combine multiple input parameters before using the combined value to access the
database (unanticipated data calculations). A Kandan command produces inconsis-
tent traces even if the path constraints in theKonure inference algorithm remain
unchanged (unanticipated control flow). In addition to these real-world applications
and commands, we also developed an adversarial synthetic program that may cause
non-termination of theKonure inference algorithm. We usedKonure to infer these
commands and report the outcomes below with representative examples.
Undetected Conditionals OutsideKonure DSL (Omitted Functionality).
Recall from Sections 3.3.4 and 3.3.5 thatKonure is designed to infer control struc-
tures that depend largely on externally observable data, specifically, the database
queries and results. A program that is not expressible in theKonure DSL may con-
tain a conditional statement that, after retrieving data from the database, compares
a retrieved value against a specific constant value (such as ‚ÄúNULL‚Äù, ‚Äú1‚Äù, or ‚Äúadmin‚Äù).
Konure is not designed to generate the specific inputs and database values for in-
ferring conditional statements of this form, especially when the conditional checks
are not externally observable. As a resultKonure may infer a slice of the program
functionality that conforms to theKonure DSL, omitting the undetected branches,
without reporting any errors.
Omitting functionality in this form enablesKonure to work with noisy specifi-
cations. Konure is likely to work well with programs whose main functionality is
expressible in theKonure DSL with exceptions on rare corner cases. For example,
if a program is defective when handling rare corner case inputs (and database val-
167
ues), Konure is likely to omit the functionality for the rare corner cases and end up
inferring only the main functionality.
Example 5.1.1.Consider the following Python program inspired by the applications
in our experiments.
def outside (conn , inputs ):
s1 = util . do_sql (conn , ‚Äô SELECT * FROM t1 WHERE id = :x‚Äô, {‚Äôx‚Äô:
inputs [0]})
if util . has_rows (s1):
v = util . get_one_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô)
print (v)
if v == 0:
crash ()
else :
s2 = util . do_sql (conn , ‚Äô SELECT * FROM t2 WHERE id = :x‚Äô, {‚Äôx‚Äô
: v})
The database has two tables,t1 and t2. Each table has two columns,id and val,
both holding integers. The columnid of each table is the unique primary key. The
conn variable is an established database connection. Theinputs variable holds the
list of input parameters. This program uses one input parameter,inputs[0]. The
call toutil.do_sql first assembles an SQL query by replacing ‚Äú:x‚Äù with the value of
the input parameter, then performs this query on the database, and finally stores the
retrieved rows in variables1. The call toutil.has_rows checks whether variables1
holds nonempty rows. Whens1 holds nonempty rows, the call toutil.get_one_data
extracts from this row the integer in columnval and stores it in variablev. After
printing the value ofv, the program behaves differently depending on whether this
value equals a constant number, zero. Depending on this check, the program either
crashes or proceeds to perform another query. This conditional check is not directly
observable in the database traffic and causes the program to be not expressible in
Konure DSL.
When inferring this program, our currentKonure implementation does not gen-
erate database values that cause variablev to equal zero. As a result this program
168
never enters the corresponding branch.Konure thus infers and regenerates a slice
of this program that performs the second query regardless of the value ofv. During
this inference,Konure does not report any errors.
Error Reported for Unanticipated Control Flow Behavior. We designed
Konure to work with programs expressible in theKonure DSL. For example, the
inference algorithm assumes that all conditional statements in the program must
condition on query results being empty or nonempty. In other words, if a query
produces the same empty/nonempty results across two executions of the program,
the program should continue to execute the same path in both executions. This
assumption does not hold for programs that are not expressible in theKonure DSL.
For these programs, different executions may behave inconsistently depending on
unanticipated factors. In this case,Konure may detect the unanticipated behavior,
report an error, and exit prematurely.
Example 5.1.2.Consider the following Python program inspired by the applications
in our experiments.
def outside (conn , inputs ):
s1 = util . do_sql (conn , ‚Äô SELECT * FROM t1 WHERE id = :x‚Äô, {‚Äôx‚Äô:
inputs [0]})
if rand ():
s2 = util . do_sql (conn , ‚Äô SELECT * FROM t2 WHERE id = :x‚Äô, {‚Äôx‚Äô:
inputs [1]})
print (s2)
if rand ():
s3 = util . do_sql (conn , ‚Äô SELECT * FROM t2 WHERE val = :x‚Äô, {‚Äôx‚Äô:
inputs [2]})
print (s3)
if rand ():
s4 = util . do_sql (conn , ‚Äô SELECT * FROM t1 WHERE id = :x‚Äô, {‚Äôx‚Äô:
inputs [1]})
print (s4)
The database has two tables,t1 and t2. Each table has two columns,id and val,
169
both holding integers. The columns id are the unique primary keys. The conn
variable is an established database connection. Theinputs variable holds the list of
input parameters. This program uses three input parameters,inputs[0], inputs[1],
and inputs[2]. Each call toutil.do_sql first assembles an SQL query by replacing
‚Äú:x‚Äù with the value of the specified input parameter, then performs this query on
the database. The retrieved rows are then stored in the corresponding variable,s1,
s2, s3, or s4. Each call to rand obtains a random boolean value, either True or
False. Conditioned on these random values, the program may or may not execute
the branches that perform queries fors2, s3, and s4. We use therand function to
emulate the effects of uninferrable conditional expressions that are not captured by
the Konure DSL.
When inferring this program, our currentKonure implementation often observes
two inconsistent executions. Both executions perform the query fors2 and retrieve
empty data. However, in one execution the next query is the query fors3, while in the
other execution the next query is the query fors4. This behavior is not expressible
in the Konure DSL, which triggers an assertion failure in our currentKonure
implementation.
ErrorReportedforUnanticipatedDataCalculations. Wedesignedthe Konure
DSL to express programs whose data flow manifests as SQL queries, which are ex-
ternally observable in the database traffic. Programs not in theKonure DSL may
perform calculations, such as arithmetics and string manipulations, using general-
purpose programming language features that are not observable byKonure. These
calculations may produce values that do not equal any of the inputs or database val-
ues. In this caseKonure detects the unanticipated value, reports an error, and exits
prematurely.
Example 5.1.3.Consider the following Python program inspired by the applications
in our experiments.
def outside (conn , inputs ):
x = average ( inputs [0] , inputs [1])
170
s1 = util . do_sql (conn , ‚Äô SELECT * FROM t1 WHERE val = :x‚Äô, {‚Äôx‚Äô:
x})
print (s1)
The database has a tablet1 with two columns,id and val, both holding integers.
The conn variable is an established database connection. Theinputs variable holds
the list of input parameters. This program uses two input parameters,inputs[0] and
inputs[1], both assumed to be integers. The program first calculates the average
valueofthetwoinputparametersandstoresitinvariable x. Notethatthiscalculation
is not expressible in theKonure DSL. Also, the value ofx may not equal any of the
inputs or database values. The program then callsutil.do_sql to perform an SQL
query using the value ofx.
When inferring this program, our currentKonure implementation often reports
that the query contains an unanticipated value for whichKonure cannot find an
origin location. This behavior triggers an assertion failure in our currentKonure
implementation.
Potential Non-Termination. There are adversarial programs for whichKonure
might not terminate, nor report an error.
Example 5.1.4.Consider the following adversarial program, written in Python.
def outside (conn , inputs ):
v = inputs [0]
while True :
s1 = util . do_sql (conn , ‚Äô SELECT * FROM t1 WHERE id = :x‚Äô, {‚Äôx‚Äô:
v})
if util . has_rows (s1):
print (v)
v = util . get_one_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô)
else :
break
print (‚ÄôDone ‚Äô)
Thedatabasehasatable t1 withtwocolumns, id andval, bothholdingintegers. The
171
column id is the unique primary key. Theconn variable is an established database
connection. The inputs variable holds the list of input parameters. This program
uses one input parameter,inputs[0]. The call to util.do_sql first assembles an
SQL query by replacing ‚Äú:x‚Äù with the value of variablev, then performs this query
on the database, and finally stores the retrieved rows in variables1. Because this
query selects rows by the primary key, the query always retrieves at most one row.
The call toutil.has_rows checks whether variables1 holds nonempty rows. When
s1 holds nonempty rows, which must be exactly one row in this program, the call to
util.get_one_data extracts from this row the integer in columnval. The program
then uses the extracted value to update variablev.
If we useKonure to infer this program as a black box, the inference algorithm
may not terminate. Recall that the inference algorithm repeatedly represents an
unvisited branch as a path constraint and uses this path constraint to solve for a
satisfying context. It is always possible for the solver to return a context that causes
Konure to infer that the program contains deeper nested conditional branches. For
example, let variable ùëñ be the input parameter and queriesùëÑùëò be as follows (ùëò =
1, 2, 3, . . .):
ùëÑ1 = ùë¶1 ‚Üêselect t1.id, t1.val where t1.id = ùëñ ; print [t1.id],
ùëÑùëò+1 = ùë¶ùëò+1 ‚Üêselect t1.id, t1.val where t1.id = ùë¶ùëò.t1.val ; print [t1.id].
For eachùëò = 1, 2, 3, . . ., the path constraint
ùëäùëò = ‚ü®ùëÑ1, ‚â•1, true‚ü©, . . .‚ü®ùëÑùëò, ‚â•1, true‚ü©
always has a satisfying context that allows the program above to terminate when
executed. If the solver forKonure returns these contexts, the inference algorithm
172
could update the hypothesis,ùëÉ, as follows:
ùëÉ = if ùëÑ1 then ùëÉ1 else ùúñ,
ùëÉ = if ùëÑ1 then {if ùëÑ2 then ùëÉ2 else ùúñ }else ùúñ,
ùëÉ = if ùëÑ1 then {if ùëÑ2 then {if ùëÑ3 then ùëÉ3 else ùúñ }else ùúñ }else ùúñ,
ùëÉ = . . . ,
where ùëÉ1, ùëÉ2, ùëÉ3 denote Prog nonterminals that remain to be inferred. Here, the
inference algorithm would populate tablet1 with more and more rows, updating the
hypothesis with deeper and deeper nested conditional statements. The hypothesis
would always contain an unvisited branch for the case where the last query in the
trace retrieves nonempty data. Hence, the inference algorithm would not terminate
in this adversarial situation.
Our current Konure implementation uses an off-the-shelf SMT solver that is
not maximally distinct. As a result the solver often returns a context that causes
the program to enter an infinite loop when executed, without allowing ourKonure
implementation to proceed to non-termination as described above.
5.2 RQ2: Scalability
We evaluate the scalability of the inference algorithm with experiments on the follow-
ing classes of synthetic commands. The source code for these commands is available
in Appendix B and at [6].
‚Ä¢ Simple Sequences (SS):A sequence of different queries, without any con-
ditional or loop statements. Each query does not reference any previously re-
trieved data.
‚Ä¢ Nested Conditionals (NC):A series of nested conditional statements. Each
except the innermost If statement has a nested If statement in thethen branch.
The innermost If statement has a query in thethen branch. None of the queries
173
reference previously retrieved data.
‚Ä¢ Unambiguous Long Reference Chains (UL):Like (NC), but each query
references data retrieved by the previous query when the data is nonempty.
‚Ä¢ Ambiguous Long Reference Chains (AL):Like (UL), but eachthen block
has an additional query before the nested If statement. This additional query
retrieves a superset of the data that will be retrieved by the next query.
‚Ä¢ Ambiguous Short Reference Chains (AS):Like (NC), but eachthen block
has an additional query before the nested If statement. This additional query
retrieves a superset of the data that will be retrieved by the next query, which
prints the retrieved data.
Weexpectthecurrent Konure implementationto(1)scalewellfor(SS)and(NC)
commands ‚Äî the fact that the queries are independent makes it straightforward to
translate path constraints to a small number of logical formulas, (2) scale well for
(UL) commands, because disambiguation is unnecessary, (3) scale poorly for (AL)
commands, because the number of disambiguation constraints grows rapidly as the
length of the query reference chain increases, and (4) scale well for (AS) commands,
because the reference chains are short.
5.2.1 Results
For each class above, we built representative commands with varying code sizes.
We then usedKonure to infer each command. Figure 5-1 presents statistics from
running Konure on these synthetic commands. For SS commands (Figure 5-1a), the
horizontal axis presents the number of queries in the command. For the remaining
commands(Figures5-1b-5-1e), thehorizontalaxispresentsthenumberofconditionals
in the command plus one. The left vertical axis presents the number of runs, solves,
or lines of code. The linesRuns(executions of the command),Solves(invocations of
Z3), andLoC(lines of code in the command) use this axis. The first right vertical axis
presents the inference time in seconds. The lineTime (wall-clock time for inference)
174
(a) (SS) commands
 (b) (NC) commands
(c) (UL) commands
 (d) (AL) commands
(e) (AS) commands
Figure 5-1: Performance on synthetic commands
uses this axis. The second right vertical axis presents the number of constraints that
Konure sends to the SMT solver during inference. The linesPathCstr(constraints
to enforce an execution path) andDisamCstr (constraints to disambiguate origin
locations) use this axis. In Figure 5-1d,Konure ran out of memory after the version
with five conditionals.
5.2.2 Discussion
Konure scales well for (SS), (NC), (UL), and (AS) commands, which is consistent
with results in Section 5.1.Konure does not scale well for (AL) commands, where
the major performance bottleneck is sending the solver disambiguation constraints
(Section 3.6). We did not optimizeKonure to generate a small number of disam-
biguation constraints, so the communication dominates the inference time. After Z3
receives constraints, it solves them quickly.
175
We anticipate that commands with ambiguous long reference chains will occur
rarely in practice, as the structure of database tables typically supports the applica-
tion functionality well enough to access the desired data by navigating through only
several tables. The four commands from Table 5.1 with the longest inference times
(get_projects_id, get_projects_id_users, get_channels, and get_channels_
id_activities) all infer in feasible times. We therefore anticipate the inference
algorithm will scale to handle real applications.
Since we expect ambiguous long reference chains to occur rarely, we did not op-
timize Konure for this case. If this issue becomes important in practice, a way to
mitigate it would be to develop a solver that returns maximally distinct values. This
solver would ensure that unrelated origin locations hold disjoint values.
Because Konure analyzes each command separately, it scales linearly with the
number of commands. Therefore, it easily scales to handle applications with many
commands, which is often the primary source of complexity.
5.3 RQ3: Active Learning Versus User Inputs
Instead of using active learning, an alternative approach is to use dynamic monitoring
to obtain inputs for interacting with the seed program. To better evaluate the value of
activelearninginourcontext, weimplementedasystemthatobservesinputs, outputs,
and database traffic generated during normal use to infer models of programs that
access databases [134]. The results show that this approach often fails to infer the
full functionality of the application because it often misses infrequent corner cases. In
contrast, Konure uses active learning to find inputs, as opposed to asking the user
for examples or specifications.
Wrapping a standard CEGIS-style loop [145] around this system would require
access to a specification, such as the source code of a reference implementation, that
describes the program behavior to synthesize. In contrast,Konure treats the given
program as a black box and infers the program behavior based on its externally visible
inputs, outputs, and database traffic.
176
5.4 Conclusion
Applications that read relational databases are pervasive in modern computing en-
vironments. We present new active learning techniques that automatically infer and
regenerate these applications. Key aspects of these techniques include (1) the for-
mulation of an inferrable DSL that supports the range of computational patterns
that these applications exhibit and (2) the inference algorithm, which progressively
synthesizes inputs and database contents that productively resolve uncertainty in the
current working hypothesis. Results from our implementation highlight the ability of
this approach to infer and regenerate applications that access relational databases.
Looking towards the future we see opportunities extending these techniques. An
immediate extension would be expanding the DSL with domain-specific knowledge
that enables more effective generation of inputs and database contents. More broadly,
future work might expand the domains of computations that work with active learn-
ing and identify other crucial components of complex systems that may benefit from
inference and regeneration. Another future direction would be to intervene, in addi-
tion to observing, the application behavior during execution. A goal here would be to
leverage the intervention to more effectively expose learnable application behavior.
177
178
Chapter 6
Shear: Inferring Loop Structures in
Database-Backed Applications via
Speculative Manipulation
In this chapter, we first present an example that illustrates howShear works. We
then present the design and implementation ofShear, including the problem formu-
lation, the algorithm for inferring loop and repetitive structures, and the algorithm
for inferring the full program structure.
6.1 Example
We present an example that illustrates howShear uses speculative manipulation to
analyze the loop and repetitive structures in a database program.
Example Program. Figure 6-1 presents the code of a task management program,
where each function calldo_sql(query, params) performs a database query by re-
placing the variables inquery with the corresponding values specified inparams. The
program takes an input argument,tid, and retrieves data from three database tables:
tasks, comments, and users. It first retrieves a task specified by the input. When the
task exists, the program retrieves comments under this task. For each comment, the
179
tasks1 = do_sql (" SELECT * FROM tasks WHERE id = :x",
{"x": tid })
print ( tasks1 [‚Äôtitle ‚Äô])
if tasks1 :
comments = do_sql (" SELECT * FROM comments WHERE task_id = :x",
{"x": tid })
print ( comments [‚Äô content ‚Äô])
for c in comments :
cid = c[‚Äô commenter_id ‚Äô]
users1 = do_sql (" SELECT * FROM users WHERE id = :x",
{"x": cid })
print ( users1 [‚Äôname ‚Äô])
tasks2 = do_sql (" SELECT * FROM tasks WHERE creator_id = :x",
{"x": cid })
print ( tasks2 [‚Äôtitle ‚Äô])
aid = tasks1 [‚Äô assignee_id ‚Äô]
users2 = do_sql (" SELECT * FROM users WHERE id = :x",
{"x": aid })
print ( users2 [‚Äôname ‚Äô])
tasks3 = do_sql (" SELECT * FROM tasks WHERE creator_id = :x",
{"x": aid })
print ( tasks3 [‚Äôtitle ‚Äô])
Figure 6-1: Example program in Python
program retrieves the user that made this comment, along with all tasks created by
this user. After iterating over comments, the program retrieves the user to which the
task is assigned, along with all tasks created by this user.
An example execution of the program uses the tasks and comments tables in Fig-
ure 6-2a, the users table empty, and the inputtid=2. Figure 6-2b presents the result-
ing trace of the database traffic. This trace is an instance of the program behavior
that we observe when executing the program.
Ambiguities from Loops and Repetitions.Without knowing the ground truth,
our algorithm analyzes the trace to infer the program‚Äôs loop structure. We first
describe multiple plausible (but not equivalent) loop structures and then present how
our algorithm disambiguates these plausible structures to infer the correct one.
We highlight five plausible loop structures in Figure 6-3. Each of these structures
may produce the trace in Figure 6-2b. Each loop structure performs certain queries,
180
tasks: id title creator_id assignee_id
1 1 4 6
2 5 4 6
comments: id task_id commenter_id content
3 2 4 7
5 2 6 7
(a) Database tables
ùëû0 : SELECT * FROM tasks WHERE id = 2
ùëû1 : SELECT * FROM comments WHERE task_id = 2
ùëû2 : SELECT * FROM users WHERE id = 4
ùëû3 : SELECT * FROM tasks WHERE creator_id = 4
ùëû4 : SELECT * FROM users WHERE id = 6
ùëû5 : SELECT * FROM tasks WHERE creator_id = 6
ùëû6 : SELECT * FROM users WHERE id = 6
ùëû7 : SELECT * FROM tasks WHERE creator_id = 6
(b) SQL database traffic of an execution. The queries retrieve 1, 2, 0, 2, 0, 0, 0, and 0 rows,
respectively.
Figure 6-2: Example execution trace
iterates over the rows retrieved by a query, and optionally performs more queries after
the loop ends. We use comments (after the ‚Äú#‚Äù symbol) to represent queries produced
across different loop iterations. Among these candidate loop structures, the only one
that is consistent with the program (Figure 6-1) is Plausible Loop L (Figure 6-3a). All
other candidates are nonequivalent and incorrect, but also indistinguishable with the
trace alone. A key reason for these ambiguities is that the execution trace is almost
unstructured‚Äîthere are no pre-defined ways to split the trace to into segments that
correspond to loop iterations.
Shear infers the unique correct loop structure usingspeculative manipulation. To
do this, Shear first identifies potential execution points that correspond to queries
over which a loop may iterate. In our example, these queries areùëû1 and ùëû3, each
of which retrieved two rows. We illustrate these execution points as question marks
in Figure 6-4. For each of these execution points, Shear performs three altered
executions of the program to determine whether the potential loop is valid.
Probing Program Behavior via Speculative Manipulation. Shear uses a
proxy between the program and the database to relay and manipulate the SQL queries
181
ùëû0
for row in ùëû1:
ùëû2 #( ùëû4)
ùëû3 #( ùëû5)
ùëû6
ùëû7
(a) Correct Plausible Loop L
ùëû0
for row in ùëû1:
ùëû2 #( ùëû4)
if not ùëû3: #( ùëû5)
ùëû6
ùëû7
(b) Incorrect Plausible Loop W
ùëû0
for row in ùëû1:
ùëû2 #( ùëû4)
if not ùëû3: #( ùëû5)
ùëû6
ùëû7
(c) Incorrect Plausible Loop X
ùëû0
for row in ùëû1:
ùëû2 #( ùëû6)
if ùëû3: #( ùëû7)
ùëû4
ùëû5
(d) Incorrect Plausible Loop Y
ùëû0
ùëû1
ùëû2
for row in ùëû3:
ùëû4 #( ùëû6)
ùëû5 #( ùëû7)
(e) Incorrect Plausible Loop Z
Figure 6-3: Plausible loop structures that may produce the example trace
in the database traffic.Shear first reuses the original inputs and database contents
to start executing the program. When the program issues queryùëû0, Shear faithfully
relays the database traffic for this query. Next, when the program issues queryùëû1,
Shear strategically alters the SQL query intoùëû‚Ä≤
1 before forwarding it to the database.
The altered query ùëû‚Ä≤
1 retrieves only the first row among the rows that would have
been retrieved by the originalùëû1. The database performsùëû‚Ä≤
1 and retrieves the row as
requested, which is then relayed through the proxy back to the program. After this
manipulation, Shear resumes normal program execution until it terminates. The
manipulated execution produces the firstaltered tracethat consists of queriesùëû0, ùëû‚Ä≤
1,
ùëû2, ùëû3, ùëû6, andùëû7. Figure 6-5b illustrates this manipulation.
Shear nextobtainsthesecondalteredtrace. Shear faithfullyrelaysthedatabase
traffic for queryùëû0. When the program issues queryùëû1, Shear alters it intoùëû‚Ä≤‚Ä≤
1 , which
retrieves only the second row among the rows that would have been retrieved by query
182
Figure 6-4: Shear performs speculative manipulation to infer and regenerate
database-backed programs that may contain loop and repetitive structures
ùëû1. The database performsùëû‚Ä≤‚Ä≤
1 , whose rows are relayed through the proxy back to the
program. After this manipulation,Shear resumes normal program execution until
it terminates. The resulting altered trace consists of queriesùëû0, ùëû‚Ä≤‚Ä≤
1 , ùëû4, ùëû5, ùëû6, andùëû7.
Figure 6-6a illustrates this manipulation.
Finally,Shear obtains the third altered trace, where the queryùëû1 is altered toùëû‚Ä≤‚Ä≤‚Ä≤
1
that retrieves both the first and the second rows inùëû1. In this example,ùëû‚Ä≤‚Ä≤‚Ä≤
1 retrieves
the same results asùëû1. Hence the third altered trace consists of queriesùëû0, ùëû‚Ä≤‚Ä≤‚Ä≤
1 , ùëû2, ùëû3,
ùëû4, ùëû5, ùëû6, andùëû7. Figure 6-6b illustrates this manipulation.
Change-Set Validation Indicating the Presence of a Loop atùëû1. Shear
compares these three altered traces to determine if a loop iterates over the two rows
retrieved by queryùëû1. Note that queriesùëû0, ùëû‚Ä≤
1, ùëû‚Ä≤‚Ä≤
1 , andùëû‚Ä≤‚Ä≤‚Ä≤
1 are produced before any
iterations of the hypothetical loop.
Shear first compares the lengths of the three altered traces to calculate the
number of queries that would be produced by the subprogram after the hypothetical
loop ends. This number is calculated by adding up the lengths of the first two altered
traces after the hypothetical loop location (ùëû‚Ä≤
1 or ùëû‚Ä≤‚Ä≤
1 ), then subtracting with the length
of the third altered trace after the hypothetical loop location (ùëû‚Ä≤‚Ä≤‚Ä≤
1 ). In this example,
this number is 2. Figure 6-7 illustrates this comparison.
Shear uses this number to infer queries that would be produced by hypothetical
183
(a) Unaltered trace
 (b) First altered trace
Figure 6-5:Shear alters the database traffic during program execution to infer loops
structures from the example trace
loop iterations. Specifically,Shear removes from each altered trace the last 2 queries
and the queries before the hypothetical loop. Remaining queries in the first altered
trace areùëû2 and ùëû3, which would be produced by the first hypothetical loop iteration.
Remaining queries in the second altered trace areùëû4 and ùëû5, which would be produced
bythesecond hypothetical loopiteration. Remaining queries inthe third alteredtrace
are ùëû2, ùëû3, ùëû4, and ùëû5, which would be produced by both first two hypothetical loop
iterations.
Shear then uses these results to check if the hypothetical loop is valid. In this
example, the queries produced by the first hypothetical iteration (ùëû2 and ùëû3) comprise
a strict prefix of the queries produced by both of the first two hypothetical iterations
(ùëû2, ùëû3, ùëû4, andùëû5). Also, the last 2 queries in all three altered traces are identical (ùëû6
and ùëû7). Based on these observations,Shear determines that the program behavior
is consistent with the existence of a hypothetical loop.Shear therefore determines
184
(a) Second altered trace
 (b) Third altered trace
Figure 6-6:Shear alters the database traffic during program execution to infer loops
structures from the example trace (continued)
that a loop indeed iterates over the two rows retrieved by queryùëû1.
Change-Set Validation Indicating the Absence of a Loop atùëû3. Because
query ùëû3 also retrieved two rows during execution, there can potentially be a loop
that iterates over the two rows retrieved by queryùëû3 (Plausible Loop Z). To determine
whether this loop exists,Shear alters the database traffic for queryùëû3 to obtain three
altered traces. The first altered execution alters queryùëû3 into queryùëû‚Ä≤
3 which retrieves
only the first row in queryùëû3. The resulting altered trace consists of queriesùëû0, ùëû1,
ùëû2, ùëû‚Ä≤
3, ùëû4, ùëû5, ùëû6, andùëû7. The second altered execution alters queryùëû3 into queryùëû‚Ä≤‚Ä≤
3
which retrieves only the second row in queryùëû3. The resulting altered trace consists
of queries ùëû0, ùëû1, ùëû2, ùëû‚Ä≤‚Ä≤
3 , ùëû4, ùëû5, ùëû6, and ùëû7. The third altered execution alters query
ùëû3 into queryùëû‚Ä≤‚Ä≤‚Ä≤
3 which retrieves both the first and the second rows in queryùëû3. The
resulting altered trace consists of queriesùëû0, ùëû1, ùëû2, ùëû‚Ä≤‚Ä≤‚Ä≤
3 , ùëû4, ùëû5, ùëû6, andùëû7.
185
Figure 6-7:Shear validates the change-sets for the hypothesis L and concludes that
L is correct
(a) Expected if Z were correct
 (b) Traces that reject Z
Figure 6-8:Shear validates the change-sets for the hypothesis Z and concludes that
Z is incorrect
Shear first compares the lengths of the three altered traces to calculate the
number of queries that would be produced by the subprogram after the hypothetical
loop ends. This number is calculated by adding up the lengths of the first two altered
traces after the hypothetical loop location (ùëû‚Ä≤
3 or ùëû‚Ä≤‚Ä≤
3 ), then subtracting with the length
of the third altered trace after the hypothetical loop location (ùëû‚Ä≤‚Ä≤‚Ä≤
3 ). In this example,
this number is 4. Figure 6-8a illustrates the expected outcome of this comparison.
Shear then uses this number to infer the queries that would be produced by the
hypothetical loop iterations. Specifically,Shear removes the last 4 queries in each
alteredtraceandremovestheleadingqueriesuptothehypotheticallooplocation. For
all of the three altered traces, there are no remaining queries. Figure 6-8b illustrates
the actual outcome of this comparison.
Shear then uses these results to check if the hypothetical loop is valid. In this
example, the queries produced by the first hypothetical iteration (no queries) do no
comprise a strict prefix of the queries produced by both of the first two hypothetical
186
iterations (no queries). Based on these observations, Shear determines that the
program behavior is inconsistent with the existence of a hypothetical loop.Shear
determines that there are no loops that iterate over the two rows retrieved by query
ùëû3. Hence, Shear rules out the incorrect Plausible Loop Z.
Probing and Validating the Loop Body Structure.After Shear infers that a
loop iterates over queryùëû1, it manipulates the database traffic again to calculate the
loop iteration boundaries. For each row retrieved byùëû1, Shear obtains an altered
trace whereùëû1 is altered to retrieve only that single row. In this example, becauseùëû1
retrieves only two rows, these altered traces are already obtained earlier whenShear
detects the existence of the loop.
Shear compares these traces to first calculate the number of queries in the trace
that are generated by the after-loop subprogram. In this case, the after-loop sub-
program generates two queries (ùëû6 and ùëû7). This result is used to infer the number
of queries generated by each loop iteration. In this case, the first iteration generates
two queries (ùëû2 and ùëû3) and the second iteration generates two queries (ùëû4 and ùëû5).
Hence, Shear rules out the incorrect Plausible Loop W,X,Y and determines that the
Plausible Loop L is correct.
Regeneration. After inferring the precise loop and repetition structures,Shear
proceeds to infer the remaining program structure and regenerate the full program.
For the example program, ourShear implementation regenerates the code in Fig-
ure 6-9. LikeKonure, our currentShear implementation regenerates Python code
using a standard SQL library to perform database queries (Section 3.1).
Discussion. Shear‚Äôs program inference algorithm is based on several speculatively
manipulated executions of the program per hypothetical loop. The algorithm works
precisely with programs that may contain a variety of loop and repetitive structures
including nested loops, consecutive loops, loops with conditional statements, and non-
loop repetitive queries. These capabilities enable Shear to infer and regenerate a
wider range of computations than prior work.
187
def example_3 (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT * FROM tasks WHERE id = :x0", {‚Äô
x0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äôtasks ‚Äô, ‚Äôtitle ‚Äô))
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT * FROM comments WHERE
task_id = :x0", {‚Äôx0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s1 , ‚Äô comments ‚Äô, ‚Äô content ‚Äô))
s1_all = s1
for s1 in s1_all :
s2 = util . do_sql (conn , " SELECT * FROM users WHERE id =
:x0", {‚Äôx0 ‚Äô: util . get_one_data (s1 , ‚Äô comments ‚Äô, ‚Äô
commenter_id ‚Äô)})
outputs . extend ( util . get_data (s2 , ‚Äôusers ‚Äô, ‚Äôname ‚Äô))
s3 = util . do_sql (conn , " SELECT * FROM tasks WHERE
creator_id = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s1 , ‚Äô
comments ‚Äô, ‚Äô commenter_id ‚Äô)})
outputs . extend ( util . get_data (s3 , ‚Äôtasks ‚Äô, ‚Äôtitle ‚Äô))
s1 = s1_all
s4 = util . do_sql (conn , " SELECT * FROM users WHERE id = :x0"
, {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôtasks ‚Äô, ‚Äô assignee_id ‚Äô)})
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äôname ‚Äô))
s5 = util . do_sql (conn , " SELECT * FROM tasks WHERE
creator_id = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôtasks ‚Äô,
‚Äô assignee_id ‚Äô)})
outputs . extend ( util . get_data (s5 , ‚Äôtasks ‚Äô, ‚Äôtitle ‚Äô))
else :
pass
return util . add_warnings ( outputs )
Figure 6-9: Shear infers the example program and regenerates code in Python
188
(a) Generic concept
(b) Specialized for database-backed pro-
grams
Figure 6-10: Program inference and regeneration
6.2 Problem Formulation
Program inference and regeneration is the process of observing a program‚Äôs behavior,
inferringaspectsofthebehaviorasamodelinacertaindomain, andusingthisinferred
model to regenerate a new program (Figure 6-10a). Inferring programs that access
an external database involves observing the database interactions [135] (Chapter 3).
Shear extends this paradigm with speculative manipulation. That is,Shear not
only observes but also manipulates the database interactions (Figure 6-10b). In both
Shear and prior work, the technique consists of a DSL and an inference algorithm.
We present the DSL below and defer the inference algorithm overview to Section 6.4.1.
6.2.1 DSL for Inferrable Programs
The DSL characterizes the externally observable behavior of database-backed pro-
grams that can be inferred. The externally observable behavior consists of the input-
output behavior and the database interactions generated during program execution.
We first reiterate key characteristics of the DSL in prior work [135]: (1) each
statement performs an SQL query to retrieve rows from the database, (2) the retrieved
rows determine the control flow, and (3) the data flow is largely visible in the database
traffic.
We next present theShear DSL. Figure 6-11 presents the DSL for database-
backed programs that can be inferred and regenerated byShear. A program consists
of sequences (Seq), conditionals (If), or loops (For). Each Query statement performs
189
Prog := ùúñ | Seq | If | For
Seq := Query Prog
If := if Query then Prog else Prog
For := for Query do Prog ; Prog
Query := ùë¶ ‚Üê select Col+ where Expr ; print Orig*
Expr := true | Expr ‚àßExpr | Col = Col | Col = Orig
Col := ùë°.ùëê
Orig := ùë• |ùë¶.Col
ùë•, ùë¶‚ààVariable, ùë° ‚ààTable, ùëê ‚ààColumn
Figure 6-11: Grammar for theShear DSL
anSQL select operationthatretrievesdatafromthedatabase. Thequerystoresthe
retrieved data in a unique variable (ùë¶) for later use. An If statement tests if its Query
retrievesemptyornonemptydata. AForstatementiteratesovertherowsinitsQuery.
For loops may be nested. TheShear DSL is the set of programsS ‚äÇProg where the
two branches of any If statement start with queries with different skeletons.1 This
DSL expands expressiveness over prior work due toShear‚Äôs speculative manipulation
(Section 7.1.3).
This DSL targets database applications with commands that retrieve data from
an external database and, therefore, restricts SQL queries to onlyselect statements.
One common scenario here is that the commands implement an Internet-accessible,
database-backed application. The purpose of the application is to provide read access
to the database to remote users who access the database via the Internet.
We highlight the following characteristics ofShear‚Äôs target domain of compu-
tations as the key enablers of its loop inference capabilities: (1) There are strong
boundaries between components. Specifically, the interface between the program and
the external database serves as a strong boundary forShear to observe, probe, and
learn information. (2) The component interactions can be altered transparently dur-
ing program execution. Specifically, the database interactions are altered byShear
during program execution without causing runtime errors or crashes. (3) Loops in
1As in prior work, this restriction is designed merely to enhance performance distinguishing Seq
and If statements and does not affect the correctness of the algorithms.
190
ùúé ‚ààContext = Input √óDatabase √óResult
ùúéùêº ‚ààInput = Variable ‚ÜíValue
ùúéùê∑ ‚ààDatabase = Table ‚ÜíZ>0 ‚ÜíColumn ‚ÜíValue
ùúéùëÖ ‚ààResult = Variable ‚ÜíZ>0 ‚ÜíTable ‚ÜíColumn ‚ÜíValue
Value = Int ‚à™String
Figure 6-12: Contexts for programs in the DSL
the program iterate over collections that move across component boundaries. Specif-
ically, loops in the DSL iterate over the rows retrieved from the database. After
Shear alters a database query, the retrieved data changes accordingly, which in turn
triggers different behaviors in the remaining program. (4) The execution of each loop
iteration generates a deterministic and nonempty trace. In particular, the loop body
in the DSL is always nonempty. (5) Each loop iteration operates locally on a single
element of the collection. Specifically, each loop iteration in the DSL operates on an
individual row among all retrieved rows. This property enablesShear to perform
change-set validation to infer the loop structures.
6.2.2 Formalizing the Program Behavior
To facilitate discussion, we follow the notation in prior work [135] that characterizes
the general domain of database-backed programs and the behavior of such programs.
Below, we reiterate the relevant definitions and extend them to work with more so-
phisticated loop structures, specifically nested loops and loops followed by additional
statements.
Definition 6.2.1.A contextùúé = ‚ü®ùúéùêº, ùúéùê∑, ùúéùëÖ‚ü©‚àà Context (Figure 6-12) contains value
mappings for the input parameters (ùúéùêº), database contents (ùúéùê∑), and results retrieved
by database queries (ùúéùëÖ).
Definition 6.2.2. ùëÉ denotes the black box executable of a programùëÉ ‚ààProg.
Definition 6.2.3.A query-result pair(ùëÑ, ùëü) has a queryùëÑ ‚ààQuery and an integer
ùëü ‚ààZ‚â•0 that counts the number of rows retrieved byùëÑ during execution.
191
Definition 6.2.4.A loop layout treefor a programùëÉ ‚ààProg is a tree that represents
information about the execution of loops. Each node in the tree is a query-result pair
that corresponds to a query inùëÉ. Each node represents whether a loop inùëÉ iterates
over the corresponding query multiple times.
Definition 6.2.5.An annotated traceis an ordered list of annotated query tuples.
Each tuple, denoted as ‚ü®ùëÑ, ùëü, ùúÜ‚ü©, has three components. The first component is a
query ùëÑ ‚ààQuery. The second component is the number of rows retrieved byùëÑ
during an execution. The third component is the annotated information of whether
a loop was found to iterate over data retrieved byùëÑ. Each path from the root of
the loop layout tree to a leaf generates a corresponding annotated trace.
Definition 6.2.6.A path constraintùëä = (‚ü®ùëÑ1, ùëü1, ùëë1, ùëé1‚ü©, . . . ,‚ü®ùëÑùëõ, ùëüùëõ, ùëëùëõ, ùëéùëõ‚ü©) con-
sists of a sequence of queriesùëÑ1, . . . , ùëÑùëõ ‚ààQuery, row count constraintsùëü1, . . . , ùëüùëõ,
boolean flags ùëë1, . . . , ùëëùëõ, and boolean flagsùëé1, . . . , ùëéùëõ. Each ùëüùëñ specifies the range of
the number of rows. Eachùëëùëñ is true if a loop iterates over the corresponding retrieved
rows andfalse otherwise. Each ùëéùëñ is true if a loop iterates over the corresponding
retrieved rows and the path enters the subprogramafter the loop.
Definition6.2.7. Anannotatedtrace ùë° isconsistent withpathconstraint ùëä, denoted
as ùë° ‚àºùëä, if the path specified inùëä is not longer thanùë°, each query inùë° matches
a query inùëä, each row count inùë° matches a row count constraint inùëä, and each
after-loop status inùë° matches a flag inùëä.
Definition 6.2.8.For a programùëÉ ‚ààProg and a contextùúé ‚ààContext, ùúé ‚ä¢ùëÉ ‚áìexec ùëí
and ùúé ‚ä¢ùëÉ ‚áìloops ùëô denote evaluatingùëÉ in ùúé to obtain a list of query-result pairsùëí
and a loop layout treeùëô, respectively.
6.3 Probe-and-ValidateCycleforInferringLoopStruc-
tures
Shear takes a database-backed program, infers its functionality, then regenerates a
new version of the program with the same inferred functionality (Figure 6-10b). A
192
Algorithm 11 Infer if a loop iterates over a query by manipulating the database
traffic in three program executions
Input: ùëÉ istheexecutableof ùëÉ ‚ààS. ùúé isacontext. ùëò isaninteger, denotingahypothetical
loop atùëò-th query.
Output: Boolean ùëì represents whether a loop is found to iterate over theùëò-th query in the
trace from executing ùëÉ with ùúé.
Output: Integer ùëôùõº represents the number of queries in the trace produced by the subpro-
gram that follows the inferred loop.
1: procedure InferLoopExists( ùëÉ , ùúé, ùëò)
2: ùë†1 ‚ÜêExecAndPick( ùëÉ , ùúé, ùëò,[1]) ; ùë†2 ‚ÜêExecAndPick( ùëÉ , ùúé, ùëò,[2]) ; ùë†12 ‚Üê
ExecAndPick( ùëÉ , ùúé, ùëò,[1, 2])
3: ùë†‚Ä≤
1 ‚Üêùë†1[ùëò + 1, . . .] ; ùë†‚Ä≤
2 ‚Üêùë†2[ùëò + 1, . . .] ; ùë†‚Ä≤
12 ‚Üêùë†12[ùëò + 1, . . .]
4: ùëôùõº ‚ÜêLen(ùë†‚Ä≤
1) + Len(ùë†‚Ä≤
2) ‚àíLen(ùë†‚Ä≤
12) ‚óÅ Len. after hypo. loop
5: ùëô1 ‚ÜêLen(ùë†‚Ä≤
1) ‚àíùëôùõº ‚óÅ Len. of the first hypo. iteration
6: ùëô2 ‚ÜêLen(ùë†‚Ä≤
2) ‚àíùëôùõº ‚óÅ Len. of the second hypo. iteration
7: ùëô12 ‚ÜêLen(ùë†‚Ä≤
12) ‚àíùëôùõº ‚óÅ Len. of both hypo. iterations
8: ùõΩ1 ‚Üêùë†‚Ä≤
1[1, . . . , ùëô1] ‚óÅ Queries in the first hypo. iteration
9: ùõΩ12 ‚Üêùë†‚Ä≤
12[1, . . . , ùëô12] ‚óÅ Queries in both hypo. iterations
10: ùõº1 ‚Üêùë†‚Ä≤
1[ùëô1 + 1, . . .] ‚óÅ Queries after the hypo. loop
11: ùõº2 ‚Üêùë†‚Ä≤
2[ùëô2 + 1, . . .] ‚óÅ Queries after the hypo. loop
12: ùõº12 ‚Üêùë†‚Ä≤
12[ùëô12 + 1, . . .] ‚óÅ Queries after the hypo. loop
13: if ùõº1 = ùõº2 = ùõº12 and PerfectPrefix(ùõΩ1, ùõΩ12) then
14: return ‚ü®true, ùëôùõº‚ü© ‚óÅ Traces consistent with hypo. loop
15: end if
16: return ‚ü®false, Nil‚ü© ‚óÅ Traces inconsistent with hypo. loop
17: end procedure
key contribution of Shear is manipulating the program‚Äôs execution on the fly to
resolve ambiguities. Shear alters the program‚Äôs interactions with the environment
at precisely chosen execution points. Specifically,Shear infers loops in a database
programbyspeculativelyalteringthedatabaseinteractionsduringprogramexecution.
To infer whether there is a loop that iterates over a specific query,Shear removes
certain data from the corresponding database interactions and validates how it affects
program execution. With a small number of such altered executions,Shear infers
whether the execution point contains a loop and, if so, the structure of the loop.
6.3.1 Speculative Manipulation of Database Interactions
Shear manipulates the database interactions through a proxy interposed between
the program and the database. In a normal execution of the program, the proxy
193
(a) Unaltered trace
 (b) First altered trace
(c) Second altered trace
 (d) Third altered trace
Figure 6-13: Illustration of Algorithm 11 when applied to a true loop that iterates
over theùëò-th query
194
faithfully relays the interactions between the program and the database. In an
execution of the program whereShear alters the database interactions, theShear
proxy (conceptually) removes certain data from the database interactions while the
program runs. Technically, there are two general options to implement this alteration:
(1) altering the queries sent from the program to the database or (2) altering the data
sent from the database to the program. OurShear implementation uses the first
option.
ExecAndPick. This procedure takes a program, a context, an integerùëò, and
a list of distinct row indices ùúå. It executes the program with the context while
intercepting the database traffic.
For the first(ùëò ‚àí1) queries that the program sends to the database, the proxy
relays the traffic faithfully. Up to this point, the collected queries and their retrieved
data are identical to what would have been collected from a normal execution of the
program.
For theùëò-th query, the proxy alters the query so that it retrieves only a sub-list of
the rows that would have been retrieved if the query were unaltered. The sub-list of
rows is specified by the row indices inùúå. OurShear implementation alters the query
using standard SQL clauses ‚ÄúLIMIT‚Äù, ‚ÄúOFFSET‚Äù, and ‚ÄúORDER BY‚Äù. The proxy forwards
the altered query to the database, which retrieves (altered) data for the query. The
proxy sends the (altered) data back to the program, which processes the data and
continues execution accordingly.
After this alteration, theShear proxy continues to relay the rest of the database
traffic faithfully until the program terminates. The procedure returns the list of
collected SQL queries.
From the program‚Äôs viewpoint,Shear transparently removes certain rows from
the data that would have been retrieved. BecauseShear only removes rows, it only
mildly disturbs the execution flow. If the program conforms to theShear DSL, this
manipulation does not cause the program to crash. Moreover, in our experiments,
this manipulation works reliably with all of our benchmark applications, without
195
triggering any errors, warnings, or crashes.
6.3.2 Loop Inference Based on Fine-Grained Interactive Feed-
back
We next present howShear infers loops by performing speculative manipulation and
collecting feedback from the altered program executions.
Probing and Validating the Presence of a Loop
For each potential execution point that may contain loops,Shear first infers whether
the loop exists. If so,Shear then infers the structure of each loop iteration. Both
steps are achieved through probe-and-validate cycles (Figure 6-4).
InferLoopExists. Algorithm 11 infers whether a loop iterates over a specific
query during an execution of the program. This procedure takes the program and a
context ùúé. Executing the program with the contextùúé would produce a trace. The
third parameter,ùëò, is an integer query index. The procedure infers if theùëò-th query
in the trace was iterated over by a loop during program execution.
To infer whether a loop iterates over theùëò-th query, the procedure invokesEx-
ecAndPick three times. Each invocation executes the program withùúé and alters
the ùëò-th query. The first execution alters theùëò-th query to retrieve only the first
row among all of the rows that would have been retrieved in an unaltered execution.
The second execution alters the query to retrieve only the second row. The third ex-
ecution alters the query to retrieve only the first two rows. Each execution produces
an altered list of SQL queries. Because all three executions initially use the same
context ùúé to run the program, the three resulting altered lists are identical up to the
(ùëò ‚àí1)-th query. These three altered lists may differ after theùëò-th query, depending
on the structure of the program.
The InferLoopExists procedure then performs location-based change-set vali-
dation on these three altered lists, to infer whether the program contains a loop that
196
Algorithm 12Infer the loop body structure in terms of the lengths of loop iterations
Input: ùëÉ is the executable ofùëÉ ‚ààS. ùúé is a context.ùëò, ùëü, ùëôùõº are integers denoting a loop at
ùëò-th query, the number of iterations, and the number of queries after loop, respectively.
Output: List ùëôùõΩ of ùëü integers, where theùëñ-th (ùëñ = 1, . . . , ùëü) integer represents the number
of queries produced by theùëñ-th loop iteration.
1: procedure InferLoopBody( ùëÉ , ùúé, ùëò, ùëü, ùëôùõº)
2: ùëôùõΩ ‚ÜêEmpty list
3: for ùëñ ‚Üê1, . . . , ùëüdo
4: ùë†ùëñ ‚ÜêExecAndPick( ùëÉ , ùúé, ùëò,[ùëñ])
5: ùëôùëñ ‚ÜêLen(ùë†ùëñ) ‚àíùëò ‚àíùëôùõº
6: Append ùëôùëñ to ùëôùõΩ
7: end for
8: return ùëôùõΩ
9: end procedure
iterates over theùëò-th query. The procedure obtains the three list suffixes starting from
the (ùëò + 1)-th query (line 3). The procedure compares these three list suffixes regard-
ing their lengths and contents. Conceptually, it first assumes there would be a loop
that iterates over the specified query. The procedure calculates the number of queries
that would have been produced by only the first hypothetical loop iteration (line 5),
the number for only the second hypothetical iteration (line 6), and the number for
both the first and second iterations (line 7). The procedure then locates the queries
that would have been produced by these hypothetical loop iterations (lines 8,9) and by
any remaining queries in the program following the hypothetical loop (lines 10,11,12).
Figure 6-13 illustrates these calculations. Finally, theInferLoopExists procedure
checks if the lengths and contents for these hypothetical iterations are consistent
(line 13). The procedure invokesPerfectPrefix with variablesùõΩ1 and ùõΩ12, which
represent the queries that would have been produced by the first hypothetical loop
iteration and by the first two hypothetical loop iterations, respectively. ThePer-
fectPrefix procedure takes two lists of SQL queries. It returnstrue if and only if
(1) the first list is strictly shorter than the second list and (2) the queries in the first
list are exactly the same as the corresponding queries at the beginning of the second
list.
When a loop is found, the valueùëôùõº represents the number of queries in the ex-
ecution trace that occur after all loop iterations end. Because this value indicates
197
Figure 6-14: Illustration of Alg. 12
exactly where the loop ends, it enablesShear to distinguish the loop body and the
after-loop subprogram without ambiguity.
This procedure infers that a loop exists if and only if the hypothetical loop is
consistent with the three (altered) executions. We show that it detects the potential
loop accurately (Section 6.3.3).
Probing and Validating the Loop Body Structure
When a loop has been inferred to be present,Shear invokes theInferLoopBody
procedure (Algorithm 12) to infer the structure of the loop body. In particular, infer-
ring the loop body structure requires inferring the boundaries for each loop iteration
in the execution traces.
InferLoopBody. The InferLoopBody procedure takes a program, a context
ùúé, and three integersùëò, ùëü, ùëôùõº. Shear invokes this procedure only when it has inferred
that a loop iterates over theùëü rows retrieved by theùëò-th query in the trace from
executing the program withùúé. Because loops in theShear DSL iterate over each
row retrieved by the query (Section 6.2.1), the loop hasùëü iterations each accessing
one row from the ùëò-th query. The integer ùëôùõº is a result from InferLoopExists
(Algorithm 11) and equals the number of queries in the trace that are produced by
the subprogram that follows the detected loop.
Theprocedure InferLoopBody performsspeculativemanipulationandlocation-
198
based change-set validation to infer the length of each loop iteration in the trace.
Specifically, the procedure invokesExecAndPick for ùëü times. 2 Each invocation
executes the program with contextùúé, but altered so that theùëò-th query retrieves
only one row each time. Each such execution produces a list of (altered) SQL queries.
In each list, the first(ùëò ‚àí1) queries are unaltered, while the queries after theùëò-th
query are altered. These suffix queries correspond to the queries that would have
been produced by one iteration of the loop, followed byùëôùõº queries that are produced
by the subprogram inùëÉ after the loop. Figure 6-14 illustrates these calculations.
The procedure calculates the lengths of each loop iteration, then returns all of
these lengths as a listùëôùõΩ. Using this list of lengths, it is straightforward to divide
the unaltered execution trace into segments that correspond to the individual loop
iterations.
Putting it All Together
We present howShear analyzes any execution trace of the program to infer all of
the executed loop structures.
InferLoops. Algorithm 13 starts with anunaltered trace from executing the pro-
gram. For each query in the trace, it invokesInferLoopExists (Algorithm 11)
to infer if a loop iterates over the query. If a loop is inferred to exist,InferLoops
invokesInferLoopBody (Algorithm 12) to identify loop iteration boundaries in the
trace. Both of these procedures leverageShear‚Äôs proxy to perform speculative ma-
nipulation. The InferLoops procedure finally invokesBuildLLTree to construct
a tree that represents the structure of all loops inferred.
BuildLLTree. The BuildLLTree procedure takes a list of query-result pairsùëí,
along with a listùêø of all loops inferred inùëí. When there areùëö inferred loops, theùëó-th
loop iterates over theùëòùëó-th query with iteration lengthsùëôùõΩùëó . These lengths indicate
the location of the queries inùëí that are generated by each loop. When there are no
2A straightforward optimization is to avoid repeatedly executing the program with the same
context and alterations.
199
Algorithm 13Infer all loops
Input: ùëÉ is the executable ofùëÉ ‚ààS. ùúé is a context. ùëí is the list of query-result pairs
obtained from executingùëÉ with ùúé.
Output: Loop layout tree constructed fromùëí.
1: procedure InferLoops( ùëÉ , ùúé, ùëí)
2: ùêø ‚ÜêEmpty list
3: (ùëÑ1, ùëü1) , . . . ,(ùëÑùëõ, ùëüùëõ) ‚Üêùëí
4: for ùëò = 1, . . . , ùëõdo
5: if ùëüùëò < 2 then continue end if
6: ‚ü®ùëì, ùëôùõº‚ü©‚Üê InferLoopExists( ùëÉ , ùúé, ùëò)
7: if notùëì then continue end if
8: ùëôùõΩ ‚ÜêInferLoopBody( ùëÉ , ùúé, ùëò, ùëüùëò, ùëôùõº)
9: Append ‚ü®ùëò, ùëôùõΩ‚ü©to ùêø
10: end for
11: return BuildLLTree(ùëí, ùêø)
12: end procedure
nested loops, the queries generated by different loops do not overlap. On the other
hand, when there are nested loops, the queries generated by an inner loop are a subset
of the queries generated by the outer loop. The procedure constructs a loop layout
tree that represents the structure of all loops inferred inùëí. The procedure builds
subtrees bottom-up, first building the subtrees for the last and innermost loops.
Programs in theShear DSL have the following property: When a loop iterates
over theùëò-th query and whenShear deletes the database traffic from theùëò-th query,
the altered execution traces are the same as the original unaltered trace for all of
the queries that do not belong to this loop. Any such altered trace differs from
the unaltered trace only by lacking the queries that belong to certain iterations of
this loop. As a result, theInferLoops procedure is able to precisely identify the
structures of all loops that iterated at least twice (see Section 6.4.1) in any unaltered
trace. These algorithms work well for programs that may contain multiple loops,
nested or otherwise.
6.3.3 Soundness of the Loop Inference Algorithm
We first outline a soundness proof for the loop inference algorithm and then discuss
the intuition.
200
Definition 6.3.1.For programùëÉ ‚ààProg and contextùúé ‚ààContext, ùúé[‚Ü¶‚Üí:ùëò ùëÉ] denotes
the context after evaluatingùëÉ inùúé for ùëò queries. Lenexec(ùëÉ, ùúé) denotes the length of
thetracefromevaluating ùëÉ inùúé, thatis,Lenexec(ùëÉ, ùúé) = Len(ùëí) whereùúé ‚ä¢ùëÉ ‚áìexec ùëí.
Definition 6.3.2.For programùëÉ ‚ààProg and list of query-result pairsùëí, ùëÉ ‚àíùëí = ùëÉ‚Ä≤
denotes the remaining subprogram after consumingùëÉ with ùëí.
Definition 6.3.3.For programùëÉ ‚ààProg and contextùúé ‚ààContext, a loop iterates
over the ùëò-th query forùëüùëò times if the following hold for someùëÉ1, ùëÉ2 ‚ààProg: ùúé ‚ä¢
ùëÉ ‚áìexec (ùëÑ1, ùëü1) , . . . ,(ùëÑùëõ, ùëüùëõ), 1 ‚â§ùëò ‚â§ùëõ, and ùëÉ ‚àí(ùëÑ1, ùëü1) , . . . ,(ùëÑùëò‚àí1, ùëüùëò‚àí1) =
for ùëÑùëò do ùëÉ1; ùëÉ2. In this case, ùúé ‚ä¢ùëò: ùëÉ ‚áìbefore ùëí denotes the list of query-result
pairs ùëí produced by the subprogram before the loop.ùúé ‚ä¢ùëò: ùëÉ ‚áìùëñ
iter ùëíùëñ denotes the
list of query-result pairsùëíùëñ obtained from evaluating theùëñ-th iteration of the loop
(ùëñ = 1, . . . , ùëüùëò). ùúé ‚ä¢ùëò: ùëÉ ‚áìafter ùëí denotes the list of query-result pairsùëí produced by
the subprogram after the loop. Œõ(ùëÉ, ùúé, ùëò) = [ ùëí1, . . . , ùëíùëüùëò] denotes the list of lists of
query-result pairs produced by each of theùëüùëò loop iterations. When no loops iterate
over theùëò-th query,Œõ(ùëÉ, ùúé, ùëò) = NotLoop.
Definition 6.3.4.For programùëÉ ‚ààProg, contextùúé ‚ààContext, and integerùëò, ùëÉ[ùëò]ùúé
denotes theùëò-th query evaluated when executingùëÉ in ùúé.
Definition 6.3.5.For programùëÉ ‚ààProg, context ùúé ‚ààContext, integer ùëò where a
loop iterates over theùëò-th query, and list of integersùúå1, . . . , ùúåùëö, ùúé ‚ä¢ùëò: ùëÉ ‚áìùúå1,...,ùúåùëö
alter
ùëí denotes the list of query-result pairs ùëí produced by an altered evaluation of ùëÉ
in ùúé where the loop that iterates over theùëò-th query performs only the iterations
ùúå1, . . . , ùúåùëö.
Proposition 6.3.6. For program ùëÉ ‚ààS, context ùúé ‚ààContext, and integer ùëò, if
Œõ(ùëÉ, ùúé, ùëò) = [ùëí1, . . . , ùëíùëü], ùúé ‚ä¢ùëò: ùëÉ ‚áìNil
alter (ùëÑ1, ùëü1) , . . . ,(ùëÑùëõ, ùëüùëõ), andExecAndPick( ùëÉ , ùúé, ùëò,[]) =
[ùëû1, . . . , ùëûùëõ‚Ä≤ ], then we haveùëõ = ùëõ‚Ä≤ and ùëûùëñ corresponds toùëÑùëñ for allùëñ = 1, . . . , ùëõ.
Proposition 6.3.7.For programùëÉ ‚ààS, contextùúé ‚ààContext, integerùëò, and list of
distinct integersùúå1, . . . , ùúåùëö (ùëö >0), ifŒõ(ùëÉ, ùúé, ùëò) = [ùëí1, . . . , ùëíùëü], 1 ‚â§ùúå1 < . . . < ùúåùëö ‚â§
ùëü, ùúé ‚ä¢ùëò: ùëÉ ‚áìùúå1,...,ùúåùëö
alter (ùëÑ1, ùëü1) , . . . ,(ùëÑùëõ, ùëüùëõ), andExecAndPick( ùëÉ , ùúé, ùëò,[ùúå1, . . . , ùúåùëö])
= [ùëû1, . . . , ùëûùëõ‚Ä≤ ], then we haveùëõ = ùëõ‚Ä≤ and ùëûùëñ corresponds toùëÑùëñ for allùëñ = 1, . . . , ùëõ.
201
Theorem 8.For any programùëÉ ‚ààS, contextùúé ‚ààContext, and integerùëò, if we have
ùúé ‚ä¢ùëÉ ‚áìexec (ùëÑ1, ùëü1) , . . . ,(ùëÑùëõ, ùëüùëõ), 1 ‚â§ùëò ‚â§ùëõ, ùëüùëò ‚â•2, andŒõ(ùëÉ, ùúé, ùëò) = [ùëí1, . . . , ùëíùëüùëò],
then we haveInferLoopExists( ùëÉ , ùúé, ùëò) = ‚ü®true, Len(ùëí‚Ä≤)‚ü©where ùúé ‚ä¢ùëò: ùëÉ ‚áìafter ùëí‚Ä≤.
Proof Sketch.By induction onùëò and the derivation of loop body.
Theorem 9.For any programùëÉ ‚ààS, context ùúé ‚ààContext, and integerùëò, if ùúé ‚ä¢
ùëÉ ‚áìexec (ùëÑ1, ùëü1) , . . . ,(ùëÑùëõ, ùëüùëõ), 1 ‚â§ùëò ‚â§ùëõ, ùëüùëò ‚â•2, andŒõ(ùëÉ, ùúé, ùëò) = NotLoop, then
InferLoopExists( ùëÉ , ùúé, ùëò) = ‚ü®false, Nil‚ü©.
Proof Sketch.The proof performs a case analysis of whether a subprogramùëÉ‚Ä≤ (see
below) references ùëÑùëò and, if so, where is the first reference. HereùëÉ‚Ä≤ satisfies ùëÉ ‚àí
(ùëÑ1, ùëü1) , . . . ,(ùëÑùëò‚àí1, ùëüùëò‚àí1) = ùëÉ‚Ä≤.
Theorem 10. For any program ùëÉ ‚àà S, context ùúé ‚àà Context, and integer ùëò, if
Œõ(ùëÉ, ùúé, ùëò) = [ùëí1, . . . , ùëíùëü] andùúé ‚ä¢ùëò: ùëÉ ‚áìafter ùëí‚Ä≤, thenInferLoopBody( ùëÉ , ùúé, ùëò, ùëü,Len(ùëí‚Ä≤)) =
[Len(ùëí1), . . . ,Len(ùëíùëü)].
Theorem 11.For any programùëÉ ‚ààS and context ùúé ‚ààContext, if ùúé ‚ä¢ùëÉ ‚áìexec ùëí
and ùúé ‚ä¢ùëÉ ‚áìloops ùëô, thenInferLoops( ùëÉ , ùúé, ùëí) = ùëô.
These results indicate thatShear is guaranteed to infer loops precisely and return
the correct loop layout trees for any program in the DSL. The algorithm works well
with any context for (and any initial execution of) the program, regardless of whether
the program contains repetitive queries or not. Loop inference is based primarily on
how the program behavior changes when theShear proxy removes certain iterations
of a hypothetical loop. The loop body boundaries are determined by how the trace
changes when the proxy removes all but one loop iteration.
The most important parts of the proof are Theorem 8 and Theorem 9.Shear
needs only several manipulated executions here becauseShear works with loops that
iterate over collections of rows and whose iterations each operates on one individual
row (Section 6.2.1). Intuitively, the loop body can be expressed equivalently as a
function that depends only on (1) the one row iterated over by the current loop
iteration and (2) the context preceding the loop. WhenShear probes an execution
point that contains a loop, the resulting altered traces have an unambiguous way to
202
divide into segments that correspond to the database interactions produced before
the loop, produced by each loop iteration, and produced after the loop (Figure 6-13).
The segments before and after the loop will be the same across all three altered traces.
The segments produced by the loop body in the third altered trace (consisting of two
iterations) will be the same as the concatenation of the segment produced by the
loop body in the first altered trace (consisting of the first iteration) and the segment
produced by the loop body in the second altered trace (consisting of the second
iteration). Conversely, whenShear probes execution points that are not loops, the
resulting altered traces will fail the change-set validations. Such feedback enables
Shear to infer loops correctly.
6.4 Modular Constructive Inference of Full Program
Structure
Shear incorporates its loop inference algorithm into a prior technique [135] for the
inference and regeneration of database-backed programs (Section 6.2). With specu-
lative manipulation,Shear brings in the capability to infer sophisticated loop and
repetitive structures.
6.4.1 Modular Inference of Program Constructs
A basic principle in bothShear‚Äôs and prior work‚Äôs full program inference algorithms
is, at each step, to correctly and unambiguously infer a construct in the target pro-
gram. Technically, this modular construction is performed by expanding a nonter-
minal symbol in a sentential form in the DSL, that is, a partially expanded abstract
syntax tree (AST). This principle enables the algorithms to efficiently infer the pro-
gram structure and to detect when they have obtained a complete program, even
when working with infinite program search spaces.
To preserve this principle in the absence of the ability to alter the program ex-
ecutions, prior work imposes restrictions on the DSL that it can infer. In contrast,
203
Shear preserves this principle while significantly expanding the range of programs
that it can infer. The reason for this capability is that, conceptually, speculative
manipulation enables Shear to break dependencies that otherwise exist across dif-
ferent database queries that retrieve overlapping data. We consider this capability as
a fundamental strength ofShear.
Preliminaries: Inference Algorithm
We first summarize the algorithm in prior work that infers programs that consist
mainly of sequences and conditionals, with limited loops [135]. The inference algo-
rithm uses an SMT solver to generate useful inputs and database values with which to
execute the original program. As the algorithm executes the program, it observes the
program behavior in terms of the database interactions and the outputs. Based on
this observation, the algorithm updates a hypothesis of the inferred program structure
as a partially expanded AST. If the updated hypothesis still contains uncertainty, the
algorithm resolves this uncertainty by using the SMT solver again to generate new
inputs and database values that distinguish different hypotheses. The algorithm re-
cursively expands nonterminal symbols in the inferred program‚Äôs AST.
To facilitate discussion, we follow the naming convention in prior work and reuse
several helper procedures for program execution and solver invocation.
Infer. The entry point to the inference algorithm. It takes an executable ùëÉ
and configures an initial context ùúé where all database tables are empty and the
input parameters are distinct. It invokes GetTrace on ùëÉ to obtain an initial
annotatedtrace ùë°. Thistrace ùë° isusedtoinvoke InferProg, whichinferstheprogram
recursively.
InferProg. This procedure infers programs in theShear DSL that may con-
tain sophisticated loop and repetitive structures, including nested loops and after-loop
subprograms. This procedure recursively explores all relevant paths through a hypo-
thetical DSL program and resolves Prog nonterminals as they are encountered. The
204
procedure takes as parameters the executableùëÉ and an annotated trace. To resolve
a Prog nonterminal,Shear examines three annotated tracesùë°0, ùë°1, andùë°2. In the
executions that generatedùë°0, ùë°1, andùë°2, ùëÑ retrieves zero rows, at least one row, and at
least two rows, respectively.Shear encodes these requirements into path constraints
by invokingMakePathConstraint. Shear then obtains the satisfying traces (if
they exist) by invokingSolveAndGetTrace. These traces are then used to expand
the Prog symbol into one of four statements:ùúñ, Seq, If, or For.
GetTrace. This procedure executes the program, collects a trace, detects loops
by invokingInferLoops, and returns an annotated trace that satisfies a path con-
straint.
MakePathConstraint. This procedure takes a trace prefixùë†1, a queryùëÑ, an
integer ùëñ, and two lists of boolean flagsùëë and ùëé. The procedure constructs a path
constraint, ùëäùëñ, which specifies that the program should execute down the same path
as ùë†1, then performùëÑ and retrieveùëñ rows.
SolveAndGetTrace. This procedure takes an executableùëÉ and a path con-
straint ùëä. The procedure solves for a contextùúé that enables ùëÉ to produce a trace
ùë° that satisfies ùëä. If satisfiable, the procedure invokesGetTrace to execute the
program and obtain a satisfying trace.
Modular Construction of Loops Newly Inferred
Thewiderrangeofcomputationscapturedbythe Shear DSLgivesrisetochallenging
loop-related ambiguities that go beyond the scope of prior work (Section 7.1). We
briefly describe howShear reasons about potential For statements as a part of the
InferProg procedure and present more detail in the supplementary material.
Shear invokes InferLoops with the unaltered trace ùë°2 to infer whether the
execution point ùëÑ contains a loop. (1) If InferLoops infers that the execution
point ùëÑ does not have loops,Shear then proceeds to infer whetherùëÑ was generated
by an If statement or a Seq statement. This scenario is handled similarly as in prior
205
(a) Unaltered trace
 (b) Altered trace
Figure 6-15: Infer the boundaries of the only iteration
work. (2) On the other hand, if InferLoops infers that a loop iterates over the
rows retrieved byùëÑ, Shear updates its hypothesis to represent thatùëÑ was generated
by a For statement. In this case, theInferProg procedure will recursively infer the
subprograms inside the For statement. Before entering the recursion, however, it first
obtains two additional annotated traces. The traceùë°iter is an annotated trace whose
query ùëÑ retrieves at least two rows and whose suffix is generated by the loop body.
The traceùë°after is an annotated trace whose suffix is generated not by the loop body,
but by the after-loop subprogram. The InferProg procedure then uses ùë°iter and
ùë°after to recursively infer the loop-body subprogram and the after-loop subprogram,
respectively. We note that most of the fine-grained information collected during this
process is made possible by speculative manipulation.
Modular Inference of Loops that Previously Iterated Only Once
A complication is when a loop iterated only once during an execution of the program.
This complication arises from the ability of theShear DSL to capture programs
whose loops are not the last statements. These programs may have statements after
loops and even multiple consecutive loops, which are important computations that
go beyond the scope of prior work.
The complications are as follows. When a loop iterated only once, theInfer-
Loops procedure does not immediately determine where the (only) loop iteration
ends in the provided list of query-result pairs. The resulting loop layout tree there-
206
fore does not characterize this loop. When Shear traverses this tree to generate
annotated traces, at least one resulting trace contains both the queries generated by
the loop body (which iterated only once) and the queries generated after the loop.
These traces, if untreated, would cause theInferProg procedure‚Äôs recursive steps
to diverge from the structure of the hypothetical program‚Äôs AST.
Shear solves these complications by constructing two new traces based on the
previous trace where the loop iterated only once.Shear performs speculative ma-
nipulation to identify the boundary of the (only one) loop iteration in the trace.
Specifically,Shear first matches a traceùë° against the known Prog nonterminals that
have already been inferred. If a queryùëÑ is known to be generated by a For statement
but retrieved only one row inùë°, then the corresponding loop iterated only once. In
this case,Shear invokesExecAndPick with an empty listùúå. In the altered execu-
tion, the queryùëÑ is altered to retrieve zero rows. The corresponding loop iterates for
zero times and continues execution after the loop. The resulting traceùë°after contains
only the after-loop queries, without any loop-body queries. Next,Shear uses ùë°after to
locate the boundary of the loop body inùë° and discards all of the subsequent queries.
The resulting traceùë°iter contains only the loop-body queries, without any after-loop
queries. Figure 6-15 illustrates these calculations.
This way, even though the loop iterated only once in the original traceùë°, Shear
is able to update its hypothesis with the correct loop structure. Shear does so
by discarding ùë° and replacing it with two new tracesùë°iter and ùë°after that correspond
correctly to the loop body and the after-loop subprogram, respectively.
6.4.2 Soundness of the Full Program Inference Algorithm
The soundness of this algorithm builds on our key results in Section 6.3.3.
Theorem 12.For any programùëÉ ‚ààS, Infer( ùëÉ ) and ùëÉ are identical except for
the use of different but equivalent origin locations.
Proof Sketch.The proof is by induction on the productions ofùëÉ. Because the regen-
eration algorithm extends from prior work (Section 6.4.1), our general proof structure
207
is similar to that of prior work [138]. Our main modifications are (1) replacing the
loop detection theorem in prior work with our Theorem 11 and (2) adding a branch to
the structural induction proof ofInferProg to account for the second subprogram
in For statements in our more expressive DSL.
208
Chapter 7
Experimental Evaluation ofShear
We evaluate our loop inference technique with the following research questions:
‚Ä¢ RQ1: AbilitytoInferandRegenerateBenchmarkPrograms. Howdoes
Shear compare with existing techniques in the ability to infer applications that
access databases?
We usedShear to infer the commands in several open-source database-backed
applications. Compared to existing techniques,Shear infers a wider range of
loop and repetitive structures (Section 7.1).
‚Ä¢ RQ2: Scalability. How does our technique scale with more complex loop
structures?
Our results indicate thatShear scales well for most dimensions of program
complexity. The only dimension for which Shear does not scale well is the
number of layers of nested loops (Section 7.2).
‚Ä¢ RQ3: SpeculativeManipulationVersusEnumerativeSearch. Howdoes
our technique compare with enumerative search?
In our experiments, theShear inference times grow asymptotically slower than
the search space sizes do with most dimensions of program complexity. The only
dimension along whichShear is asymptotically slower is the number of loop
iterations (Section 7.3).
209
We performed experiments on Ubuntu 16.04 virtual machines with 6 cores and 4
GB memory. The host machine uses a processor with 6 cores (2.9 GHz Intel Core i9)
and has 32 GB 2400 MHz DDR4 memory. OurShear implementation uses Python
3.7.9 (PyPy 7.3.3) and Z3 4.6.0.
7.1 RQ1: Ability to Infer and Regenerate Bench-
mark Programs
We evaluateShear on a set of benchmark applications and a synthetic test suite.
Each application has several commands;Shear infers one command at a time. Each
command takes input parameters, performs SQL queries accordingly, and outputs
some of the retrieved data.
7.1.1 Benchmark Applications
Our benchmark applications include:
‚Ä¢ RailsCollab Project Manager: RailsCollab [8] is an open-source project
management and collaboration tool, built with Ruby on Rails, with over 250
stars on GitHub. The source code contains 11944 lines of Ruby, HTML, CSS,
and JavaScript. RailsCollab maintains multiple task lists, tasks, milestones,
time records, and messages. RailsCollab retrieves data from 24 relevant tables
with 270 columns. Its commands enable users to navigate these contents.
‚Ä¢ Kanban Task Manager: Kanban [11] is an open-source task management
system, built with Ruby on Rails, with over 600 stars and 200 forks on GitHub.
The source code contains 1653 lines of JavaScript, SASS, Ruby, and HTML.
Kanbanmaintainsboards. Eachboardmaycontainmultiplelists. Eachlistmay
contain multiple cards, each of which may have comments. Kanban retrieves
data from 4 relevant tables with 42 columns. Its commands enable users to
navigate boards, lists, cards, and comments.
210
‚Ä¢ Todo Task Manager: Todo [9] is an open-source task-tracking tool, built
with Ruby on Rails, with over 100 stars and 180 forks on GitHub. The source
code contains 1340 lines of HTML, JavaScript, Ruby, CSS, and SASS. Todo
maintains multiple lists. Each list may contain multiple tasks. Todo retrieves
data from 2 relevant tables with 10 columns. Its commands enable users to
navigate lists and tasks.
‚Ä¢ FulcrumTaskManager: ThesameFulcrum[3]applicationasinSection5.1.1.
‚Ä¢ Kandan Chat Room:The same Kandan [5] application as in Section 5.1.1.
‚Ä¢ EnkiBloggingApplication: ThesameEnki[2]applicationasinSection5.1.1.
‚Ä¢ Blog: The same Blog [4] application as in Section 5.1.1.
‚Ä¢ Student Registration:The same Student [7] application as in Section 5.1.1.
‚Ä¢ Synthetic: A set of synthetic Python programs with repetitions, nested loops,
and consecutive loops designed to challenge other loop inference techniques.
Five of these applications ‚Äì RailsCollab, Kanban, Fulcrum, Kandan, and Enki
‚Äì are studied in a recent survey [173]. We identified the Todo Task Manager from
popular Ruby on Rails projects on GitHub. Five of the applications ‚Äì Fulcrum,
Kandan, Enki, Blog, and Student ‚Äì were used in the evaluation ofKonure. A copy
of the source code for the benchmark applications is available at [10]. The synthetic
test suite highlights the capability ofShear. The source code for the synthetic test
suite is available in Appendix C.
Characteristics of Loop and Repetition Structures. Our benchmarks have
structures as follows.
‚Ä¢ Non-Loop Repetitive Queries:Codes ‚ÄúùëÖ‚Äù and ‚Äúùëü‚Äù denote that a command
contains non-loop repetitive queries that violate the heuristic assumptions in
other loop inference systems. Specifically, the code ‚ÄúùëÖ‚Äù denotes that the com-
mand may generate an execution trace that contains non-adjacent repetitions.
The code ‚Äúùëü‚Äù denotes generating adjacent repetitions.
211
‚Ä¢ Control Structures in the Loop Body:The code ‚Äúùê∂‚Äù denotes that a com-
mand has a loop whose loop body contains control structures such as conditional
statements or loops.
‚Ä¢ Nested Loops: The code ‚ÄúùëÅùëñ‚Äù denotes that a command containsùëñ layers of
nested loops when the command‚Äôs externally observable behavior is expressed
in theShear DSL.
‚Ä¢ After-Loop Subprograms: The code ‚Äúùê¥‚Äù denotes that a command contains
after-loop subprograms. The code ‚Äúùê¥ùëñ‚Äù denotes that the command containsùëñ
loops, one after the other.
Commands with code ‚ÄúùëÖ‚Äù are out of the scope of Konure, Kobayashi‚Äôs algo-
rithm [99], and WebRobot [64]. Commands with code ‚Äúùëü‚Äù are out of the scope of
Konure, DaViS [110], Kobayashi‚Äôs algorithm, and WebRobot. Commands with
code ‚Äúùê∂‚Äù are out of the scope of DaViS, Kobayashi‚Äôs algorithm, and WebRobot.
Commands with code ‚ÄúùëÅùëñ‚Äù are out of the scope ofKonure, DaViS, and Kobayashi‚Äôs
algorithm. Commands with code ‚Äúùê¥‚Äù or ‚Äúùê¥ùëñ‚Äù are out of the scope ofKonure.
7.1.2 Results
Experimental Results for Loop Inference.Table 7.1 and Table 7.2 present the
resultsofapplying Shear tothebenchmarkcommands, alongwithacomparisonwith
other loop inference techniques. Each row presents a command. A row is shaded if the
corresponding command does not have any loop or repetitive structures as expressed
in the Shear DSL. The first column (Command) presents the command name.
The next (Time) presents the wall-clock inference time. The next (LoC) presents
the number of lines in the regenerated Python code. The next three (Q, If, andFor)
present the numbers of SQL, If, and For statements as expressed in the DSL. The next
(Struct) presents the characteristics of loop and repetitive structures outlined above.
Thenexttwo( SandKn)representwhetherthecommandissupportedby Shear and
Konure, respectively. The next two (D and Kb) represent whether the execution
212
Table 7.1:Shear‚Äôs performance on inferring and regenerating benchmark commands
Command Time LoC Q If For Struct S Kn D Kb WR
get_projects_id_messages 7203.3s 114 34 9 3 ùëÖ, ùê∂, ùê¥2  √ó √ó √ó √ó
get_projects_id_messages_id 4326.4s 69 21 5 0 ùëü  √ó √ó √ó √ó
get_projects_id_messages_display_list 7461.4s 115 35 9 3 ùëÖ, ùê∂, ùê¥2  √ó √ó √ó √ó
get_projects_id_times (fixed 500 error) 8739.7s 114 38 11 1 ùëÖ, ùê∂, ùê¥  √ó √ó √ó √ó
get_projects_id_times_id 3846.7s 147 55 15 0 ùëÖ  √ó  √ó √ó
get_projects_id_milestones_id 5544.6s 93 25 6 2 ùëÖ, ùëü, ùê¥  √ó √ó √ó √ó
get_users_id (RailsCollab) (fixed 500 error) 960.3s 53 12 5 1     
get_api_lists 1557.2s 55 9 1 3 ùê∂, ùëÅ3  √ó √ó √ó √ó
get_api_lists_id 765.5s 54 9 2 2 ùê∂, ùëÅ2  √ó √ó √ó √ó
get_api_cards 780.3s 46 8 1 2 ùê∂, ùëÅ2  √ó √ó √ó √ó
get_api_cards_id 398.4s 45 8 2 1     
get_api_boards_id 1329.2s 64 10 2 3 ùê∂, ùëÅ3, ùê¥  √ó √ó √ó √ó
get_home (Todo) 529.3s 20 5 1 1 ùê∂   √ó √ó √ó
get_lists_id_tasks 565.9s 17 6 1 1 ùê∂, ùê¥  √ó √ó √ó √ó
get_lists_id_tasks (fixed 404 error) 742.2s 20 6 1 1 ùê∂, ùê¥  √ó √ó √ó √ó
get_channels 3762.2s 53 16 4 2 ùê∂   √ó √ó √ó
get_home (Enki) 757.2s 26 9 1 1 ùê¥  √ó   
get_archives 659.4s 21 6 1 1 ùê∂, ùê¥  √ó √ó √ó √ó
get_admin_posts 397.5s 17 3 1 1     
get_admin (trimmed) 773.9s 21 7 0 2 ùê¥2  √ó   
liststudentcourses 171.1s 22 5 2 1     
repeat_2 82.0s 7 3 0 0 ùëü  √ó √ó √ó √ó
repeat_3 102.7s 8 4 0 0 ùëÖ, ùëü  √ó √ó √ó √ó
repeat_4 122.2s 9 5 0 0 ùëÖ, ùëü  √ó √ó √ó √ó
repeat_5 143.0s 10 6 0 0 ùëÖ, ùëü  √ó √ó √ó √ó
213
Table 7.2:Shear‚Äôs performance on inferring and regenerating benchmark commands (continued)
Command Time LoC Q If For Struct S Kn D Kb WR
nest393.8s 15 3 0 2ùê∂, ùëÅ2√ó √ó √ó √ó
after_2220.8s 15 4 0 2ùëÖ, ùê¥2√ó√ó √ó
after_3328.7s 20 6 0 3ùëÖ, ùê¥3√ó√ó √ó
after_4441.1s 25 8 0 4ùëÖ, ùê¥4√ó√ó √ó
after_5549.4s 30 10 0 5ùëÖ, ùê¥5√ó√ó √ó
example(Section 6.1)293.3s 22 6 1 1ùëÖ, ùê¥√ó√ó √ó
get_projects295.3s26720‚Äì‚Äì‚Äì
get_companies_id257.3s28620‚Äì‚Äì‚Äì
get_api_users_current41.3s9100‚Äì‚Äì‚Äì
get_api_users_id39.0s9100‚Äì‚Äì‚Äì
get_home(Fulcrum)165.2s21510‚Äì‚Äì‚Äì
get_projects165.4s21510‚Äì‚Äì‚Äì
get_projects_id584.1s25820‚Äì‚Äì‚Äì
get_projects_id_stories366.3s31830‚Äì‚Äì‚Äì
get_projects_id_stories_id363.7s31930‚Äì‚Äì‚Äì
get_projects_id_stories_id_notes364.7s24930‚Äì‚Äì‚Äì
get_projects_id_stories_id_notes_id391.6s281040‚Äì‚Äì‚Äì
get_projects_id_users525.0s25820‚Äì‚Äì‚Äì
get_channels_id_activities1388.2s491660‚Äì‚Äì‚Äì
get_channels_id_activities_id844.3s251130‚Äì‚Äì‚Äì
get_me637.7s44830‚Äì‚Äì‚Äì
get_users1872.4s671130‚Äì‚Äì‚Äì
get_users_id(Kandan)678.7s44830‚Äì‚Äì‚Äì
get_admin_comments_id62.4s10100‚Äì‚Äì‚Äì
get_admin_pages220.7s13210‚Äì‚Äì‚Äì
get_admin_pages_id51.8s9100‚Äì‚Äì‚Äì
get_article_id92.1s15210‚Äì‚Äì‚Äì
get_articles60.8s8100‚Äì‚Äì‚Äì
214
traces produced by the command are compatible with DaViS and Kobayashi‚Äôs loop
inference algorithms [99], respectively. The next (WR) represents whether the loop
structures can be supported by an adaptation of the rewrite-based loop synthesis
algorithm in WebRobot. Symbols ‚Äú‚Äù and ‚Äú√ó‚Äù indicate that a command is in the
scope and out of the scope of a technique, respectively. Symbol ‚Äú‚Äì‚Äù indicates that a
command is not applicable for the comparison of loop inference techniques.
Compared to these four other techniques,Shear supports a substantially more
complex set of loop and repetitive structures. All 25 benchmark commands with
loops (whose ‚ÄúFor‚Äù column is nonzero) are supported byShear. In contrast, only 13
of these commands are supported by at least one of the four other techniques. All
6 benchmark commands without loops but contain repetitive queries (whose ‚ÄúFor‚Äù
column is zero) are supported byShear. In contrast, only one of these commands is
supported by at least one of the four other techniques. Overall, 25 benchmark com-
mands are out of the scope ofKonure, 18 commands are out of the scope of DaViS,
and 25 commands are out of the scope of both Kobayashi‚Äôs [99] and WebRobot‚Äôs [64]
algorithms. In contrast, all of these commands are supported byShear. We at-
tribute these differences toShear‚Äôs capability to precisely disambiguate loops with
speculative manipulation.
Experimental Results for Program Inference. We applied Shear to infer
and regenerate 53 commands in our benchmarks. These commands include 9 from
RailsCollab, 7 from Kanban, 3 from Todo, 8 from Fulcrum, 6 from Kandan, 7 from
Enki, 2 from Blog, 1 from Student, and 10 from Synthetic. Among these supported
commands, 25 (47%) are out of the scope ofKonure (Table 7.1 and Table 7.2).
The wall-clock inference times range between 39‚Äì8740 seconds (average 1197 sec-
onds). Among the 25 benchmark commands that are out of the scope ofKonure,
Shear‚Äôs inference times range between 82‚Äì8740 seconds (average 1909 seconds).
Amongthe28benchmarkcommandsthataresupportedbyboth Shear andKonure,
Shear‚Äôs inference times range between 39‚Äì3762 seconds (average 560 seconds). The
former commands are often larger and more complex than the latter.
215
We next compareShear and Konure on the 21 shared benchmark commands
that are used in the evaluation of both systems.1 The unaltered execution numbers
in Shear are slightly higher than the corresponding numbers reported inKonure.
We attribute this difference to the different uses of the solver when implementing
these two systems. The number of altered executions inShear range between 0‚Äì6.3
times (average 1.6 times) that of unaltered executions. We attribute this overhead to
Shear‚Äôs algorithm that infers a wider range of loop and repetitive structures.
The number of solver invocations in both systems are roughly in the same range.
Shear‚Äôs inference times are generally shorter thanKonure for commands that
required many solver invocations. We attribute this difference to the different uses
of the solver when implementing these two systems. Shear‚Äôs inference times are
generally longer than Konure for commands that required many executions. We
attribute this difference to the increased number of command executions byShear
for inferring more expressive loop and repetitive structures.
Experimental Results for Program Regeneration.For each benchmark com-
mand, Shear regenerates a Python program. We present all of the regenerated
programs in Appendix D. The regenerated programs have between 1‚Äì55 (average 9.8)
SQL queries, between 0‚Äì15 (average 2.3) If statements, between 0‚Äì5 (average 0.9)
For statements, between 0‚Äì50 (average 12.7) lines that generate output, and between
7‚Äì147 (average 36.0) total lines of code.
Wecomparedtheregeneratedprogramsforthesharedcommands. Foreachshared
command in Enki, Fulcrum, Kandan, and Student,Shear and Konure infer and
regenerate equivalent programs. For each command in Blog,Shear and Konure
infer and regenerate equivalent programs except for a minor difference in the scripts
for restarting and executing the application.
1Our benchmarks contain 7 commands that can be supported byKonure but were not used in
Konure‚Äôs evaluation.
216
Scope. Some of these benchmark applications implement read-only data-retrieval
commands2 that are out of the scope ofShear. Six such commands in RailsCollab
and two in Kandan retrieve files or folders. One in Kanban and one in Fulcrum
retrieves metadata such as session keys and history updates. Four in RailsCollab
and one in Kanban iterate over the rows retrieved by an earlier query that does not
immediately precede the first iteration of the loop body. One in RailsCollab contains
conditional statements that do not depend on whether the preceding query retrieves
empty or nonempty. The majority of the remaining data retrieval commands in
Enki and RailsCollab involve application-specific calculations such as concatenating
multiple input strings, checking whether a datetime is smaller than another, and
enumerating a set of activity type strings. Shear infers all of the data retrieval
commands in Todo, Blog, Student, and Synthetic.
7.1.3 Discussion
Compared to four other techniques,Shear supports a wider range of loop and repet-
itive structures that occur in real-world database-backed applications. When applied
on identical benchmarks that are supported by bothShear and Konure, the two
infer and regenerate equivalent results, with the main difference being thatShear
may execute the benchmarks more times. This overhead often becomes less noticeable
for larger programs, as the inference algorithm spends a larger portion of the time
interacting with the solver. Almost half of our benchmark commands contain loop
and repetitive structures that are supported by onlyShear but notKonure.
We attribute these improvements to the capability ofShear to perform specu-
lative manipulation. Intuitively, speculative manipulation enablesShear to elimi-
nate dependencies between constructs that access overlapping sets of database items,
which in turn enablesShear to more precisely control program behavior and obtain
fined-grained interactive feedback.Shear exploits this control to infer a larger and
2For a Ruby on Rails application, these commands correspond to the routes that handle HTTP
GET requests with anindex action, ashow action, or an action that displays the current user. We
count such routes only if their corresponding actions are implemented and access the database.
217
more expressive class of programs thanKonure while preserving the advantages of
the Konure inference algorithm, which proceeds by correctly and unambiguously
expanding one nonterminal at each step of the algorithm. This capability enables
Shear to eliminate many of the heuristic restrictions in prior work. It enables the
unambiguous inference of a wider range of computations that are out of the scope of
prior techniques. The four prior techniques all use repetition-based pattern match-
ing to infer loops from the execution traces of programs. Because there are often
multiple program structures that can generate the observed repetitions, these prior
techniques all resort to heuristics to deal with the ambiguity. They either limit the
loop and repetitive structures they can work with or simply pick one of the multiple
nonequivalent candidate program structures.
In particular, theShear DSL is more expressive thanKonure as follows. The
Konure DSL uses heuristics to impose a range of restrictions on the structure of
the program‚Äîfor example, it requires the (unchecked) property that any query that
follows a query in the DSL program that may retrieve multiple rows must not have
the same query skeleton as any following query. It also requires any loop to be the
last statement of the program, that is,Konure does not allow any other statements
to follow after a loop ends. And it does not support nested loops. Because theShear
DSL does not have these restrictions, it is much more expressive than theKonure
DSL: (1) The Shear DSL supports more general looping constructs, specifically
loop nests and intermixed sequences of sequential code, loops, and conditionals. In
contrast, theKonure DSL supports only a single loop at the end of the program with
no code after the loop. (2) TheShear DSL supports repeated queries. In contrast,
the Konure DSL imposes restrictions on repeated queries. These differences are
a result of Shear‚Äôs speculative manipulation, which enablesShear to infer more
benchmarks: 10 of our open-source commands have code after loops, 4 have nested
loops, and 6 have non-loop repetitions‚Äîall these commands are supported byShear
but notKonure. Shear infers all 31 commands (21 open-source and 10 synthetic)
that contain loops or repetitions, whileKonure infers only 6 of them.
218
for n_loops in range ( ùëô):
s = do_sql (" SELECT * FROM t1")
for row in s:
for n_body in range ( ùëè):
do_sql (" SELECT * FROM t0")
(a) withùëô consecutive loops, where each loop body hasùëè queries
do_sql (" SELECT * FROM t1")
for n_query in range ( ùëû):
do_sql (" SELECT * FROM t2")
(b) withùëû non-loop repetitive queries
def rec ( n_layer ):
if n_layer <= 0:
do_sql (" SELECT * FROM t0")
return
s = do_sql (" SELECT * FROM t1")
for row in s:
rec ( n_layer - 1)
rec (ùëõ)
(c) withùëõ layers of nested loops
Figure 7-1: Programs for testing scalability
7.2 RQ2: Scalability
We empirically evaluate the scalability ofShear‚Äôs loop inference algorithm along
seven dimensions of program complexity. These dimensions are: (a) the number of
consecutive loops in the program, (b) the number of iterations executed for a loop, (c)
the number of non-loop repetitive queries in the program, (d) the number of queries
in the body of a loop, (e) the number of non-loop queries that retrieve multiple rows
during execution, (f) the number of both consecutive loops and database rows, and
(g) the number of layers of nested loops. The dimension f is designed to simulate the
effects of applyingShear to infer full programs, because our database solver often
inserts more rows for longer program paths. By definition, the dimension f reflects
the combined effects of both dimensions a and b.
Independent Variables. For each dimension of program complexity, we developed
a set of synthetic Python programs (along with the associated input and database val-
219
ues) with various levels of complexity. Each program‚Äôs externally observable behavior
is expressible in theShear DSL. Specifically, we generated the synthetic programs
for dimension (a) from Figure 7-1a withùëü = 2, ùëè = 1, and varying values forùëô, (b)
from Figure 7-1a withùëô = 1, ùëè = 1, and varying values forùëü, (c) from Figure 7-1b
with ùëü = 8 and varying values forùëû, (d) from Figure 7-1a withùëü = 2, ùëô = 1, and
varying values forùëè, (e) from Figure 7-1a withùëü = 2, ùëè = 0, and varying values forùëô,
(f) from Figure 7-1a withùëè = 1 and varying values for bothùëü and ùëô (ùëü = ùëô), and (g)
from Figure 7-1c with varying values forùëõ. Here ùëü denotes the number of rows we
insert into the tablet1 in the database.
Note that for the complexity dimensions b and f, settingùëü = 1 means inserting
only one row into the tablet1, which causes the loop to iterate only once. Loops
that iterated only once are not identified by loop inference alone (Section 6.4.1).
Dependent Variables. For each dimension of complexity and value of the inde-
pendent variable, we executed the synthetic program with the associated input and
database values. We measured thewall-clock time for executing the program. This
execution produces an unaltered trace. We then used this unaltered trace (along with
the executable program) to invokeShear‚Äôs loop inference algorithm. We measured
the wall-clock time for inferring loopsin this trace.
7.2.1 Results
Figure 7-2 presents the scalability results forShear‚Äôs loop inference. Each subfigure
corresponds to a dimension of complexity. The horizontal axes represent the inde-
pendent variables. The vertical axes represent the dependent variables in numbers of
seconds.
The green circles represent program execution times. The program execution
time is positively correlated with the length of the unaltered execution trace. The
traces in our experiments contain between 0‚Äì48 queries (Figure 7-2a), 2‚Äì17 queries
(Figure 7-2b), 1‚Äì17 queries (Figure 7-2c), 3‚Äì33 queries (Figure 7-2d), 0‚Äì16 queries
(Figure 7-2e), 2‚Äì272 queries (Figure 7-2f), and 1‚Äì127 queries for 0‚Äì6 layers of nested
220
loops and 255‚Äì1023 queries for 7‚Äì9 layers (Figure 7-2g).
The blue triangles represent loop inference times. Shear correctly infers the
unique correct loop structures for all of these traces.
7.2.2 Discussion
In these experiments, the growths of the loop inference times are correlated mainly
with the number of altered program executions during loop inference. For the plotted
values, the loop inference times scale linearly with the number of loops (Figure 7-2a),
the number of loop iterations (Figure 7-2b), and the number of queries retrieving
multiple rows (Figure 7-2e). For the plotted values, the loop inference times remain
stable with various numbers of non-loop repetitions (Figure 7-2c) and numbers of
queries in the loop body (Figure 7-2d) and scale quadratically with the number of
both loops and database rows (Figure 7-2f). In theory, the asymptotic growths of the
loop inference times are also correlated with the times for executing the program and
the times for parsing the execution traces. These two time components both grow
linearly along dimensions a‚Äìe and quadratically along the dimension f. The loop
inference times grow exponentially with increasing layers of nested loops (Figure 7-
2g). We attribute this phenomenon to the exponential growth in the lengths of
execution traces for deeper nested loops. Overall,Shear‚Äôs loop inference algorithm
scales polynomially along the first six dimensions of program complexity.
7.3 RQ3: Speculative Manipulation Versus Enumer-
ative Search
We evaluate the asymptotic efficiency ofShear‚Äôs loop inference algorithm by con-
trasting the loop inference time against the size of the search space of candidate
program structures. We note that many program synthesis techniques are based on
enumerative search with pruning [14, 18, 32, 50, 69, 79, 93, 102, 103, 111, 112, 143,
144, 158, 162, 163, 175, 116].
221
(a) consecutive loops
 (b) loop iterations
(c) non-loop repetitions
 (d) queries in loop body
(e) queries with‚â•2 rows
 (f) size of prog. & DB
(g) nested loops
Figure 7-2: Time to infer loops in programs with various measures of complexity
222
(a) consecutive loops
 (b) loop iterations
(c) non-loop repetitions
 (d) queries in loop body
(e) queries with‚â•2 rows
 (f) size of prog. & DB
(g) nested loops
Figure 7-3: Number of candidate loop structures in programs with various measures
of complexity
223
Independent Variables. We conducted two experiments that calculate the search
space sizes. The first experiment uses the same set of independent variables as in
Section 7.2. The second experiment uses the maximum depth of programs as the
independent variable, where depth is defined as the maximum number of SQL queries
along any path in the program‚Äôs AST.
Dependent Variables. The first experiment uses the unaltered traces collected
from executing the synthetic programs for the various dimensions of complexity and
values of the independent variables. For each trace, we calculated thenumber of
candidate loop structuresthat may generate the trace. The second experiment is
based on theoretical calculation. For each maximum program depth, we calculated
the number of candidate AST program structuresunder this depth.
7.3.1 Results
Figure 7-3 presents the results for the first experiment. Each subfigure corresponds
to one dimension of program complexity. The horizontal axes represent the indepen-
dent variables. The vertical axes represent the sizes of the search space of candidate
loop structures given an unaltered trace. To evaluate the efficiency ofShear‚Äôs loop
inference algorithm, we compare the asymptotic growths of the search space sizes
against the loop inference times. For the plotted values, the search space sizes grow
at least exponentially with increasing numbers of consecutive loops (Figure 7-3a),
numbers of queries retrieving multiple rows (Figure 7-3e), and numbers of both loops
and database rows (Figure 7-3f). In contrast, theShear loop inference times grow
polynomially along these dimensions (Figure 7-2a, Figure 7-2e, and Figure 7-2f).
Compared to the loop inference times, the search space sizes also grow asymptoti-
cally faster with increasing numbers of non-loop repetitions (Figure 7-3c), numbers
of queries in the loop body (Figure 7-3d), and numbers of layers of nested loops
(Figure 7-3g). We attribute these differences to Shear‚Äôs ability to infer loops ef-
ficiently. The only dimension along which the search space sizes grow slower than
loop inference times is the number of loop iterations (Figure 7-3b). We attribute this
224
Figure 7-4: Log base 10 of the number of candidate AST structures in programs with
various maximum depths
difference to the increased number of program executions required forShear to infer
the boundaries for an increased number of loop iterations.
Figure 7-4 presents the results for the second experiment. The horizontal axis
represents the maximum depth of a program in theShear DSL. The vertical axis
represents the size of the search space of candidate AST structures. Because these
numbers are too large for our plotting software, we plot them after taking logarithm
with base 10. This search space grows double-exponentially with the maximum pro-
gram depth.
7.3.2 Discussion
Overall, theasymptoticperformanceof Shear‚Äôsloopinferencealgorithm(Figure7-2)
is very efficient compared to the search space of candidate loop structures (Figure 7-
3). We attribute this efficiency to the fact thatShear‚Äôs algorithm does not require
enumerative search‚Äîinstead, it is based on manipulating the program executions and
comparing the trace lengths. A na√Øve search space of candidate AST programs may
contain programs whose depths are less than or equal to the trace length, up to 272 in
our experiments. This search space is way beyond the plotting capability of Figure 7-
4 and infeasible to enumerate. In contrast, the Shear loop inference algorithm
terminates within half an hour on a laptop computer for all of these experiments
(Figure 7-2).
225
7.4 Conclusion
The need to infer loop constructs from observations of program executions has re-
peatedly arisen in a range of fields. We present a novel dynamic analysis technique
that automatically infers loop and repetitive structures from execution traces. The
algorithm strategically alters the program‚Äôs database traffic at precisely chosen exe-
cution points to elicit different behaviors, which differ depending on the structure of
the underlying program. Results from our implementation highlight the effectiveness
of our technique at eliminating many of the limitations present in other systems.
226
Chapter 8
Conclusion
Human society will continue to develop and rely on software. The goal of my re-
search is to improve software development by automating tasks that currently re-
quire substantial manual engineering effort, more specifically by providing a powerful
way for developers to express program functionality that adapts flexibly to a variety
of contexts. This thesis demonstrates that the program inference and regeneration
framework satisfies this goal.
We have demonstrated the feasibility of this framework by implementing it in
Konure and Shear. These systems take a gray-box active learning approach. They
treat an existing program as a gray box that consists of black-box components that
interact with each other, observing the behaviors of the black boxes, controlling the
environments in which they operate, inferring models of their core functionality, and
finally using the models to regenerate new implementations. The new implementa-
tions deliver the same core functionality but are potentially augmented or transformed
to operate successfully in different environments. Example use cases include generat-
ing correct-by-construction code augmented with checks that eliminate security vul-
nerabilities, automatically improving program comprehension and producing cleaner
code, and automatically extracting the human knowledge in software and retargeting
it to different languages and platforms.
We evaluate Konure and Shear by applying them to open source database-
backed applications. Our results indicate thatKonure and Shear work well with
227
applications whose core functionality is expressible in our DSLs, with data flow largely
visible in the database queries and control flow directly tied to the query results. Our
current techniques do not work well with applications whose core functionality is not
expressible in our DSLs. Some of these applications can be inferred and regenerated
after straightforward extensions to our current techniques. Others may require more
involved extensions or are out of the scope of our approach.
Because our approach was designed to work with a range of inferrable compu-
tations, each of our techniques is unsuitable for inferring and regenerating general-
purpose computations. To this end, our philosophy is to identify recurring patterns
‚Äî many such patterns exist in today‚Äôs software, which contains enormous amounts
of human effort ‚Äî and design domain-specific techniques that exploit these patterns.
In the future, software will serve even more critical tasks in human society. The
research presented in this thesis provides insights on how to reduce the fundamental
inefficiencies in how people work with software.
228
Appendix A
Code Regenerated byKonure
A.1 Regenerated Code for Fulcrum Task Manager
A.1.1 Command get_home
def get_home (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
if util . has_rows (s0):
s7 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
s8 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM ‚Äò
projects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s7 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s8 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
229
outputs . extend ( util . get_data (s8 , ‚Äô projects ‚Äô, ‚Äô start_date ‚Äô))
s9 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s7 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s9 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
s10 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM
‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid
‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s9 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s10 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s10 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s10 , ‚Äô projects ‚Äô, ‚Äô start_date ‚Äô)
)
else :
pass
return util . add_warnings ( outputs )
A.1.2 Command get_projects
def get_projects (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
if util . has_rows (s0):
s7 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
s8 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM ‚Äò
projects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
230
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s7 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s8 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äô projects ‚Äô, ‚Äô start_date ‚Äô))
s9 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s7 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s9 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
s10 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM
‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid
‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s9 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s10 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s10 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s10 , ‚Äô projects ‚Äô, ‚Äô start_date ‚Äô)
)
else :
pass
return util . add_warnings ( outputs )
A.1.3 Command get_projects_id
def get_projects_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s8 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
231
s9 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM ‚Äò
projects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s8 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s10 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s8 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s11 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM
‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äò
id ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò
projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :
x1 LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô
), ‚Äôx1 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s11 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s11 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
if util . has_rows ( s11 ):
s61 = util . do_sql (conn , " SELECT DISTINCT ‚Äòusers ‚Äò.* FROM
‚Äòusers ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòusers ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò project_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s11 ,
‚Äô projects ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s61 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s61 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s61 , ‚Äôusers ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s61 , ‚Äôusers ‚Äô, ‚Äô initials ‚Äô))
s62 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äò
projects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE
‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s62 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s62 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
else :
s12 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äò
232
projects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE
‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
else :
pass
return util . add_warnings ( outputs )
A.1.4 Command get_projects_id_stories
def get_projects_id_stories (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s8 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s9 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM ‚Äò
projects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s8 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s10 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s8 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s11 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM
‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äò
id ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò
projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :
x1 LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô
), ‚Äôx1 ‚Äô: inputs [1]})
if util . has_rows ( s11 ):
233
s46 = util . do_sql (conn , " SELECT ‚Äòstories ‚Äò.* FROM ‚Äò
stories ‚Äò WHERE ‚Äòstories ‚Äò. ‚Äò project_id ‚Äò IN (: x0)", {‚Äô
x0 ‚Äô: util . get_one_data (s11 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s46 , ‚Äô stories ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s46 , ‚Äô stories ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s46 , ‚Äô stories ‚Äô, ‚Äô
description ‚Äô))
outputs . extend ( util . get_data (s46 , ‚Äô stories ‚Äô, ‚Äô estimate ‚Äô
))
outputs . extend ( util . get_data (s46 , ‚Äô stories ‚Äô, ‚Äô
requested_by_id ‚Äô))
outputs . extend ( util . get_data (s46 , ‚Äô stories ‚Äô, ‚Äô
owned_by_id ‚Äô))
outputs . extend ( util . get_data (s46 , ‚Äô stories ‚Äô, ‚Äô
project_id ‚Äô))
if util . has_rows ( s46 ):
s62 = util . do_sql (conn , " SELECT ‚Äònotes ‚Äò.* FROM ‚Äò
notes ‚Äò WHERE ‚Äònotes ‚Äò. ‚Äò story_id ‚Äò IN (: x0)", {‚Äôx0
‚Äô: util . get_one_data (s46 , ‚Äô stories ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s62 , ‚Äônotes ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s62 , ‚Äônotes ‚Äô, ‚Äônote ‚Äô))
outputs . extend ( util . get_data (s62 , ‚Äônotes ‚Äô, ‚Äô user_id
‚Äô))
outputs . extend ( util . get_data (s62 , ‚Äônotes ‚Äô, ‚Äô
story_id ‚Äô))
else :
pass
else :
s12 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äò
projects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE
‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
else :
pass
return util . add_warnings ( outputs )
234
A.1.5 Command get_projects_id_stories_id
def get_projects_id_stories_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s8 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s9 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM ‚Äò
projects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s8 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s10 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s8 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s11 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM
‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äò
id ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò
projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :
x1 LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô
), ‚Äôx1 ‚Äô: inputs [1]})
if util . has_rows ( s11 ):
s47 = util . do_sql (conn , " SELECT ‚Äòstories ‚Äò.* FROM ‚Äò
stories ‚Äò WHERE ‚Äòstories ‚Äò. ‚Äò project_id ‚Äò = :x0 AND ‚Äò
stories ‚Äò. ‚Äòid ‚Äò = :x1 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s11 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs
[2]})
outputs . extend ( util . get_data (s47 , ‚Äô stories ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s47 , ‚Äô stories ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s47 , ‚Äô stories ‚Äô, ‚Äô
description ‚Äô))
235
outputs . extend ( util . get_data (s47 , ‚Äô stories ‚Äô, ‚Äô estimate ‚Äô
))
outputs . extend ( util . get_data (s47 , ‚Äô stories ‚Äô, ‚Äô
requested_by_id ‚Äô))
outputs . extend ( util . get_data (s47 , ‚Äô stories ‚Äô, ‚Äô
owned_by_id ‚Äô))
outputs . extend ( util . get_data (s47 , ‚Äô stories ‚Äô, ‚Äô
project_id ‚Äô))
if util . has_rows ( s47 ):
s64 = util . do_sql (conn , " SELECT ‚Äònotes ‚Äò.* FROM ‚Äò
notes ‚Äò WHERE ‚Äònotes ‚Äò. ‚Äò story_id ‚Äò = :x0", {‚Äôx0 ‚Äô:
util . get_one_data (s47 , ‚Äô stories ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s64 , ‚Äônotes ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s64 , ‚Äônotes ‚Äô, ‚Äônote ‚Äô))
outputs . extend ( util . get_data (s64 , ‚Äônotes ‚Äô, ‚Äô user_id
‚Äô))
outputs . extend ( util . get_data (s64 , ‚Äônotes ‚Äô, ‚Äô
story_id ‚Äô))
else :
s48 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects
‚Äò.* FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò
ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò
project_id ‚Äò WHERE ‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :
x0", {‚Äôx0 ‚Äô: util . get_one_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô
)})
else :
s12 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äò
projects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE
‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
else :
pass
return util . add_warnings ( outputs )
236
A.1.6 Command get_projects_id_stories_id_notes
def get_projects_id_stories_id_notes (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s8 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s9 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM ‚Äò
projects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s8 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s10 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s8 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s11 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM
‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äò
id ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò
projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :
x1 LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô
), ‚Äôx1 ‚Äô: inputs [1]})
if util . has_rows ( s11 ):
s47 = util . do_sql (conn , " SELECT ‚Äòstories ‚Äò.* FROM ‚Äò
stories ‚Äò WHERE ‚Äòstories ‚Äò. ‚Äò project_id ‚Äò = :x0 AND ‚Äò
stories ‚Äò. ‚Äòid ‚Äò = :x1 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s11 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs
[2]})
if util . has_rows ( s47 ):
s57 = util . do_sql (conn , " SELECT ‚Äònotes ‚Äò.* FROM ‚Äò
notes ‚Äò WHERE ‚Äònotes ‚Äò. ‚Äò story_id ‚Äò = :x0", {‚Äôx0 ‚Äô:
util . get_one_data (s47 , ‚Äô stories ‚Äô, ‚Äôid ‚Äô)})
237
outputs . extend ( util . get_data (s57 , ‚Äônotes ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s57 , ‚Äônotes ‚Äô, ‚Äônote ‚Äô))
outputs . extend ( util . get_data (s57 , ‚Äônotes ‚Äô, ‚Äô user_id
‚Äô))
outputs . extend ( util . get_data (s57 , ‚Äônotes ‚Äô, ‚Äô
story_id ‚Äô))
else :
s48 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects
‚Äò.* FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò
ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò
project_id ‚Äò WHERE ‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :
x0", {‚Äôx0 ‚Äô: util . get_one_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô
)})
else :
s12 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äò
projects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE
‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
else :
pass
return util . add_warnings ( outputs )
A.1.7 Command get_projects_id_stories_id_notes_id
def get_projects_id_stories_id_notes_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s8 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
238
s9 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM ‚Äò
projects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s8 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s10 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s8 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s11 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM
‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äò
id ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò
projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :
x1 LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô
), ‚Äôx1 ‚Äô: inputs [1]})
if util . has_rows ( s11 ):
s47 = util . do_sql (conn , " SELECT ‚Äòstories ‚Äò.* FROM ‚Äò
stories ‚Äò WHERE ‚Äòstories ‚Äò. ‚Äò project_id ‚Äò = :x0 AND ‚Äò
stories ‚Äò. ‚Äòid ‚Äò = :x1 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s11 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs
[2]})
if util . has_rows ( s47 ):
s57 = util . do_sql (conn , " SELECT ‚Äònotes ‚Äò.* FROM ‚Äò
notes ‚Äò WHERE ‚Äònotes ‚Äò. ‚Äò story_id ‚Äò = :x0 AND ‚Äò
notes ‚Äò. ‚Äòid ‚Äò = :x1 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s47 , ‚Äô stories ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs
[3]})
outputs . extend ( util . get_data (s57 , ‚Äônotes ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s57 , ‚Äônotes ‚Äô, ‚Äônote ‚Äô))
outputs . extend ( util . get_data (s57 , ‚Äônotes ‚Äô, ‚Äô user_id
‚Äô))
outputs . extend ( util . get_data (s57 , ‚Äônotes ‚Äô, ‚Äô
story_id ‚Äô))
if util . has_rows ( s57 ):
pass
else :
239
s58 = util . do_sql (conn , " SELECT DISTINCT ‚Äò
projects ‚Äò.* FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò
projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = ‚Äò
projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò
projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô:
util . get_one_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
else :
s48 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects
‚Äò.* FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò
ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò
project_id ‚Äò WHERE ‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :
x0", {‚Äôx0 ‚Äô: util . get_one_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô
)})
else :
s12 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äò
projects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE
‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
else :
pass
return util . add_warnings ( outputs )
A.1.8 Command get_projects_id_users
def get_projects_id_users (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s8 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
240
s9 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM ‚Äò
projects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s8 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s10 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s8 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s11 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM
‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äò
id ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò
projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :
x1 LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô
), ‚Äôx1 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s11 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s11 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
if util . has_rows ( s11 ):
s61 = util . do_sql (conn , " SELECT DISTINCT ‚Äòusers ‚Äò.* FROM
‚Äòusers ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòusers ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò project_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s11 ,
‚Äô projects ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s61 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s61 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s61 , ‚Äôusers ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s61 , ‚Äôusers ‚Äô, ‚Äô initials ‚Äô))
s62 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äò
projects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE
‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s62 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s62 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
else :
s12 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äò
241
projects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE
‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
else :
pass
return util . add_warnings ( outputs )
A.2 Regenerated Code for Kandan Chat Room
A.2.1 Command get_channels
def get_channels (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s2 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s3 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äòchannels ‚Äò
", {})
outputs . extend ( util . get_data (s3 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äô channels ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äô channels ‚Äô, ‚Äô user_id ‚Äô))
if util . has_rows (s3):
s4 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.* FROM ‚Äò
activities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò channel_id ‚Äò IN :x0"
, {‚Äôx0 ‚Äô: util . get_data (s3 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s4 , ‚Äô activities ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô activities ‚Äô, ‚Äô content
‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô activities ‚Äô, ‚Äô
channel_id ‚Äô))
242
outputs . extend ( util . get_data (s4 , ‚Äô activities ‚Äô, ‚Äô user_id
‚Äô))
if util . has_rows (s4):
s71 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò IN :x0", {‚Äôx0 ‚Äô: util .
get_data (s4 , ‚Äô activities ‚Äô, ‚Äô user_id ‚Äô)})
outputs . extend ( util . get_data (s71 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s71 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô)
)
outputs . extend ( util . get_data (s71 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
outputs . extend ( util . get_data (s71 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
outputs . extend ( util . get_data (s71 , ‚Äôusers ‚Äô, ‚Äô
username ‚Äô))
s72 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s2 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s73 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äò
channels ‚Äò", {})
outputs . extend ( util . get_data (s73 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô)
)
outputs . extend ( util . get_data (s73 , ‚Äô channels ‚Äô, ‚Äôname
‚Äô))
outputs . extend ( util . get_data (s73 , ‚Äô channels ‚Äô, ‚Äô
user_id ‚Äô))
s73_all = s73
for s73 in s73_all :
s74 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
activities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò channel_id ‚Äò
= :x0", {‚Äôx0 ‚Äô: util . get_one_data (s73 , ‚Äô
channels ‚Äô, ‚Äôid ‚Äô)})
s75 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.*
FROM ‚Äòactivities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò
channel_id ‚Äò = :x0 ORDER BY id DESC LIMIT 30
OFFSET 0", {‚Äôx0 ‚Äô: util . get_one_data (s73 , ‚Äô
243
channels ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s75 , ‚Äô activities ‚Äô,
‚Äôid ‚Äô))
outputs . extend ( util . get_data (s75 , ‚Äô activities ‚Äô,
‚Äô content ‚Äô))
outputs . extend ( util . get_data (s75 , ‚Äô activities ‚Äô,
‚Äô channel_id ‚Äô))
outputs . extend ( util . get_data (s75 , ‚Äô activities ‚Äô,
‚Äô user_id ‚Äô))
if util . has_rows ( s75 ):
s78 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.*
FROM ‚Äòusers ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò IN :x0"
, {‚Äôx0 ‚Äô: util . get_data (s75 , ‚Äô activities ‚Äô
, ‚Äô user_id ‚Äô)})
outputs . extend ( util . get_data (s78 , ‚Äôusers ‚Äô,
‚Äôid ‚Äô))
outputs . extend ( util . get_data (s78 , ‚Äôusers ‚Äô,
‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s78 , ‚Äôusers ‚Äô,
‚Äô first_name ‚Äô))
outputs . extend ( util . get_data (s78 , ‚Äôusers ‚Äô,
‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s78 , ‚Äôusers ‚Äô,
‚Äô username ‚Äô))
else :
pass
s73 = s73_all
else :
s5 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s2 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s6 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äò
channels ‚Äò", {})
outputs . extend ( util . get_data (s6 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äô channels ‚Äô, ‚Äôname ‚Äô
))
244
outputs . extend ( util . get_data (s6 , ‚Äô channels ‚Äô, ‚Äô
user_id ‚Äô))
s6_all = s6
for s6 in s6_all :
s7 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
activities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò channel_id ‚Äò
= :x0", {‚Äôx0 ‚Äô: util . get_one_data (s6 , ‚Äô
channels ‚Äô, ‚Äôid ‚Äô)})
s8 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.*
FROM ‚Äòactivities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò
channel_id ‚Äò = :x0 ORDER BY id DESC LIMIT 30
OFFSET 0", {‚Äôx0 ‚Äô: util . get_one_data (s6 , ‚Äô
channels ‚Äô, ‚Äôid ‚Äô)})
s6 = s6_all
else :
s36 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s2 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s37 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äò
channels ‚Äò", {})
else :
pass
return util . add_warnings ( outputs )
A.2.2 Command get_channels_id_activities
def get_channels_id_activities (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s2 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
245
s3 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äòchannels ‚Äò
", {})
if util . has_rows (s3):
s4 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.* FROM ‚Äò
activities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò channel_id ‚Äò IN :x0"
, {‚Äôx0 ‚Äô: util . get_data (s3 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô)})
if util . has_rows (s4):
s40 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò IN :x0", {‚Äôx0 ‚Äô: util .
get_data (s4 , ‚Äô activities ‚Äô, ‚Äô user_id ‚Äô)})
s41 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s2 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s42 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM
‚Äòchannels ‚Äò WHERE ‚Äòchannels ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1"
, {‚Äôx0 ‚Äô: inputs [1]})
if util . has_rows ( s42 ):
s132 = util . do_sql (conn , " SELECT ‚Äòactivities
‚Äò.* FROM ‚Äòactivities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò
channel_id ‚Äò = :x0 ORDER BY id LIMIT 1", {‚Äôx0
‚Äô: util . get_one_data (s42 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô)
})
outputs . extend ( util . get_data (s132 , ‚Äô activities ‚Äô
, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s132 , ‚Äô activities ‚Äô
, ‚Äô content ‚Äô))
outputs . extend ( util . get_data (s132 , ‚Äô activities ‚Äô
, ‚Äô channel_id ‚Äô))
outputs . extend ( util . get_data (s132 , ‚Äô activities ‚Äô
, ‚Äô user_id ‚Äô))
s133 = util . do_sql (conn , " SELECT ‚Äòactivities
‚Äò.* FROM ‚Äòactivities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò
channel_id ‚Äò = :x0 ORDER BY id DESC LIMIT 30"
, {‚Äôx0 ‚Äô: util . get_one_data (s42 , ‚Äô channels ‚Äô,
‚Äôid ‚Äô)})
246
outputs . extend ( util . get_data (s133 , ‚Äô activities ‚Äô
, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s133 , ‚Äô activities ‚Äô
, ‚Äô content ‚Äô))
outputs . extend ( util . get_data (s133 , ‚Äô activities ‚Äô
, ‚Äô channel_id ‚Äô))
outputs . extend ( util . get_data (s133 , ‚Äô activities ‚Äô
, ‚Äô user_id ‚Äô))
if util . has_rows ( s133 ):
s167 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.*
FROM ‚Äòusers ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò IN :x0"
, {‚Äôx0 ‚Äô: util . get_data (s133 , ‚Äô activities
‚Äô, ‚Äô user_id ‚Äô)})
outputs . extend ( util . get_data (s167 , ‚Äôusers ‚Äô,
‚Äôid ‚Äô))
outputs . extend ( util . get_data (s167 , ‚Äôusers ‚Äô,
‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s167 , ‚Äôusers ‚Äô,
‚Äô first_name ‚Äô))
outputs . extend ( util . get_data (s167 , ‚Äôusers ‚Äô,
‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s167 , ‚Äôusers ‚Äô,
‚Äô username ‚Äô))
else :
pass
else :
pass
else :
s5 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s2 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s6 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äò
channels ‚Äò WHERE ‚Äòchannels ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1",
{‚Äôx0 ‚Äô: inputs [1]})
if util . has_rows (s6):
247
s69 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.*
FROM ‚Äòactivities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò
channel_id ‚Äò = :x0 ORDER BY id LIMIT 1", {‚Äôx0
‚Äô: util . get_one_data (s6 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô)})
s70 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.*
FROM ‚Äòactivities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò
channel_id ‚Äò = :x0 ORDER BY id DESC LIMIT 30"
, {‚Äôx0 ‚Äô: util . get_one_data (s6 , ‚Äô channels ‚Äô, ‚Äô
id ‚Äô)})
else :
pass
else :
s25 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s2 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s26 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äò
channels ‚Äò WHERE ‚Äòchannels ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äô
x0 ‚Äô: inputs [1]})
else :
pass
return util . add_warnings ( outputs )
A.2.3 Command get_channels_id_activities_id
def get_channels_id_activities_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s2 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s3 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äòchannels ‚Äò
", {})
248
if util . has_rows (s3):
s4 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.* FROM ‚Äò
activities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò channel_id ‚Äò IN :x0"
, {‚Äôx0 ‚Äô: util . get_data (s3 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô)})
if util . has_rows (s4):
s47 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò IN :x0", {‚Äôx0 ‚Äô: util .
get_data (s4 , ‚Äô activities ‚Äô, ‚Äô user_id ‚Äô)})
s48 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s2 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s49 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.*
FROM ‚Äòactivities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äòid ‚Äò = :x0
LIMIT 1", {‚Äôx0 ‚Äô: inputs [2]})
outputs . extend ( util . get_data (s49 , ‚Äô activities ‚Äô, ‚Äô
content ‚Äô))
else :
s5 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s2 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s6 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.* FROM
‚Äòactivities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äòid ‚Äò = :x0
LIMIT 1", {‚Äôx0 ‚Äô: inputs [2]})
outputs . extend ( util . get_data (s6 , ‚Äô activities ‚Äô, ‚Äô
content ‚Äô))
else :
s25 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s2 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s26 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.* FROM ‚Äò
activities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1",
{‚Äôx0 ‚Äô: inputs [2]})
outputs . extend ( util . get_data (s26 , ‚Äô activities ‚Äô, ‚Äô
content ‚Äô))
else :
pass
249
return util . add_warnings ( outputs )
A.2.4 Command get_me
def get_me (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
if util . has_rows (s0):
s2 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s2 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
s3 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äòchannels ‚Äò
", {})
if util . has_rows (s3):
s4 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.* FROM ‚Äò
activities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò channel_id ‚Äò IN :x0"
, {‚Äôx0 ‚Äô: util . get_data (s3 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô)})
if util . has_rows (s4):
s35 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò IN :x0", {‚Äôx0 ‚Äô: util .
get_data (s4 , ‚Äô activities ‚Äô, ‚Äô user_id ‚Äô)})
s36 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
250
: util . get_one_data (s2 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s36 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s36 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô)
)
outputs . extend ( util . get_data (s36 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
outputs . extend ( util . get_data (s36 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
outputs . extend ( util . get_data (s36 , ‚Äôusers ‚Äô, ‚Äô
username ‚Äô))
else :
s5 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s2 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äô username
‚Äô))
else :
s22 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s2 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s22 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s22 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s22 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô
))
outputs . extend ( util . get_data (s22 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô)
)
outputs . extend ( util . get_data (s22 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
else :
pass
return util . add_warnings ( outputs )
251
A.2.5 Command get_users
def get_users (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
if util . has_rows (s0):
s8 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
s9 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äòchannels ‚Äò
", {})
if util . has_rows (s9):
s10 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.* FROM ‚Äò
activities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò channel_id ‚Äò IN :x0"
, {‚Äôx0 ‚Äô: util . get_data (s9 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô)})
if util . has_rows ( s10 ):
s58 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò IN :x0", {‚Äôx0 ‚Äô: util .
get_data (s10 , ‚Äô activities ‚Äô, ‚Äô user_id ‚Äô)})
outputs . extend ( util . get_data (s58 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s58 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô)
)
outputs . extend ( util . get_data (s58 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
252
outputs . extend ( util . get_data (s58 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
outputs . extend ( util . get_data (s58 , ‚Äôusers ‚Äô, ‚Äô
username ‚Äô))
s59 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s8 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s59 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s59 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô)
)
outputs . extend ( util . get_data (s59 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
outputs . extend ( util . get_data (s59 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
outputs . extend ( util . get_data (s59 , ‚Äôusers ‚Äô, ‚Äô
username ‚Äô))
s60 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò", {})
outputs . extend ( util . get_data (s60 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s60 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô)
)
outputs . extend ( util . get_data (s60 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
outputs . extend ( util . get_data (s60 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
outputs . extend ( util . get_data (s60 , ‚Äôusers ‚Äô, ‚Äô
username ‚Äô))
else :
s11 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s8 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s11 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s11 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô)
)
outputs . extend ( util . get_data (s11 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
253
outputs . extend ( util . get_data (s11 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
outputs . extend ( util . get_data (s11 , ‚Äôusers ‚Äô, ‚Äô
username ‚Äô))
s12 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò", {})
outputs . extend ( util . get_data (s12 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s12 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô)
)
outputs . extend ( util . get_data (s12 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
outputs . extend ( util . get_data (s12 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
outputs . extend ( util . get_data (s12 , ‚Äôusers ‚Äô, ‚Äô
username ‚Äô))
else :
s36 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s8 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s36 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s36 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s36 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô
))
outputs . extend ( util . get_data (s36 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô)
)
outputs . extend ( util . get_data (s36 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
s37 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò"
, {})
outputs . extend ( util . get_data (s37 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s37 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s37 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô
))
outputs . extend ( util . get_data (s37 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô)
)
outputs . extend ( util . get_data (s37 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
else :
254
pass
return util . add_warnings ( outputs )
A.2.6 Command get_users_id
def get_users_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
if util . has_rows (s0):
s2 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s2 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
s3 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äòchannels ‚Äò
", {})
if util . has_rows (s3):
s4 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.* FROM ‚Äò
activities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò channel_id ‚Äò IN :x0"
, {‚Äôx0 ‚Äô: util . get_data (s3 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô)})
if util . has_rows (s4):
s35 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò IN :x0", {‚Äôx0 ‚Äô: util .
get_data (s4 , ‚Äô activities ‚Äô, ‚Äô user_id ‚Äô)})
255
s36 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s2 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s36 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s36 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô)
)
outputs . extend ( util . get_data (s36 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
outputs . extend ( util . get_data (s36 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
outputs . extend ( util . get_data (s36 , ‚Äôusers ‚Äô, ‚Äô
username ‚Äô))
else :
s5 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s2 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äô username
‚Äô))
else :
s22 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s2 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s22 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s22 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s22 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô
))
outputs . extend ( util . get_data (s22 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô)
)
outputs . extend ( util . get_data (s22 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
else :
256
pass
return util . add_warnings ( outputs )
A.3 Regenerated Code for Enki Blogging Applica-
tion
A.3.1 Command get_admin_comments_id
def get_admin_comments_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòcomments ‚Äò.* FROM ‚Äòcomments ‚Äò
WHERE ‚Äòcomments ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äô comments ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äô comments ‚Äô, ‚Äô author ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äô comments ‚Äô, ‚Äô author_url ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äô comments ‚Äô, ‚Äô author_email ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äô comments ‚Äô, ‚Äôbody ‚Äô))
return util . add_warnings ( outputs )
A.3.2 Command get_admin_pages
def get_admin_pages (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äòpages ‚Äò", {})
if util . has_rows (s0):
s2 = util . do_sql (conn , " SELECT ‚Äòpages ‚Äò.* FROM ‚Äòpages ‚Äò
ORDER BY created_at DESC LIMIT 30 OFFSET 0", {})
outputs . extend ( util . get_data (s2 , ‚Äôpages ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äôpages ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äôpages ‚Äô, ‚Äôslug ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äôpages ‚Äô, ‚Äôbody ‚Äô))
257
else :
pass
return util . add_warnings ( outputs )
A.3.3 Command get_admin_pages_id
def get_admin_pages_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòpages ‚Äò.* FROM ‚Äòpages ‚Äò WHERE ‚Äò
pages ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äôpages ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôpages ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôpages ‚Äô, ‚Äôslug ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôpages ‚Äô, ‚Äôbody ‚Äô))
return util . add_warnings ( outputs )
A.3.4 Command get_admin_posts
def get_admin_posts (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äòposts ‚Äò", {})
if util . has_rows (s0):
s2 = util . do_sql (conn , " SELECT ‚Äòposts ‚Äò.* FROM ‚Äòposts ‚Äò
ORDER BY coalesce ( published_at , updated_at ) DESC LIMIT
30 OFFSET 0", {})
outputs . extend ( util . get_data (s2 , ‚Äôposts ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äôposts ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äôposts ‚Äô, ‚Äôbody ‚Äô))
s2_all = s2
for s2 in s2_all :
s3 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äòcomments ‚Äò
WHERE ‚Äòcomments ‚Äò. ‚Äò post_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s2 , ‚Äôposts ‚Äô, ‚Äôid ‚Äô)})
258
s2 = s2_all
else :
pass
return util . add_warnings ( outputs )
A.4 Regenerated Code for Blog Application
A.4.1 Command get_articles
def get_articles (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòarticles ‚Äò.* FROM ‚Äòarticles ‚Äò",
{})
outputs . extend ( util . get_data (s0 , ‚Äô articles ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äô articles ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äô articles ‚Äô, ‚Äôtext ‚Äô))
s1 = util . do_sql (conn , " SELECT ‚Äòarticles ‚Äò.* FROM ‚Äòarticles ‚Äò",
{})
outputs . extend ( util . get_data (s1 , ‚Äô articles ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äô articles ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äô articles ‚Äô, ‚Äôtext ‚Äô))
return util . add_warnings ( outputs )
A.4.2 Command get_article_id
def get_article_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòarticles ‚Äò.* FROM ‚Äòarticles ‚Äò",
{})
s1 = util . do_sql (conn , " SELECT ‚Äòarticles ‚Äò.* FROM ‚Äòarticles ‚Äò
WHERE ‚Äòarticles ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s1 , ‚Äô articles ‚Äô, ‚Äôid ‚Äô))
259
outputs . extend ( util . get_data (s1 , ‚Äô articles ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äô articles ‚Äô, ‚Äôtext ‚Äô))
if util . has_rows (s1):
s9 = util . do_sql (conn , " SELECT ‚Äòcomments ‚Äò.* FROM ‚Äòcomments ‚Äò
WHERE ‚Äòcomments ‚Äò. ‚Äò article_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s1 , ‚Äô articles ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s9 , ‚Äô comments ‚Äô, ‚Äô commenter ‚Äô))
outputs . extend ( util . get_data (s9 , ‚Äô comments ‚Äô, ‚Äôbody ‚Äô))
outputs . extend ( util . get_data (s9 , ‚Äô comments ‚Äô, ‚Äô article_id ‚Äô))
else :
pass
return util . add_warnings ( outputs )
A.5 RegeneratedCodeforStudentRegistrationSys-
tem
A.5.1 Command liststudentcourses
def liststudentcourses (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT * FROM student WHERE id = :x0",
{‚Äôx0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s2 = util . do_sql (conn , " SELECT * FROM student WHERE id =: x0
AND password =: x1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äô student
‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs [1]})
if util . has_rows (s2):
s6 = util . do_sql (conn , " SELECT * FROM course c JOIN
registration r on r. course_id = c.id WHERE r.
student_id = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s2 , ‚Äô
student ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s6 , ‚Äô course ‚Äô, ‚Äôid ‚Äô))
260
outputs . extend ( util . get_data (s6 , ‚Äô course ‚Äô, ‚Äô teacher_id ‚Äô
))
outputs . extend ( util . get_data (s6 , ‚Äô registration ‚Äô, ‚Äô
course_id ‚Äô))
if util . has_rows (s6):
s6_all = s6
for s6 in s6_all :
s12 = util . do_sql (conn , " Select firstname ,
lastname from teacher where id = :x0", {‚Äôx0 ‚Äô
: util . get_one_data (s6 , ‚Äô course ‚Äô, ‚Äô
teacher_id ‚Äô)})
s13 = util . do_sql (conn , " SELECT count (*) FROM
registration WHERE course_id = :x0", {‚Äôx0 ‚Äô:
util . get_one_data (s6 , ‚Äô registration ‚Äô, ‚Äô
course_id ‚Äô)})
s6 = s6_all
else :
pass
else :
pass
else :
pass
return util . add_warnings ( outputs )
261
262
Appendix B
Synthetic Commands for Evaluating
Konure
B.1 Simple Sequences (SS)
Version 1:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
Version 2:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
s2 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [2]})
Version 3:
263
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
s2 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [2]})
s3 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [3]})
Version 4:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
s2 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [2]})
s3 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [3]})
s4 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [4]})
Version 5:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
s2 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [2]})
s3 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
264
sys . argv [3]})
s4 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [4]})
s5 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [5]})
Version 6:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
s2 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [2]})
s3 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [3]})
s4 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [4]})
s5 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [5]})
s6 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [6]})
Version 7:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
s2 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [2]})
s3 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [3]})
s4 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
265
sys . argv [4]})
s5 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [5]})
s6 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [6]})
s7 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [7]})
Version 8:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
s2 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [2]})
s3 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [3]})
s4 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [4]})
s5 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [5]})
s6 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [6]})
s7 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [7]})
s8 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [8]})
Version 9:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
266
sys . argv [1]})
s2 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [2]})
s3 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [3]})
s4 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [4]})
s5 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [5]})
s6 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [6]})
s7 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [7]})
s8 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [8]})
s9 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [9]})
B.2 Nested Conditionals (NC)
Version 1:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1", {})
Version 2:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1", {})
if s1:
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
267
Version 3:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1", {})
if s1:
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
if s2:
s3 = util . do_sql (conn , " SELECT * FROM t3", {})
Version 4:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1", {})
if s1:
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
if s2:
s3 = util . do_sql (conn , " SELECT * FROM t3", {})
if s3:
s4 = util . do_sql (conn , " SELECT * FROM t4", {})
Version 5:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1", {})
if s1:
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
if s2:
s3 = util . do_sql (conn , " SELECT * FROM t3", {})
268
if s3:
s4 = util . do_sql (conn , " SELECT * FROM t4", {})
if s4:
s5 = util . do_sql (conn , " SELECT * FROM t5", {})
Version 6:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1", {})
if s1:
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
if s2:
s3 = util . do_sql (conn , " SELECT * FROM t3", {})
if s3:
s4 = util . do_sql (conn , " SELECT * FROM t4", {})
if s4:
s5 = util . do_sql (conn , " SELECT * FROM t5", {})
if s5:
s6 = util . do_sql (conn , " SELECT * FROM t6",
{})
Version 7:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1", {})
if s1:
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
if s2:
s3 = util . do_sql (conn , " SELECT * FROM t3", {})
if s3:
s4 = util . do_sql (conn , " SELECT * FROM t4", {})
if s4:
269
s5 = util . do_sql (conn , " SELECT * FROM t5", {})
if s5:
s6 = util . do_sql (conn , " SELECT * FROM t6",
{})
if s6:
s7 = util . do_sql (conn , " SELECT * FROM
t7", {})
Version 8:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1", {})
if s1:
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
if s2:
s3 = util . do_sql (conn , " SELECT * FROM t3", {})
if s3:
s4 = util . do_sql (conn , " SELECT * FROM t4", {})
if s4:
s5 = util . do_sql (conn , " SELECT * FROM t5", {})
if s5:
s6 = util . do_sql (conn , " SELECT * FROM t6",
{})
if s6:
s7 = util . do_sql (conn , " SELECT * FROM
t7", {})
if s7:
s8 = util . do_sql (conn , " SELECT *
FROM t8", {})
Version 9:
import sys
import active_utils as util
270
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1", {})
if s1:
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
if s2:
s3 = util . do_sql (conn , " SELECT * FROM t3", {})
if s3:
s4 = util . do_sql (conn , " SELECT * FROM t4", {})
if s4:
s5 = util . do_sql (conn , " SELECT * FROM t5", {})
if s5:
s6 = util . do_sql (conn , " SELECT * FROM t6",
{})
if s6:
s7 = util . do_sql (conn , " SELECT * FROM
t7", {})
if s7:
s8 = util . do_sql (conn , " SELECT *
FROM t8", {})
if s8:
s9 = util . do_sql (conn , " SELECT
* FROM t9", {})
B.3 Unambiguous Long Reference Chains (UL)
Version 1:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
Version 2:
271
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
if s1:
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": util . get_one_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô)})
Version 3:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
if s1:
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": util . get_one_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô)})
if s2:
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": util . get_one_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô)})
Version 4:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
if s1:
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": util . get_one_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô)})
if s2:
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
272
, {"x": util . get_one_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô)})
if s3:
s4 = util . do_sql (conn , " SELECT * FROM t4 WHERE id =
:x", {"x": util . get_one_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô)})
Version 5:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
if s1:
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": util . get_one_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô)})
if s2:
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": util . get_one_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô)})
if s3:
s4 = util . do_sql (conn , " SELECT * FROM t4 WHERE id =
:x", {"x": util . get_one_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô)})
if s4:
s5 = util . do_sql (conn , " SELECT * FROM t5 WHERE
id = :x", {"x": util . get_one_data (s4 , ‚Äôt4 ‚Äô,
‚Äôval ‚Äô)})
Version 6:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
if s1:
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": util . get_one_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô)})
273
if s2:
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": util . get_one_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô)})
if s3:
s4 = util . do_sql (conn , " SELECT * FROM t4 WHERE id =
:x", {"x": util . get_one_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô)})
if s4:
s5 = util . do_sql (conn , " SELECT * FROM t5 WHERE
id = :x", {"x": util . get_one_data (s4 , ‚Äôt4 ‚Äô,
‚Äôval ‚Äô)})
if s5:
s6 = util . do_sql (conn , " SELECT * FROM t6
WHERE id = :x", {"x": util . get_one_data (
s5 , ‚Äôt5 ‚Äô, ‚Äôval ‚Äô)})
Version 7:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
if s1:
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": util . get_one_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô)})
if s2:
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": util . get_one_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô)})
if s3:
s4 = util . do_sql (conn , " SELECT * FROM t4 WHERE id =
:x", {"x": util . get_one_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô)})
if s4:
s5 = util . do_sql (conn , " SELECT * FROM t5 WHERE
id = :x", {"x": util . get_one_data (s4 , ‚Äôt4 ‚Äô,
‚Äôval ‚Äô)})
if s5:
274
s6 = util . do_sql (conn , " SELECT * FROM t6
WHERE id = :x", {"x": util . get_one_data (
s5 , ‚Äôt5 ‚Äô, ‚Äôval ‚Äô)})
if s6:
s7 = util . do_sql (conn , " SELECT * FROM
t7 WHERE id = :x", {"x": util .
get_one_data (s6 , ‚Äôt6 ‚Äô, ‚Äôval ‚Äô)})
Version 8:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
if s1:
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": util . get_one_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô)})
if s2:
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": util . get_one_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô)})
if s3:
s4 = util . do_sql (conn , " SELECT * FROM t4 WHERE id =
:x", {"x": util . get_one_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô)})
if s4:
s5 = util . do_sql (conn , " SELECT * FROM t5 WHERE
id = :x", {"x": util . get_one_data (s4 , ‚Äôt4 ‚Äô,
‚Äôval ‚Äô)})
if s5:
s6 = util . do_sql (conn , " SELECT * FROM t6
WHERE id = :x", {"x": util . get_one_data (
s5 , ‚Äôt5 ‚Äô, ‚Äôval ‚Äô)})
if s6:
s7 = util . do_sql (conn , " SELECT * FROM
t7 WHERE id = :x", {"x": util .
get_one_data (s6 , ‚Äôt6 ‚Äô, ‚Äôval ‚Äô)})
275
if s7:
s8 = util . do_sql (conn , " SELECT *
FROM t8 WHERE id = :x", {"x":
util . get_one_data (s7 , ‚Äôt7 ‚Äô, ‚Äôval
‚Äô)})
Version 9:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
if s1:
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": util . get_one_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô)})
if s2:
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": util . get_one_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô)})
if s3:
s4 = util . do_sql (conn , " SELECT * FROM t4 WHERE id =
:x", {"x": util . get_one_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô)})
if s4:
s5 = util . do_sql (conn , " SELECT * FROM t5 WHERE
id = :x", {"x": util . get_one_data (s4 , ‚Äôt4 ‚Äô,
‚Äôval ‚Äô)})
if s5:
s6 = util . do_sql (conn , " SELECT * FROM t6
WHERE id = :x", {"x": util . get_one_data (
s5 , ‚Äôt5 ‚Äô, ‚Äôval ‚Äô)})
if s6:
s7 = util . do_sql (conn , " SELECT * FROM
t7 WHERE id = :x", {"x": util .
get_one_data (s6 , ‚Äôt6 ‚Äô, ‚Äôval ‚Äô)})
if s7:
s8 = util . do_sql (conn , " SELECT *
276
FROM t8 WHERE id = :x", {"x":
util . get_one_data (s7 , ‚Äôt7 ‚Äô, ‚Äôval
‚Äô)})
if s8:
s9 = util . do_sql (conn , " SELECT
* FROM t9 WHERE id = :x", {"
x": util . get_one_data (s8 , ‚Äô
t8 ‚Äô, ‚Äôval ‚Äô)})
B.4 Ambiguous Long Reference Chains (AL)
Version 1:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1_ = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
Version 2:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1_ = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
if s1:
s2_ = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": util . get_one_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô)})
Version 3:
277
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1_ = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
if s1:
s2_ = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": util . get_one_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô)})
if s2:
s3_ = util . do_sql (conn , " SELECT * FROM t3", {})
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": util . get_one_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô)})
Version 4:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1_ = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
if s1:
s2_ = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": util . get_one_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô)})
if s2:
s3_ = util . do_sql (conn , " SELECT * FROM t3", {})
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": util . get_one_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô)})
if s3:
s4_ = util . do_sql (conn , " SELECT * FROM t4", {})
s4 = util . do_sql (conn , " SELECT * FROM t4 WHERE id =
278
:x", {"x": util . get_one_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô)})
Version 5:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1_ = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
if s1:
s2_ = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": util . get_one_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô)})
if s2:
s3_ = util . do_sql (conn , " SELECT * FROM t3", {})
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": util . get_one_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô)})
if s3:
s4_ = util . do_sql (conn , " SELECT * FROM t4", {})
s4 = util . do_sql (conn , " SELECT * FROM t4 WHERE id =
:x", {"x": util . get_one_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô)})
if s4:
s5_ = util . do_sql (conn , " SELECT * FROM t5", {})
s5 = util . do_sql (conn , " SELECT * FROM t5 WHERE
id = :x", {"x": util . get_one_data (s4 , ‚Äôt4 ‚Äô,
‚Äôval ‚Äô)})
Version 6:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1_ = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
279
if s1:
s2_ = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": util . get_one_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô)})
if s2:
s3_ = util . do_sql (conn , " SELECT * FROM t3", {})
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": util . get_one_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô)})
if s3:
s4_ = util . do_sql (conn , " SELECT * FROM t4", {})
s4 = util . do_sql (conn , " SELECT * FROM t4 WHERE id =
:x", {"x": util . get_one_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô)})
if s4:
s5_ = util . do_sql (conn , " SELECT * FROM t5", {})
s5 = util . do_sql (conn , " SELECT * FROM t5 WHERE
id = :x", {"x": util . get_one_data (s4 , ‚Äôt4 ‚Äô,
‚Äôval ‚Äô)})
if s5:
s6_ = util . do_sql (conn , " SELECT * FROM t6",
{})
s6 = util . do_sql (conn , " SELECT * FROM t6
WHERE id = :x", {"x": util . get_one_data (
s5 , ‚Äôt5 ‚Äô, ‚Äôval ‚Äô)})
Version 7:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1_ = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
if s1:
s2_ = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": util . get_one_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô)})
280
if s2:
s3_ = util . do_sql (conn , " SELECT * FROM t3", {})
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": util . get_one_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô)})
if s3:
s4_ = util . do_sql (conn , " SELECT * FROM t4", {})
s4 = util . do_sql (conn , " SELECT * FROM t4 WHERE id =
:x", {"x": util . get_one_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô)})
if s4:
s5_ = util . do_sql (conn , " SELECT * FROM t5", {})
s5 = util . do_sql (conn , " SELECT * FROM t5 WHERE
id = :x", {"x": util . get_one_data (s4 , ‚Äôt4 ‚Äô,
‚Äôval ‚Äô)})
if s5:
s6_ = util . do_sql (conn , " SELECT * FROM t6",
{})
s6 = util . do_sql (conn , " SELECT * FROM t6
WHERE id = :x", {"x": util . get_one_data (
s5 , ‚Äôt5 ‚Äô, ‚Äôval ‚Äô)})
if s6:
s7_ = util . do_sql (conn , " SELECT * FROM
t7", {})
s7 = util . do_sql (conn , " SELECT * FROM
t7 WHERE id = :x", {"x": util .
get_one_data (s6 , ‚Äôt6 ‚Äô, ‚Äôval ‚Äô)})
Version 8:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1_ = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
if s1:
s2_ = util . do_sql (conn , " SELECT * FROM t2", {})
281
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": util . get_one_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô)})
if s2:
s3_ = util . do_sql (conn , " SELECT * FROM t3", {})
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": util . get_one_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô)})
if s3:
s4_ = util . do_sql (conn , " SELECT * FROM t4", {})
s4 = util . do_sql (conn , " SELECT * FROM t4 WHERE id =
:x", {"x": util . get_one_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô)})
if s4:
s5_ = util . do_sql (conn , " SELECT * FROM t5", {})
s5 = util . do_sql (conn , " SELECT * FROM t5 WHERE
id = :x", {"x": util . get_one_data (s4 , ‚Äôt4 ‚Äô,
‚Äôval ‚Äô)})
if s5:
s6_ = util . do_sql (conn , " SELECT * FROM t6",
{})
s6 = util . do_sql (conn , " SELECT * FROM t6
WHERE id = :x", {"x": util . get_one_data (
s5 , ‚Äôt5 ‚Äô, ‚Äôval ‚Äô)})
if s6:
s7_ = util . do_sql (conn , " SELECT * FROM
t7", {})
s7 = util . do_sql (conn , " SELECT * FROM
t7 WHERE id = :x", {"x": util .
get_one_data (s6 , ‚Äôt6 ‚Äô, ‚Äôval ‚Äô)})
if s7:
s8_ = util . do_sql (conn , " SELECT *
FROM t8", {})
s8 = util . do_sql (conn , " SELECT *
FROM t8 WHERE id = :x", {"x":
util . get_one_data (s7 , ‚Äôt7 ‚Äô, ‚Äôval
‚Äô)})
Version 9:
282
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1_ = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
if s1:
s2_ = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": util . get_one_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô)})
if s2:
s3_ = util . do_sql (conn , " SELECT * FROM t3", {})
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": util . get_one_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô)})
if s3:
s4_ = util . do_sql (conn , " SELECT * FROM t4", {})
s4 = util . do_sql (conn , " SELECT * FROM t4 WHERE id =
:x", {"x": util . get_one_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô)})
if s4:
s5_ = util . do_sql (conn , " SELECT * FROM t5", {})
s5 = util . do_sql (conn , " SELECT * FROM t5 WHERE
id = :x", {"x": util . get_one_data (s4 , ‚Äôt4 ‚Äô,
‚Äôval ‚Äô)})
if s5:
s6_ = util . do_sql (conn , " SELECT * FROM t6",
{})
s6 = util . do_sql (conn , " SELECT * FROM t6
WHERE id = :x", {"x": util . get_one_data (
s5 , ‚Äôt5 ‚Äô, ‚Äôval ‚Äô)})
if s6:
s7_ = util . do_sql (conn , " SELECT * FROM
t7", {})
s7 = util . do_sql (conn , " SELECT * FROM
t7 WHERE id = :x", {"x": util .
get_one_data (s6 , ‚Äôt6 ‚Äô, ‚Äôval ‚Äô)})
283
if s7:
s8_ = util . do_sql (conn , " SELECT *
FROM t8", {})
s8 = util . do_sql (conn , " SELECT *
FROM t8 WHERE id = :x", {"x":
util . get_one_data (s7 , ‚Äôt7 ‚Äô, ‚Äôval
‚Äô)})
if s8:
s9_ = util . do_sql (conn , " SELECT
* FROM t9", {})
s9 = util . do_sql (conn , " SELECT
* FROM t9 WHERE id = :x", {"
x": util . get_one_data (s8 , ‚Äô
t8 ‚Äô, ‚Äôval ‚Äô)})
B.5 Ambiguous Short Reference Chains (AS)
Version 1:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1_ = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
print ( util . get_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô))
Version 2:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1_ = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
284
print ( util . get_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô))
if s1:
s2_ = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": sys . argv [2]})
print ( util . get_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô))
Version 3:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1_ = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
print ( util . get_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô))
if s1:
s2_ = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": sys . argv [2]})
print ( util . get_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô))
if s2:
s3_ = util . do_sql (conn , " SELECT * FROM t3", {})
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": sys . argv [3]})
print ( util . get_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô))
Version 4:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1_ = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
print ( util . get_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô))
285
if s1:
s2_ = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": sys . argv [2]})
print ( util . get_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô))
if s2:
s3_ = util . do_sql (conn , " SELECT * FROM t3", {})
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": sys . argv [3]})
print ( util . get_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô))
if s3:
s4_ = util . do_sql (conn , " SELECT * FROM t4", {})
s4 = util . do_sql (conn , " SELECT * FROM t4 WHERE id =
:x", {"x": sys . argv [4]})
print ( util . get_data (s4 , ‚Äôt4 ‚Äô, ‚Äôval ‚Äô))
Version 5:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1_ = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
print ( util . get_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô))
if s1:
s2_ = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": sys . argv [2]})
print ( util . get_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô))
if s2:
s3_ = util . do_sql (conn , " SELECT * FROM t3", {})
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": sys . argv [3]})
print ( util . get_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô))
if s3:
286
s4_ = util . do_sql (conn , " SELECT * FROM t4", {})
s4 = util . do_sql (conn , " SELECT * FROM t4 WHERE id =
:x", {"x": sys . argv [4]})
print ( util . get_data (s4 , ‚Äôt4 ‚Äô, ‚Äôval ‚Äô))
if s4:
s5_ = util . do_sql (conn , " SELECT * FROM t5", {})
s5 = util . do_sql (conn , " SELECT * FROM t5 WHERE
id = :x", {"x": sys . argv [5]})
print ( util . get_data (s5 , ‚Äôt5 ‚Äô, ‚Äôval ‚Äô))
Version 6:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1_ = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
print ( util . get_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô))
if s1:
s2_ = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": sys . argv [2]})
print ( util . get_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô))
if s2:
s3_ = util . do_sql (conn , " SELECT * FROM t3", {})
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": sys . argv [3]})
print ( util . get_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô))
if s3:
s4_ = util . do_sql (conn , " SELECT * FROM t4", {})
s4 = util . do_sql (conn , " SELECT * FROM t4 WHERE id =
:x", {"x": sys . argv [4]})
print ( util . get_data (s4 , ‚Äôt4 ‚Äô, ‚Äôval ‚Äô))
if s4:
s5_ = util . do_sql (conn , " SELECT * FROM t5", {})
287
s5 = util . do_sql (conn , " SELECT * FROM t5 WHERE
id = :x", {"x": sys . argv [5]})
print ( util . get_data (s5 , ‚Äôt5 ‚Äô, ‚Äôval ‚Äô))
if s5:
s6_ = util . do_sql (conn , " SELECT * FROM t6",
{})
s6 = util . do_sql (conn , " SELECT * FROM t6
WHERE id = :x", {"x": sys . argv [6]})
print ( util . get_data (s6 , ‚Äôt6 ‚Äô, ‚Äôval ‚Äô))
Version 7:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1_ = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
print ( util . get_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô))
if s1:
s2_ = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": sys . argv [2]})
print ( util . get_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô))
if s2:
s3_ = util . do_sql (conn , " SELECT * FROM t3", {})
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": sys . argv [3]})
print ( util . get_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô))
if s3:
s4_ = util . do_sql (conn , " SELECT * FROM t4", {})
s4 = util . do_sql (conn , " SELECT * FROM t4 WHERE id =
:x", {"x": sys . argv [4]})
print ( util . get_data (s4 , ‚Äôt4 ‚Äô, ‚Äôval ‚Äô))
if s4:
s5_ = util . do_sql (conn , " SELECT * FROM t5", {})
288
s5 = util . do_sql (conn , " SELECT * FROM t5 WHERE
id = :x", {"x": sys . argv [5]})
print ( util . get_data (s5 , ‚Äôt5 ‚Äô, ‚Äôval ‚Äô))
if s5:
s6_ = util . do_sql (conn , " SELECT * FROM t6",
{})
s6 = util . do_sql (conn , " SELECT * FROM t6
WHERE id = :x", {"x": sys . argv [6]})
print ( util . get_data (s6 , ‚Äôt6 ‚Äô, ‚Äôval ‚Äô))
if s6:
s7_ = util . do_sql (conn , " SELECT * FROM
t7", {})
s7 = util . do_sql (conn , " SELECT * FROM
t7 WHERE id = :x", {"x": sys . argv
[7]})
print ( util . get_data (s7 , ‚Äôt7 ‚Äô, ‚Äôval ‚Äô))
Version 8:
import sys
import active_utils as util
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1_ = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
print ( util . get_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô))
if s1:
s2_ = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": sys . argv [2]})
print ( util . get_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô))
if s2:
s3_ = util . do_sql (conn , " SELECT * FROM t3", {})
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": sys . argv [3]})
print ( util . get_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô))
289
if s3:
s4_ = util . do_sql (conn , " SELECT * FROM t4", {})
s4 = util . do_sql (conn , " SELECT * FROM t4 WHERE id =
:x", {"x": sys . argv [4]})
print ( util . get_data (s4 , ‚Äôt4 ‚Äô, ‚Äôval ‚Äô))
if s4:
s5_ = util . do_sql (conn , " SELECT * FROM t5", {})
s5 = util . do_sql (conn , " SELECT * FROM t5 WHERE
id = :x", {"x": sys . argv [5]})
print ( util . get_data (s5 , ‚Äôt5 ‚Äô, ‚Äôval ‚Äô))
if s5:
s6_ = util . do_sql (conn , " SELECT * FROM t6",
{})
s6 = util . do_sql (conn , " SELECT * FROM t6
WHERE id = :x", {"x": sys . argv [6]})
print ( util . get_data (s6 , ‚Äôt6 ‚Äô, ‚Äôval ‚Äô))
if s6:
s7_ = util . do_sql (conn , " SELECT * FROM
t7", {})
s7 = util . do_sql (conn , " SELECT * FROM
t7 WHERE id = :x", {"x": sys . argv
[7]})
print ( util . get_data (s7 , ‚Äôt7 ‚Äô, ‚Äôval ‚Äô))
if s7:
s8_ = util . do_sql (conn , " SELECT *
FROM t8", {})
s8 = util . do_sql (conn , " SELECT *
FROM t8 WHERE id = :x", {"x":
sys . argv [8]})
print ( util . get_data (s8 , ‚Äôt8 ‚Äô, ‚Äôval ‚Äô
))
Version 9:
import sys
import active_utils as util
290
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s1_ = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t1 WHERE id = :x", {"x":
sys . argv [1]})
print ( util . get_data (s1 , ‚Äôt1 ‚Äô, ‚Äôval ‚Äô))
if s1:
s2_ = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2 WHERE id = :x", {"
x": sys . argv [2]})
print ( util . get_data (s2 , ‚Äôt2 ‚Äô, ‚Äôval ‚Äô))
if s2:
s3_ = util . do_sql (conn , " SELECT * FROM t3", {})
s3 = util . do_sql (conn , " SELECT * FROM t3 WHERE id = :x"
, {"x": sys . argv [3]})
print ( util . get_data (s3 , ‚Äôt3 ‚Äô, ‚Äôval ‚Äô))
if s3:
s4_ = util . do_sql (conn , " SELECT * FROM t4", {})
s4 = util . do_sql (conn , " SELECT * FROM t4 WHERE id =
:x", {"x": sys . argv [4]})
print ( util . get_data (s4 , ‚Äôt4 ‚Äô, ‚Äôval ‚Äô))
if s4:
s5_ = util . do_sql (conn , " SELECT * FROM t5", {})
s5 = util . do_sql (conn , " SELECT * FROM t5 WHERE
id = :x", {"x": sys . argv [5]})
print ( util . get_data (s5 , ‚Äôt5 ‚Äô, ‚Äôval ‚Äô))
if s5:
s6_ = util . do_sql (conn , " SELECT * FROM t6",
{})
s6 = util . do_sql (conn , " SELECT * FROM t6
WHERE id = :x", {"x": sys . argv [6]})
print ( util . get_data (s6 , ‚Äôt6 ‚Äô, ‚Äôval ‚Äô))
if s6:
s7_ = util . do_sql (conn , " SELECT * FROM
t7", {})
s7 = util . do_sql (conn , " SELECT * FROM
t7 WHERE id = :x", {"x": sys . argv
291
[7]})
print ( util . get_data (s7 , ‚Äôt7 ‚Äô, ‚Äôval ‚Äô))
if s7:
s8_ = util . do_sql (conn , " SELECT *
FROM t8", {})
s8 = util . do_sql (conn , " SELECT *
FROM t8 WHERE id = :x", {"x":
sys . argv [8]})
print ( util . get_data (s8 , ‚Äôt8 ‚Äô, ‚Äôval ‚Äô
))
if s8:
s9_ = util . do_sql (conn , " SELECT
* FROM t9", {})
s9 = util . do_sql (conn , " SELECT
* FROM t9 WHERE id = :x", {"
x": sys . argv [9]})
print ( util . get_data (s9 , ‚Äôt9 ‚Äô, ‚Äô
val ‚Äô))
292
Appendix C
Synthetic Commands for Evaluating
Shear
C.1 Repetitions
C.1.1 Command repeat_2
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s0 = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
C.1.2 Command repeat_3
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s0 = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
s3 = util . do_sql (conn , " SELECT * FROM t2", {})
C.1.3 Command repeat_4
293
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s0 = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
s3 = util . do_sql (conn , " SELECT * FROM t2", {})
s4 = util . do_sql (conn , " SELECT * FROM t2", {})
C.1.4 Command repeat_5
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s0 = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
s3 = util . do_sql (conn , " SELECT * FROM t2", {})
s4 = util . do_sql (conn , " SELECT * FROM t2", {})
s5 = util . do_sql (conn , " SELECT * FROM t2", {})
C.2 Nested Loops
C.2.1 Command nest
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s0 = util . do_sql (conn , " SELECT * FROM t0", {})
for row0 in s0:
s1 = util . do_sql (conn , " SELECT * FROM t1", {})
for row1 in s1:
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
C.3 Consecutive Loops
C.3.1 Command after_2
294
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s0 = util . do_sql (conn , " SELECT * FROM t1", {})
for row0 in s0:
s1 = util . do_sql (conn , " SELECT * FROM t0", {})
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
for row2 in s2:
s3 = util . do_sql (conn , " SELECT * FROM t0", {})
C.3.2 Command after_3
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s0 = util . do_sql (conn , " SELECT * FROM t1", {})
for row0 in s0:
s1 = util . do_sql (conn , " SELECT * FROM t0", {})
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
for row2 in s2:
s3 = util . do_sql (conn , " SELECT * FROM t0", {})
s4 = util . do_sql (conn , " SELECT * FROM t3", {})
for row4 in s4:
s5 = util . do_sql (conn , " SELECT * FROM t0", {})
C.3.3 Command after_4
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s0 = util . do_sql (conn , " SELECT * FROM t1", {})
for row0 in s0:
s1 = util . do_sql (conn , " SELECT * FROM t0", {})
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
for row2 in s2:
s3 = util . do_sql (conn , " SELECT * FROM t0", {})
s4 = util . do_sql (conn , " SELECT * FROM t3", {})
for row4 in s4:
s5 = util . do_sql (conn , " SELECT * FROM t0", {})
s6 = util . do_sql (conn , " SELECT * FROM t4", {})
295
for row6 in s6:
s7 = util . do_sql (conn , " SELECT * FROM t0", {})
C.3.4 Command after_5
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
s0 = util . do_sql (conn , " SELECT * FROM t1", {})
for row0 in s0:
s1 = util . do_sql (conn , " SELECT * FROM t0", {})
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
for row2 in s2:
s3 = util . do_sql (conn , " SELECT * FROM t0", {})
s4 = util . do_sql (conn , " SELECT * FROM t3", {})
for row4 in s4:
s5 = util . do_sql (conn , " SELECT * FROM t0", {})
s6 = util . do_sql (conn , " SELECT * FROM t4", {})
for row6 in s6:
s7 = util . do_sql (conn , " SELECT * FROM t0", {})
s8 = util . do_sql (conn , " SELECT * FROM t5", {})
for row8 in s8:
s9 = util . do_sql (conn , " SELECT * FROM t0", {})
C.4 Command example (Section 6.1)
with util . open_database (‚Äô active_test_app ‚Äô) as conn :
tasks1 = util . do_sql (conn , " SELECT * FROM tasks WHERE id = :x",
{"x": sys . argv [1]})
print ( util . get_data ( tasks1 , ‚Äôtasks ‚Äô, ‚Äôtitle ‚Äô))
if util . has_rows ( tasks1 ):
task_assignee = util . get_one_data ( tasks1 , ‚Äôtasks ‚Äô, ‚Äô
assignee_id ‚Äô)
296
comments = util . do_sql (conn , " SELECT * FROM comments WHERE
task_id = :x", {"x": sys . argv [1]})
print ( util . get_data ( comments , ‚Äô comments ‚Äô, ‚Äô content ‚Äô))
for row2 in comments :
comment_commenter = util . get_one_data (row2 , ‚Äô comments ‚Äô,
‚Äô commenter_id ‚Äô)
users1 = util . do_sql (conn , " SELECT * FROM users WHERE
id = :x", {"x": comment_commenter })
print ( util . get_data ( users1 , ‚Äôusers ‚Äô, ‚Äôname ‚Äô))
tasks2 = util . do_sql (conn , " SELECT * FROM tasks WHERE
creator_id = :x", {"x": comment_commenter })
print ( util . get_data ( tasks2 , ‚Äôtasks ‚Äô, ‚Äôtitle ‚Äô))
users2 = util . do_sql (conn , " SELECT * FROM users WHERE id =
:x", {"x": task_assignee })
print ( util . get_data ( users2 , ‚Äôusers ‚Äô, ‚Äôname ‚Äô))
tasks3 = util . do_sql (conn , " SELECT * FROM tasks WHERE
creator_id = :x", {"x": task_assignee })
print ( util . get_data ( tasks3 , ‚Äôtasks ‚Äô, ‚Äôtitle ‚Äô))
297
298
Appendix D
Code Regenerated byShear
D.1 Regenerated Code for RailsCollab Project Man-
ager
D.1.1 Command get_projects_id_messages
def get_projects_id_messages (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s2 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.* FROM ‚Äòprojects ‚Äò
INNER JOIN ‚Äòpeople ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = ‚Äòpeople ‚Äò. ‚Äò
project_id ‚Äò WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ( projects
. completed_on IS NULL ) ORDER BY projects . priority ASC ,
projects . name ASC ", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s3 = util . do_sql (conn , " SELECT ‚Äò time_records ‚Äò.* FROM ‚Äò
time_records ‚Äò WHERE ‚Äò time_records ‚Äò. ‚Äò assigned_to_user_id
299
‚Äò = :x0 AND ( start_date IS NOT NULL AND done_date IS
NULL )", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s4 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.* FROM ‚Äòprojects
‚Äò WHERE ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs
[1]})
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
if util . has_rows (s4):
s5 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM ‚Äò
companies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {
‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô company_id ‚Äô)})
outputs . extend ( util . get_data (s5 , ‚Äô companies ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äô companies ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äô companies ‚Äô, ‚Äô homepage
‚Äô))
if util . has_rows (s5):
s6 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM
‚Äòcompanies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò IS NULL
LIMIT 1", {})
s7 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
messages ‚Äò WHERE ‚Äòmessages ‚Äò. ‚Äò project_id ‚Äò = :x0",
{‚Äôx0 ‚Äô: inputs [1]})
s8 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
messages ‚Äò WHERE ‚Äòmessages ‚Äò. ‚Äò project_id ‚Äò = :x0",
{‚Äôx0 ‚Äô: inputs [1]})
if util . has_rows (s8):
s18 = util . do_sql (conn , " SELECT ‚Äòmessages ‚Äò.*
FROM ‚Äòmessages ‚Äò WHERE ‚Äòmessages ‚Äò. ‚Äò
project_id ‚Äò = :x0 ORDER BY created_on DESC
LIMIT 10 OFFSET 0", {‚Äôx0 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s18 , ‚Äô messages ‚Äô, ‚Äô
id ‚Äô))
outputs . extend ( util . get_data (s18 , ‚Äô messages ‚Äô, ‚Äô
project_id ‚Äô))
outputs . extend ( util . get_data (s18 , ‚Äô messages ‚Äô, ‚Äô
title ‚Äô))
300
outputs . extend ( util . get_data (s18 , ‚Äô messages ‚Äô, ‚Äô
text ‚Äô))
s18_all = s18
for s18 in s18_all :
s19 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.*
FROM ‚Äòusers ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s18 ,
‚Äô messages ‚Äô, ‚Äô created_by_id ‚Äô)})
outputs . extend ( util . get_data (s19 , ‚Äôusers ‚Äô,
‚Äôid ‚Äô))
outputs . extend ( util . get_data (s19 , ‚Äôusers ‚Äô,
‚Äô display_name ‚Äô))
s20 = util . do_sql (conn , " SELECT ‚Äòprojects
‚Äò.* FROM ‚Äòprojects ‚Äò WHERE ‚Äòprojects ‚Äò. ‚Äò
id ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s18 , ‚Äô messages ‚Äô, ‚Äô
project_id ‚Äô)})
outputs . extend ( util . get_data (s20 , ‚Äô projects
‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s20 , ‚Äô projects
‚Äô, ‚Äôname ‚Äô))
s21 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.*
FROM ‚Äòpeople ‚Äò WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1", {‚Äôx0 ‚Äô: util
. get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
util . get_one_data (s18 , ‚Äô messages ‚Äô, ‚Äô
project_id ‚Äô)})
outputs . extend ( util . get_data (s21 , ‚Äôpeople ‚Äô,
‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s21 , ‚Äôpeople ‚Äô,
‚Äô user_id ‚Äô))
s22 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.*
FROM ‚Äòpeople ‚Äò WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò
= :x0 AND ‚Äòpeople ‚Äò. ‚Äò project_id ‚Äò = :x1",
{‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô
id ‚Äô), ‚Äôx1 ‚Äô: util . get_one_data (s18 , ‚Äô
301
messages ‚Äô, ‚Äô project_id ‚Äô)})
outputs . extend ( util . get_data (s22 , ‚Äôpeople ‚Äô,
‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s22 , ‚Äôpeople ‚Äô,
‚Äô user_id ‚Äô))
if util . has_rows ( s22 ):
pass
else :
s23 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :x1)
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (
s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s18 , ‚Äô messages ‚Äô, ‚Äô
project_id ‚Äô)})
s24 = util . do_sql (conn , " SELECT ‚Äòpeople
‚Äò.* FROM ‚Äòpeople ‚Äò WHERE ‚Äòpeople ‚Äò. ‚Äò
user_id ‚Äò = :x0 AND ‚Äòpeople ‚Äò. ‚Äò
project_id ‚Äò = :x1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1
‚Äô: util . get_one_data (s18 , ‚Äô messages ‚Äô
, ‚Äô project_id ‚Äô)})
s18 = s18_all
s25 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.*
FROM ‚Äòpeople ‚Äò WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (s25 , ‚Äôpeople ‚Äô, ‚Äô
project_id ‚Äô))
outputs . extend ( util . get_data (s25 , ‚Äôpeople ‚Äô, ‚Äô
user_id ‚Äô))
s26 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
messages ‚Äò WHERE ‚Äòmessages ‚Äò. ‚Äò project_id ‚Äò = :
x0 AND ‚Äòmessages ‚Äò. ‚Äò is_important ‚Äò = 1", {‚Äôx0 ‚Äô
: inputs [1]})
302
s27 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
categories ‚Äò WHERE ‚Äòcategories ‚Äò. ‚Äò project_id ‚Äò
= :x0", {‚Äôx0 ‚Äô: inputs [1]})
if util . has_rows ( s27 ):
s28 = util . do_sql (conn , " SELECT ‚Äòcategories
‚Äò.* FROM ‚Äòcategories ‚Äò WHERE ‚Äòcategories
‚Äò. ‚Äò project_id ‚Äò = :x0", {‚Äôx0 ‚Äô: inputs
[1]})
outputs . extend ( util . get_data (s28 , ‚Äô
categories ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s28 , ‚Äô
categories ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s28 , ‚Äô
categories ‚Äô, ‚Äôname ‚Äô))
s28_all = s28
for s28 in s28_all :
s29 = util . do_sql (conn , " SELECT ‚Äò
projects ‚Äò.* FROM ‚Äòprojects ‚Äò WHERE ‚Äò
projects ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s28 , ‚Äô categories
‚Äô, ‚Äô project_id ‚Äô)})
outputs . extend ( util . get_data (s29 , ‚Äô
projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s29 , ‚Äô
projects ‚Äô, ‚Äôname ‚Äô))
s30 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :x1)
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (
s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s28 , ‚Äô categories ‚Äô, ‚Äô
project_id ‚Äô)})
outputs . extend ( util . get_data (s30 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s30 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
303
s31 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :x1)
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (
s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s28 , ‚Äô categories ‚Äô, ‚Äô
project_id ‚Äô)})
outputs . extend ( util . get_data (s31 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s31 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
if util . has_rows ( s31 ):
pass
else :
s32 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: util . get_one_data (s28 , ‚Äô
categories ‚Äô, ‚Äô project_id ‚Äô)})
s33 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: util . get_one_data (s28 , ‚Äô
categories ‚Äô, ‚Äô project_id ‚Äô)})
s28 = s28_all
pass
else :
pass
else :
s9 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.* FROM
‚Äòpeople ‚Äò WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
304
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (s9 , ‚Äô people ‚Äô, ‚Äô
project_id ‚Äô))
outputs . extend ( util . get_data (s9 , ‚Äô people ‚Äô, ‚Äô
user_id ‚Äô))
s10 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
messages ‚Äò WHERE ‚Äòmessages ‚Äò. ‚Äò project_id ‚Äò = :
x0 AND ‚Äòmessages ‚Äò. ‚Äò is_important ‚Äò = 1", {‚Äôx0 ‚Äô
: inputs [1]})
s11 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
categories ‚Äò WHERE ‚Äòcategories ‚Äò. ‚Äò project_id ‚Äò
= :x0", {‚Äôx0 ‚Äô: inputs [1]})
if util . has_rows ( s11 ):
s12 = util . do_sql (conn , " SELECT ‚Äòcategories
‚Äò.* FROM ‚Äòcategories ‚Äò WHERE ‚Äòcategories
‚Äò. ‚Äò project_id ‚Äò = :x0", {‚Äôx0 ‚Äô: inputs
[1]})
outputs . extend ( util . get_data (s12 , ‚Äô
categories ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s12 , ‚Äô
categories ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s12 , ‚Äô
categories ‚Äô, ‚Äôname ‚Äô))
s12_all = s12
for s12 in s12_all :
s13 = util . do_sql (conn , " SELECT ‚Äò
projects ‚Äò.* FROM ‚Äòprojects ‚Äò WHERE ‚Äò
projects ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s12 , ‚Äô categories
‚Äô, ‚Äô project_id ‚Äô)})
outputs . extend ( util . get_data (s13 , ‚Äô
projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s13 , ‚Äô
projects ‚Äô, ‚Äôname ‚Äô))
305
s14 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :x1)
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (
s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s12 , ‚Äô categories ‚Äô, ‚Äô
project_id ‚Äô)})
outputs . extend ( util . get_data (s14 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s14 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
s15 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :x1)
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (
s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s12 , ‚Äô categories ‚Äô, ‚Äô
project_id ‚Äô)})
outputs . extend ( util . get_data (s15 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s15 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
if util . has_rows ( s15 ):
pass
else :
s16 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: util . get_one_data (s12 , ‚Äô
categories ‚Äô, ‚Äô project_id ‚Äô)})
s17 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
306
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: util . get_one_data (s12 , ‚Äô
categories ‚Äô, ‚Äô project_id ‚Äô)})
s12 = s12_all
pass
else :
pass
else :
pass
else :
pass
else :
pass
return util . add_warnings ( outputs )
D.1.2 Command get_projects_id_messages_id
def get_projects_id_messages_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s2 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.* FROM ‚Äòprojects ‚Äò
INNER JOIN ‚Äòpeople ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = ‚Äòpeople ‚Äò. ‚Äò
project_id ‚Äò WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ( projects
. completed_on IS NULL ) ORDER BY projects . priority ASC ,
projects . name ASC ", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s3 = util . do_sql (conn , " SELECT ‚Äò time_records ‚Äò.* FROM ‚Äò
time_records ‚Äò WHERE ‚Äò time_records ‚Äò. ‚Äò assigned_to_user_id
‚Äò = :x0 AND ( start_date IS NOT NULL AND done_date IS
307
NULL )", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s4 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.* FROM ‚Äòprojects
‚Äò WHERE ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs
[1]})
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
if util . has_rows (s4):
s5 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM ‚Äò
companies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {
‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô company_id ‚Äô)})
if util . has_rows (s5):
s6 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM
‚Äòcompanies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò IS NULL
LIMIT 1", {})
s7 = util . do_sql (conn , " SELECT ‚Äòmessages ‚Äò.* FROM ‚Äò
messages ‚Äò WHERE ‚Äòmessages ‚Äò. ‚Äò project_id ‚Äò = :x0
AND ‚Äòmessages ‚Äò. ‚Äòid ‚Äò = :x1 ORDER BY created_on
DESC LIMIT 1", {‚Äôx0 ‚Äô: inputs [1] , ‚Äôx1 ‚Äô: inputs
[2]})
outputs . extend ( util . get_data (s7 , ‚Äô messages ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äô messages ‚Äô, ‚Äô
project_id ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äô messages ‚Äô, ‚Äôtitle
‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äô messages ‚Äô, ‚Äôtext ‚Äô
))
if util . has_rows (s7):
s8 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò WHERE ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x0
LIMIT 1", {‚Äôx0 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s8 , ‚Äô projects ‚Äô, ‚Äô
id ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äô projects ‚Äô, ‚Äô
name ‚Äô))
s9 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.* FROM
‚Äòpeople ‚Äò WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
308
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (s9 , ‚Äô people ‚Äô, ‚Äô
project_id ‚Äô))
outputs . extend ( util . get_data (s9 , ‚Äô people ‚Äô, ‚Äô
user_id ‚Äô))
if util . has_rows (s9):
s11 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.*
FROM ‚Äòusers ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s7 , ‚Äô
messages ‚Äô, ‚Äô created_by_id ‚Äô)})
outputs . extend ( util . get_data (s11 , ‚Äôusers ‚Äô,
‚Äôid ‚Äô))
outputs . extend ( util . get_data (s11 , ‚Äôusers ‚Äô,
‚Äô display_name ‚Äô))
s12 = util . do_sql (conn , " SELECT ‚Äò
milestones ‚Äò.* FROM ‚Äòmilestones ‚Äò WHERE ‚Äò
milestones ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô:
util . get_one_data (s7 , ‚Äô messages ‚Äô, ‚Äô
milestone_id ‚Äô)})
outputs . extend ( util . get_data (s12 , ‚Äô
milestones ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s12 , ‚Äô
milestones ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s12 , ‚Äô
milestones ‚Äô, ‚Äôname ‚Äô))
s13 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.*
FROM ‚Äòpeople ‚Äò WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1", {‚Äôx0 ‚Äô: util
. get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (s13 , ‚Äôpeople ‚Äô,
‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s13 , ‚Äôpeople ‚Äô,
‚Äô user_id ‚Äô))
309
s14 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.*
FROM ‚Äòpeople ‚Äò WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1", {‚Äôx0 ‚Äô: util
. get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (s14 , ‚Äôpeople ‚Äô,
‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s14 , ‚Äôpeople ‚Äô,
‚Äô user_id ‚Äô))
s15 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.*
FROM ‚Äòpeople ‚Äò WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1", {‚Äôx0 ‚Äô: util
. get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (s15 , ‚Äôpeople ‚Äô,
‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s15 , ‚Äôpeople ‚Äô,
‚Äô user_id ‚Äô))
s16 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.*
FROM ‚Äòpeople ‚Äò WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1", {‚Äôx0 ‚Äô: util
. get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (s16 , ‚Äôpeople ‚Äô,
‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s16 , ‚Äôpeople ‚Äô,
‚Äô user_id ‚Äô))
s17 = util . do_sql (conn , " SELECT ‚Äò
categories ‚Äò.* FROM ‚Äòcategories ‚Äò WHERE ‚Äò
categories ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô:
util . get_one_data (s7 , ‚Äô messages ‚Äô, ‚Äô
category_id ‚Äô)})
outputs . extend ( util . get_data (s17 , ‚Äô
categories ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s17 , ‚Äô
categories ‚Äô, ‚Äôname ‚Äô))
310
s18 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.*
FROM ‚Äòusers ‚Äò INNER JOIN ‚Äò
message_subscriptions ‚Äò ON ‚Äòusers ‚Äò. ‚Äòid ‚Äò =
‚Äò message_subscriptions ‚Äò. ‚Äò user_id ‚Äò WHERE
‚Äò message_subscriptions ‚Äò. ‚Äò message_id ‚Äò =
:x0", {‚Äôx0 ‚Äô: inputs [2]})
outputs . extend ( util . get_data (s18 , ‚Äôusers ‚Äô,
‚Äôid ‚Äô))
outputs . extend ( util . get_data (s18 , ‚Äôusers ‚Äô,
‚Äô display_name ‚Äô))
s19 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.*
FROM ‚Äòpeople ‚Äò WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1", {‚Äôx0 ‚Äô: util
. get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (s19 , ‚Äôpeople ‚Äô,
‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s19 , ‚Äôpeople ‚Äô,
‚Äô user_id ‚Äô))
s20 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.*
FROM ‚Äòpeople ‚Äò WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1", {‚Äôx0 ‚Äô: util
. get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (s20 , ‚Äôpeople ‚Äô,
‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s20 , ‚Äôpeople ‚Äô,
‚Äô user_id ‚Äô))
else :
s10 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.*
FROM ‚Äòpeople ‚Äò WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò
= :x0 AND ‚Äòpeople ‚Äò. ‚Äò project_id ‚Äò = :x1",
{‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô
id ‚Äô), ‚Äôx1 ‚Äô: inputs [1]})
else :
pass
311
else :
pass
else :
pass
else :
pass
return util . add_warnings ( outputs )
D.1.3 Command get_projects_id_messages_display_list
def get_projects_id_messages_display_list (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s2 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.* FROM ‚Äòprojects ‚Äò
INNER JOIN ‚Äòpeople ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = ‚Äòpeople ‚Äò. ‚Äò
project_id ‚Äò WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ( projects
. completed_on IS NULL ) ORDER BY projects . priority ASC ,
projects . name ASC ", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s3 = util . do_sql (conn , " SELECT ‚Äò time_records ‚Äò.* FROM ‚Äò
time_records ‚Äò WHERE ‚Äò time_records ‚Äò. ‚Äò assigned_to_user_id
‚Äò = :x0 AND ( start_date IS NOT NULL AND done_date IS
NULL )", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s4 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.* FROM ‚Äòprojects
‚Äò WHERE ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs
[1]})
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
if util . has_rows (s4):
312
s5 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM ‚Äò
companies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {
‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô company_id ‚Äô)})
outputs . extend ( util . get_data (s5 , ‚Äô companies ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äô companies ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äô companies ‚Äô, ‚Äô homepage
‚Äô))
if util . has_rows (s5):
s6 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM
‚Äòcompanies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò IS NULL
LIMIT 1", {})
s7 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
messages ‚Äò WHERE ‚Äòmessages ‚Äò. ‚Äò project_id ‚Äò = :x0",
{‚Äôx0 ‚Äô: inputs [1]})
s8 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
messages ‚Äò WHERE ‚Äòmessages ‚Äò. ‚Äò project_id ‚Äò = :x0",
{‚Äôx0 ‚Äô: inputs [1]})
if util . has_rows (s8):
s18 = util . do_sql (conn , " SELECT ‚Äòmessages ‚Äò.*
FROM ‚Äòmessages ‚Äò WHERE ‚Äòmessages ‚Äò. ‚Äò
project_id ‚Äò = :x0 ORDER BY created_on DESC
LIMIT 10 OFFSET 0", {‚Äôx0 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s18 , ‚Äô messages ‚Äô, ‚Äô
id ‚Äô))
outputs . extend ( util . get_data (s18 , ‚Äô messages ‚Äô, ‚Äô
project_id ‚Äô))
outputs . extend ( util . get_data (s18 , ‚Äô messages ‚Äô, ‚Äô
title ‚Äô))
s18_all = s18
for s18 in s18_all :
s19 = util . do_sql (conn , " SELECT ‚Äòprojects
‚Äò.* FROM ‚Äòprojects ‚Äò WHERE ‚Äòprojects ‚Äò. ‚Äò
id ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s18 , ‚Äô messages ‚Äô, ‚Äô
project_id ‚Äô)})
313
outputs . extend ( util . get_data (s19 , ‚Äô projects
‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s19 , ‚Äô projects
‚Äô, ‚Äôname ‚Äô))
s20 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.*
FROM ‚Äòpeople ‚Äò WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1", {‚Äôx0 ‚Äô: util
. get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
util . get_one_data (s18 , ‚Äô messages ‚Äô, ‚Äô
project_id ‚Äô)})
outputs . extend ( util . get_data (s20 , ‚Äôpeople ‚Äô,
‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s20 , ‚Äôpeople ‚Äô,
‚Äô user_id ‚Äô))
s21 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.*
FROM ‚Äòpeople ‚Äò WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò
= :x0 AND ‚Äòpeople ‚Äò. ‚Äò project_id ‚Äò = :x1",
{‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô
id ‚Äô), ‚Äôx1 ‚Äô: util . get_one_data (s18 , ‚Äô
messages ‚Äô, ‚Äô project_id ‚Äô)})
outputs . extend ( util . get_data (s21 , ‚Äôpeople ‚Äô,
‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s21 , ‚Äôpeople ‚Äô,
‚Äô user_id ‚Äô))
if util . has_rows ( s21 ):
s25 = util . do_sql (conn , " SELECT ‚Äòusers
‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò
= :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s18 , ‚Äô messages ‚Äô, ‚Äô
created_by_id ‚Äô)})
outputs . extend ( util . get_data (s25 , ‚Äô
users ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s25 , ‚Äô
users ‚Äô, ‚Äô display_name ‚Äô))
else :
314
s22 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :x1)
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (
s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s18 , ‚Äô messages ‚Äô, ‚Äô
project_id ‚Äô)})
s23 = util . do_sql (conn , " SELECT ‚Äòpeople
‚Äò.* FROM ‚Äòpeople ‚Äò WHERE ‚Äòpeople ‚Äò. ‚Äò
user_id ‚Äò = :x0 AND ‚Äòpeople ‚Äò. ‚Äò
project_id ‚Äò = :x1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1
‚Äô: util . get_one_data (s18 , ‚Äô messages ‚Äô
, ‚Äô project_id ‚Äô)})
s24 = util . do_sql (conn , " SELECT ‚Äòusers
‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò
= :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s18 , ‚Äô messages ‚Äô, ‚Äô
created_by_id ‚Äô)})
outputs . extend ( util . get_data (s24 , ‚Äô
users ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s24 , ‚Äô
users ‚Äô, ‚Äô display_name ‚Äô))
s18 = s18_all
s26 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.*
FROM ‚Äòpeople ‚Äò WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (s26 , ‚Äôpeople ‚Äô, ‚Äô
project_id ‚Äô))
outputs . extend ( util . get_data (s26 , ‚Äôpeople ‚Äô, ‚Äô
user_id ‚Äô))
s27 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
messages ‚Äò WHERE ‚Äòmessages ‚Äò. ‚Äò project_id ‚Äò = :
x0 AND ‚Äòmessages ‚Äò. ‚Äò is_important ‚Äò = 1", {‚Äôx0 ‚Äô
315
: inputs [1]})
s28 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
categories ‚Äò WHERE ‚Äòcategories ‚Äò. ‚Äò project_id ‚Äò
= :x0", {‚Äôx0 ‚Äô: inputs [1]})
if util . has_rows ( s28 ):
s29 = util . do_sql (conn , " SELECT ‚Äòcategories
‚Äò.* FROM ‚Äòcategories ‚Äò WHERE ‚Äòcategories
‚Äò. ‚Äò project_id ‚Äò = :x0", {‚Äôx0 ‚Äô: inputs
[1]})
outputs . extend ( util . get_data (s29 , ‚Äô
categories ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s29 , ‚Äô
categories ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s29 , ‚Äô
categories ‚Äô, ‚Äôname ‚Äô))
s29_all = s29
for s29 in s29_all :
s30 = util . do_sql (conn , " SELECT ‚Äò
projects ‚Äò.* FROM ‚Äòprojects ‚Äò WHERE ‚Äò
projects ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s29 , ‚Äô categories
‚Äô, ‚Äô project_id ‚Äô)})
outputs . extend ( util . get_data (s30 , ‚Äô
projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s30 , ‚Äô
projects ‚Äô, ‚Äôname ‚Äô))
s31 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :x1)
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (
s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s29 , ‚Äô categories ‚Äô, ‚Äô
project_id ‚Äô)})
outputs . extend ( util . get_data (s31 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
316
outputs . extend ( util . get_data (s31 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
s32 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :x1)
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (
s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s29 , ‚Äô categories ‚Äô, ‚Äô
project_id ‚Äô)})
outputs . extend ( util . get_data (s32 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s32 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
if util . has_rows ( s32 ):
pass
else :
s33 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: util . get_one_data (s29 , ‚Äô
categories ‚Äô, ‚Äô project_id ‚Äô)})
s34 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: util . get_one_data (s29 , ‚Äô
categories ‚Äô, ‚Äô project_id ‚Äô)})
s29 = s29_all
pass
else :
pass
else :
317
s9 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.* FROM
‚Äòpeople ‚Äò WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (s9 , ‚Äô people ‚Äô, ‚Äô
project_id ‚Äô))
outputs . extend ( util . get_data (s9 , ‚Äô people ‚Äô, ‚Äô
user_id ‚Äô))
s10 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
messages ‚Äò WHERE ‚Äòmessages ‚Äò. ‚Äò project_id ‚Äò = :
x0 AND ‚Äòmessages ‚Äò. ‚Äò is_important ‚Äò = 1", {‚Äôx0 ‚Äô
: inputs [1]})
s11 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
categories ‚Äò WHERE ‚Äòcategories ‚Äò. ‚Äò project_id ‚Äò
= :x0", {‚Äôx0 ‚Äô: inputs [1]})
if util . has_rows ( s11 ):
s12 = util . do_sql (conn , " SELECT ‚Äòcategories
‚Äò.* FROM ‚Äòcategories ‚Äò WHERE ‚Äòcategories
‚Äò. ‚Äò project_id ‚Äò = :x0", {‚Äôx0 ‚Äô: inputs
[1]})
outputs . extend ( util . get_data (s12 , ‚Äô
categories ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s12 , ‚Äô
categories ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s12 , ‚Äô
categories ‚Äô, ‚Äôname ‚Äô))
s12_all = s12
for s12 in s12_all :
s13 = util . do_sql (conn , " SELECT ‚Äò
projects ‚Äò.* FROM ‚Äòprojects ‚Äò WHERE ‚Äò
projects ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s12 , ‚Äô categories
‚Äô, ‚Äô project_id ‚Äô)})
outputs . extend ( util . get_data (s13 , ‚Äô
projects ‚Äô, ‚Äôid ‚Äô))
318
outputs . extend ( util . get_data (s13 , ‚Äô
projects ‚Äô, ‚Äôname ‚Äô))
s14 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :x1)
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (
s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s12 , ‚Äô categories ‚Äô, ‚Äô
project_id ‚Äô)})
outputs . extend ( util . get_data (s14 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s14 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
s15 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :x1)
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (
s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s12 , ‚Äô categories ‚Äô, ‚Äô
project_id ‚Äô)})
outputs . extend ( util . get_data (s15 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s15 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
if util . has_rows ( s15 ):
pass
else :
s16 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: util . get_one_data (s12 , ‚Äô
categories ‚Äô, ‚Äô project_id ‚Äô)})
s17 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
319
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: util . get_one_data (s12 , ‚Äô
categories ‚Äô, ‚Äô project_id ‚Äô)})
s12 = s12_all
pass
else :
pass
else :
pass
else :
pass
else :
pass
return util . add_warnings ( outputs )
D.1.4 Command get_projects_id_times
For this command we use a modified version of RailsCollab, where we fixed a 500
error when a task‚Äôs task list ID does not match any records in the database. Specifi-
cally, we changed the statement ‚Äúurl_for hash_for_task_path(:id => self.id,
:active_project => self.project_id, :only_path => host.nil?, :host => host)‚Äù
into‚Äú url_for hash_for_task_path(:id => self.id, :active_project => self.project_id,
:only_path => host.nil?, :host => host) rescue nil‚Äù inthefile app/models/task.rb.
def get_projects_id_times (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
320
s2 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.* FROM ‚Äòprojects ‚Äò
INNER JOIN ‚Äòpeople ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = ‚Äòpeople ‚Äò. ‚Äò
project_id ‚Äò WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ( projects
. completed_on IS NULL ) ORDER BY projects . priority ASC ,
projects . name ASC ", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s3 = util . do_sql (conn , " SELECT ‚Äò time_records ‚Äò.* FROM ‚Äò
time_records ‚Äò WHERE ‚Äò time_records ‚Äò. ‚Äò assigned_to_user_id
‚Äò = :x0 AND ( start_date IS NOT NULL AND done_date IS
NULL )", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s4 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.* FROM ‚Äòprojects
‚Äò WHERE ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs
[1]})
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
if util . has_rows (s4):
s5 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM ‚Äò
companies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {
‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô company_id ‚Äô)})
outputs . extend ( util . get_data (s5 , ‚Äô companies ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äô companies ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äô companies ‚Äô, ‚Äô homepage
‚Äô))
if util . has_rows (s5):
s6 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM
‚Äòcompanies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò IS NULL
LIMIT 1", {})
s7 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
time_records ‚Äò WHERE ‚Äò time_records ‚Äò. ‚Äò project_id ‚Äò
= :x0", {‚Äôx0 ‚Äô: inputs [1]})
s8 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
time_records ‚Äò WHERE ‚Äò time_records ‚Äò. ‚Äò project_id ‚Äò
= :x0", {‚Äôx0 ‚Äô: inputs [1]})
if util . has_rows (s8):
s10 = util . do_sql (conn , " SELECT ‚Äò time_records
‚Äò.* FROM ‚Äò time_records ‚Äò WHERE ‚Äò time_records
321
‚Äò. ‚Äò project_id ‚Äò = :x0 ORDER BY created_on
DESC LIMIT 10 OFFSET 0", {‚Äôx0 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s10 , ‚Äô time_records
‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s10 , ‚Äô time_records
‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s10 , ‚Äô time_records
‚Äô, ‚Äôname ‚Äô))
s10_all = s10
for s10 in s10_all :
s11 = util . do_sql (conn , " SELECT ‚Äòcompanies
‚Äò.* FROM ‚Äòcompanies ‚Äò WHERE ‚Äòcompanies
‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s10 , ‚Äô time_records ‚Äô, ‚Äô
assigned_to_company_id ‚Äô)})
outputs . extend ( util . get_data (s11 , ‚Äô
companies ‚Äô, ‚Äôname ‚Äô))
if util . has_rows ( s11 ):
s25 = util . do_sql (conn , " SELECT ‚Äòtasks
‚Äò.* FROM ‚Äòtasks ‚Äò WHERE ‚Äòtasks ‚Äò. ‚Äòid ‚Äò
= :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s10 , ‚Äô time_records ‚Äô, ‚Äô
task_id ‚Äô)})
if util . has_rows ( s25 ):
s31 = util . do_sql (conn , " SELECT ‚Äò
task_lists ‚Äò.* FROM ‚Äòtask_lists ‚Äò
WHERE ‚Äòtask_lists ‚Äò. ‚Äòid ‚Äò = :x0
LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s25 , ‚Äôtasks ‚Äô, ‚Äô
task_list_id ‚Äô)})
outputs . extend ( util . get_data (s31 , ‚Äô
task_lists ‚Äô, ‚Äô project_id ‚Äô))
s32 = util . do_sql (conn , " SELECT ‚Äò
projects ‚Äò.* FROM ‚Äòprojects ‚Äò
WHERE ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x0
LIMIT 1", {‚Äôx0 ‚Äô: util .
322
get_one_data (s10 , ‚Äô time_records ‚Äô
, ‚Äô project_id ‚Äô)})
outputs . extend ( util . get_data (s32 , ‚Äô
projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s32 , ‚Äô
projects ‚Äô, ‚Äôname ‚Äô))
s33 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: util . get_one_data (s10 , ‚Äô
time_records ‚Äô, ‚Äô project_id ‚Äô)})
outputs . extend ( util . get_data (s33 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s33 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
s34 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE ‚Äò
people ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äò
people ‚Äò. ‚Äò project_id ‚Äò = :x1", {‚Äô
x0 ‚Äô: util . get_one_data (s0 , ‚Äô
users ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s10 , ‚Äô time_records ‚Äô
, ‚Äô project_id ‚Äô)})
outputs . extend ( util . get_data (s34 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s34 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
if util . has_rows ( s34 ):
pass
else :
s35 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1",
323
{‚Äôx0 ‚Äô: util . get_one_data (s0 ,
‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s10 , ‚Äô
time_records ‚Äô, ‚Äô project_id ‚Äô)
})
s36 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò = :
x0 AND ‚Äòpeople ‚Äò. ‚Äò project_id ‚Äò
= :x1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô
id ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s10 , ‚Äô
time_records ‚Äô, ‚Äô project_id ‚Äô)
})
else :
s26 = util . do_sql (conn , " SELECT ‚Äò
projects ‚Äò.* FROM ‚Äòprojects ‚Äò
WHERE ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x0
LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s10 , ‚Äô time_records ‚Äô
, ‚Äô project_id ‚Äô)})
outputs . extend ( util . get_data (s26 , ‚Äô
projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s26 , ‚Äô
projects ‚Äô, ‚Äôname ‚Äô))
s27 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: util . get_one_data (s10 , ‚Äô
time_records ‚Äô, ‚Äô project_id ‚Äô)})
outputs . extend ( util . get_data (s27 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s27 , ‚Äô
324
people ‚Äô, ‚Äô user_id ‚Äô))
s28 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE ‚Äò
people ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äò
people ‚Äò. ‚Äò project_id ‚Äò = :x1", {‚Äô
x0 ‚Äô: util . get_one_data (s0 , ‚Äô
users ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s10 , ‚Äô time_records ‚Äô
, ‚Äô project_id ‚Äô)})
outputs . extend ( util . get_data (s28 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s28 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
if util . has_rows ( s28 ):
pass
else :
s29 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1",
{‚Äôx0 ‚Äô: util . get_one_data (s0 ,
‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s10 , ‚Äô
time_records ‚Äô, ‚Äô project_id ‚Äô)
})
s30 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò = :
x0 AND ‚Äòpeople ‚Äò. ‚Äò project_id ‚Äò
= :x1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô
id ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s10 , ‚Äô
time_records ‚Äô, ‚Äô project_id ‚Äô)
})
else :
325
s12 = util . do_sql (conn , " SELECT ‚Äòusers
‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò
= :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s10 , ‚Äô time_records ‚Äô, ‚Äô
assigned_to_user_id ‚Äô)})
outputs . extend ( util . get_data (s12 , ‚Äô
users ‚Äô, ‚Äô display_name ‚Äô))
s13 = util . do_sql (conn , " SELECT ‚Äòtasks
‚Äò.* FROM ‚Äòtasks ‚Äò WHERE ‚Äòtasks ‚Äò. ‚Äòid ‚Äò
= :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s10 , ‚Äô time_records ‚Äô, ‚Äô
task_id ‚Äô)})
if util . has_rows ( s13 ):
s19 = util . do_sql (conn , " SELECT ‚Äò
task_lists ‚Äò.* FROM ‚Äòtask_lists ‚Äò
WHERE ‚Äòtask_lists ‚Äò. ‚Äòid ‚Äò = :x0
LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s13 , ‚Äôtasks ‚Äô, ‚Äô
task_list_id ‚Äô)})
outputs . extend ( util . get_data (s19 , ‚Äô
task_lists ‚Äô, ‚Äô project_id ‚Äô))
s20 = util . do_sql (conn , " SELECT ‚Äò
projects ‚Äò.* FROM ‚Äòprojects ‚Äò
WHERE ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x0
LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s10 , ‚Äô time_records ‚Äô
, ‚Äô project_id ‚Äô)})
outputs . extend ( util . get_data (s20 , ‚Äô
projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s20 , ‚Äô
projects ‚Äô, ‚Äôname ‚Äô))
s21 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
326
‚Äôx1 ‚Äô: util . get_one_data (s10 , ‚Äô
time_records ‚Äô, ‚Äô project_id ‚Äô)})
outputs . extend ( util . get_data (s21 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s21 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
s22 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE ‚Äò
people ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äò
people ‚Äò. ‚Äò project_id ‚Äò = :x1", {‚Äô
x0 ‚Äô: util . get_one_data (s0 , ‚Äô
users ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s10 , ‚Äô time_records ‚Äô
, ‚Äô project_id ‚Äô)})
outputs . extend ( util . get_data (s22 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s22 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
if util . has_rows ( s22 ):
pass
else :
s23 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1",
{‚Äôx0 ‚Äô: util . get_one_data (s0 ,
‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s10 , ‚Äô
time_records ‚Äô, ‚Äô project_id ‚Äô)
})
s24 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò = :
x0 AND ‚Äòpeople ‚Äò. ‚Äò project_id ‚Äò
= :x1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô
327
id ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s10 , ‚Äô
time_records ‚Äô, ‚Äô project_id ‚Äô)
})
else :
s14 = util . do_sql (conn , " SELECT ‚Äò
projects ‚Äò.* FROM ‚Äòprojects ‚Äò
WHERE ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x0
LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s10 , ‚Äô time_records ‚Äô
, ‚Äô project_id ‚Äô)})
outputs . extend ( util . get_data (s14 , ‚Äô
projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s14 , ‚Äô
projects ‚Äô, ‚Äôname ‚Äô))
s15 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: util . get_one_data (s10 , ‚Äô
time_records ‚Äô, ‚Äô project_id ‚Äô)})
outputs . extend ( util . get_data (s15 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s15 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
s16 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE ‚Äò
people ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äò
people ‚Äò. ‚Äò project_id ‚Äò = :x1", {‚Äô
x0 ‚Äô: util . get_one_data (s0 , ‚Äô
users ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s10 , ‚Äô time_records ‚Äô
, ‚Äô project_id ‚Äô)})
outputs . extend ( util . get_data (s16 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
328
outputs . extend ( util . get_data (s16 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
if util . has_rows ( s16 ):
pass
else :
s17 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1",
{‚Äôx0 ‚Äô: util . get_one_data (s0 ,
‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s10 , ‚Äô
time_records ‚Äô, ‚Äô project_id ‚Äô)
})
s18 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò = :
x0 AND ‚Äòpeople ‚Äò. ‚Äò project_id ‚Äò
= :x1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô
id ‚Äô), ‚Äôx1 ‚Äô: util .
get_one_data (s10 , ‚Äô
time_records ‚Äô, ‚Äô project_id ‚Äô)
})
s10 = s10_all
s37 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.*
FROM ‚Äòpeople ‚Äò WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (s37 , ‚Äôpeople ‚Äô, ‚Äô
project_id ‚Äô))
outputs . extend ( util . get_data (s37 , ‚Äôpeople ‚Äô, ‚Äô
user_id ‚Äô))
else :
s9 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.* FROM
329
‚Äòpeople ‚Äò WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (s9 , ‚Äô people ‚Äô, ‚Äô
project_id ‚Äô))
outputs . extend ( util . get_data (s9 , ‚Äô people ‚Äô, ‚Äô
user_id ‚Äô))
else :
pass
else :
pass
else :
pass
return util . add_warnings ( outputs )
D.1.5 Command get_projects_id_times_id
def get_projects_id_times_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s2 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.* FROM ‚Äòprojects ‚Äò
INNER JOIN ‚Äòpeople ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = ‚Äòpeople ‚Äò. ‚Äò
project_id ‚Äò WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ( projects
. completed_on IS NULL ) ORDER BY projects . priority ASC ,
projects . name ASC ", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s3 = util . do_sql (conn , " SELECT ‚Äò time_records ‚Äò.* FROM ‚Äò
time_records ‚Äò WHERE ‚Äò time_records ‚Äò. ‚Äò assigned_to_user_id
330
‚Äò = :x0 AND ( start_date IS NOT NULL AND done_date IS
NULL )", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s4 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.* FROM ‚Äòprojects
‚Äò WHERE ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs
[1]})
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
if util . has_rows (s4):
s5 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM ‚Äò
companies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {
‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô company_id ‚Äô)})
if util . has_rows (s5):
s6 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM
‚Äòcompanies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò IS NULL
LIMIT 1", {})
s7 = util . do_sql (conn , " SELECT ‚Äò time_records ‚Äò.*
FROM ‚Äò time_records ‚Äò WHERE ‚Äò time_records ‚Äò. ‚Äò
project_id ‚Äò = :x0 AND ‚Äò time_records ‚Äò. ‚Äòid ‚Äò = :x1
LIMIT 1", {‚Äôx0 ‚Äô: inputs [1] , ‚Äôx1 ‚Äô: inputs [2]})
outputs . extend ( util . get_data (s7 , ‚Äô time_records ‚Äô, ‚Äô
id ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äô time_records ‚Äô, ‚Äô
project_id ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äô time_records ‚Äô, ‚Äô
name ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äô time_records ‚Äô, ‚Äô
description ‚Äô))
if util . has_rows (s7):
s8 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò WHERE ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x0
LIMIT 1", {‚Äôx0 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s8 , ‚Äô projects ‚Äô, ‚Äô
id ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äô projects ‚Äô, ‚Äô
name ‚Äô))
s9 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.* FROM
‚Äòpeople ‚Äò WHERE ( user_id = :x0 AND
331
project_id = :x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (s9 , ‚Äô people ‚Äô, ‚Äô
project_id ‚Äô))
outputs . extend ( util . get_data (s9 , ‚Äô people ‚Äô, ‚Äô
user_id ‚Äô))
if util . has_rows (s9):
s37 = util . do_sql (conn , " SELECT ‚Äòcompanies
‚Äò.* FROM ‚Äòcompanies ‚Äò WHERE ‚Äòcompanies
‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s7 , ‚Äô time_records ‚Äô, ‚Äô
assigned_to_company_id ‚Äô)})
outputs . extend ( util . get_data (s37 , ‚Äô
companies ‚Äô, ‚Äôname ‚Äô))
if util . has_rows ( s37 ):
s47 = util . do_sql (conn , " SELECT ‚Äòtasks
‚Äò.* FROM ‚Äòtasks ‚Äò WHERE ‚Äòtasks ‚Äò. ‚Äòid ‚Äò
= :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s7 , ‚Äô time_records ‚Äô, ‚Äô
task_id ‚Äô)})
outputs . extend ( util . get_data (s47 , ‚Äô
tasks ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s47 , ‚Äô
tasks ‚Äô, ‚Äôtext ‚Äô))
if util . has_rows ( s47 ):
s51 = util . do_sql (conn , " SELECT ‚Äò
task_lists ‚Äò.* FROM ‚Äòtask_lists ‚Äò
WHERE ‚Äòtask_lists ‚Äò. ‚Äòid ‚Äò = :x0
LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s47 , ‚Äôtasks ‚Äô, ‚Äô
task_list_id ‚Äô)})
outputs . extend ( util . get_data (s51 , ‚Äô
task_lists ‚Äô, ‚Äô project_id ‚Äô))
if util . has_rows ( s51 ):
332
s52 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1",
{‚Äôx0 ‚Äô: util . get_one_data (s0 ,
‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (
s52 , ‚Äô people ‚Äô, ‚Äô project_id ‚Äô)
)
outputs . extend ( util . get_data (
s52 , ‚Äô people ‚Äô, ‚Äô user_id ‚Äô))
s53 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1",
{‚Äôx0 ‚Äô: util . get_one_data (s0 ,
‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (
s53 , ‚Äô people ‚Äô, ‚Äô project_id ‚Äô)
)
outputs . extend ( util . get_data (
s53 , ‚Äô people ‚Äô, ‚Äô user_id ‚Äô))
s54 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1",
{‚Äôx0 ‚Äô: util . get_one_data (s0 ,
‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (
s54 , ‚Äô people ‚Äô, ‚Äô project_id ‚Äô)
)
outputs . extend ( util . get_data (
s54 , ‚Äô people ‚Äô, ‚Äô user_id ‚Äô))
333
else :
pass
else :
s48 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s48 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s48 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
s49 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s49 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s49 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
s50 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s50 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s50 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
else :
s38 = util . do_sql (conn , " SELECT ‚Äòusers
‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò
334
= :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s7 , ‚Äô time_records ‚Äô, ‚Äô
assigned_to_user_id ‚Äô)})
outputs . extend ( util . get_data (s38 , ‚Äô
users ‚Äô, ‚Äô display_name ‚Äô))
s39 = util . do_sql (conn , " SELECT ‚Äòtasks
‚Äò.* FROM ‚Äòtasks ‚Äò WHERE ‚Äòtasks ‚Äò. ‚Äòid ‚Äò
= :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s7 , ‚Äô time_records ‚Äô, ‚Äô
task_id ‚Äô)})
outputs . extend ( util . get_data (s39 , ‚Äô
tasks ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s39 , ‚Äô
tasks ‚Äô, ‚Äôtext ‚Äô))
if util . has_rows ( s39 ):
s43 = util . do_sql (conn , " SELECT ‚Äò
task_lists ‚Äò.* FROM ‚Äòtask_lists ‚Äò
WHERE ‚Äòtask_lists ‚Äò. ‚Äòid ‚Äò = :x0
LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s39 , ‚Äôtasks ‚Äô, ‚Äô
task_list_id ‚Äô)})
outputs . extend ( util . get_data (s43 , ‚Äô
task_lists ‚Äô, ‚Äô project_id ‚Äô))
if util . has_rows ( s43 ):
s44 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1",
{‚Äôx0 ‚Äô: util . get_one_data (s0 ,
‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (
s44 , ‚Äô people ‚Äô, ‚Äô project_id ‚Äô)
)
outputs . extend ( util . get_data (
s44 , ‚Äô people ‚Äô, ‚Äô user_id ‚Äô))
335
s45 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1",
{‚Äôx0 ‚Äô: util . get_one_data (s0 ,
‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (
s45 , ‚Äô people ‚Äô, ‚Äô project_id ‚Äô)
)
outputs . extend ( util . get_data (
s45 , ‚Äô people ‚Äô, ‚Äô user_id ‚Äô))
s46 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1",
{‚Äôx0 ‚Äô: util . get_one_data (s0 ,
‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (
s46 , ‚Äô people ‚Äô, ‚Äô project_id ‚Äô)
)
outputs . extend ( util . get_data (
s46 , ‚Äô people ‚Äô, ‚Äô user_id ‚Äô))
else :
pass
else :
s40 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s40 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
336
outputs . extend ( util . get_data (s40 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
s41 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s41 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s41 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
s42 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s42 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s42 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
else :
s10 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.*
FROM ‚Äòpeople ‚Äò WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1", {‚Äôx0 ‚Äô: util
. get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
s11 = util . do_sql (conn , " SELECT ‚Äòcompanies
‚Äò.* FROM ‚Äòcompanies ‚Äò WHERE ‚Äòcompanies
‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s7 , ‚Äô time_records ‚Äô, ‚Äô
assigned_to_company_id ‚Äô)})
outputs . extend ( util . get_data (s11 , ‚Äô
companies ‚Äô, ‚Äôname ‚Äô))
if util . has_rows ( s11 ):
337
s25 = util . do_sql (conn , " SELECT ‚Äòtasks
‚Äò.* FROM ‚Äòtasks ‚Äò WHERE ‚Äòtasks ‚Äò. ‚Äòid ‚Äò
= :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s7 , ‚Äô time_records ‚Äô, ‚Äô
task_id ‚Äô)})
outputs . extend ( util . get_data (s25 , ‚Äô
tasks ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s25 , ‚Äô
tasks ‚Äô, ‚Äôtext ‚Äô))
if util . has_rows ( s25 ):
s31 = util . do_sql (conn , " SELECT ‚Äò
task_lists ‚Äò.* FROM ‚Äòtask_lists ‚Äò
WHERE ‚Äòtask_lists ‚Äò. ‚Äòid ‚Äò = :x0
LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s25 , ‚Äôtasks ‚Äô, ‚Äô
task_list_id ‚Äô)})
outputs . extend ( util . get_data (s31 , ‚Äô
task_lists ‚Äô, ‚Äô project_id ‚Äô))
if util . has_rows ( s31 ):
s32 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1",
{‚Äôx0 ‚Äô: util . get_one_data (s0 ,
‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
s33 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò = :
x0 AND ‚Äòpeople ‚Äò. ‚Äò project_id ‚Äò
= :x1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô
id ‚Äô), ‚Äôx1 ‚Äô: inputs [1]})
s34 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ( user_id = :x0 AND
338
project_id = :x1) LIMIT 1",
{‚Äôx0 ‚Äô: util . get_one_data (s0 ,
‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
s35 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò = :
x0 AND ‚Äòpeople ‚Äò. ‚Äò project_id ‚Äò
= :x1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô
id ‚Äô), ‚Äôx1 ‚Äô: inputs [1]})
s36 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1",
{‚Äôx0 ‚Äô: util . get_one_data (s0 ,
‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
else :
pass
else :
s26 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: inputs [1]})
s27 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE ‚Äò
people ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äò
people ‚Äò. ‚Äò project_id ‚Äò = :x1", {‚Äô
x0 ‚Äô: util . get_one_data (s0 , ‚Äô
users ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs [1]})
s28 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
339
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: inputs [1]})
s29 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE ‚Äò
people ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äò
people ‚Äò. ‚Äò project_id ‚Äò = :x1", {‚Äô
x0 ‚Äô: util . get_one_data (s0 , ‚Äô
users ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs [1]})
s30 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: inputs [1]})
else :
s12 = util . do_sql (conn , " SELECT ‚Äòusers
‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò
= :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s7 , ‚Äô time_records ‚Äô, ‚Äô
assigned_to_user_id ‚Äô)})
outputs . extend ( util . get_data (s12 , ‚Äô
users ‚Äô, ‚Äô display_name ‚Äô))
s13 = util . do_sql (conn , " SELECT ‚Äòtasks
‚Äò.* FROM ‚Äòtasks ‚Äò WHERE ‚Äòtasks ‚Äò. ‚Äòid ‚Äò
= :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s7 , ‚Äô time_records ‚Äô, ‚Äô
task_id ‚Äô)})
outputs . extend ( util . get_data (s13 , ‚Äô
tasks ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s13 , ‚Äô
tasks ‚Äô, ‚Äôtext ‚Äô))
if util . has_rows ( s13 ):
s19 = util . do_sql (conn , " SELECT ‚Äò
task_lists ‚Äò.* FROM ‚Äòtask_lists ‚Äò
WHERE ‚Äòtask_lists ‚Äò. ‚Äòid ‚Äò = :x0
340
LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s13 , ‚Äôtasks ‚Äô, ‚Äô
task_list_id ‚Äô)})
outputs . extend ( util . get_data (s19 , ‚Äô
task_lists ‚Äô, ‚Äô project_id ‚Äô))
if util . has_rows ( s19 ):
s20 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1",
{‚Äôx0 ‚Äô: util . get_one_data (s0 ,
‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
s21 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò = :
x0 AND ‚Äòpeople ‚Äò. ‚Äò project_id ‚Äò
= :x1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô
id ‚Äô), ‚Äôx1 ‚Äô: inputs [1]})
s22 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1",
{‚Äôx0 ‚Äô: util . get_one_data (s0 ,
‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
s23 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò = :
x0 AND ‚Äòpeople ‚Äò. ‚Äò project_id ‚Äò
= :x1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô
id ‚Äô), ‚Äôx1 ‚Äô: inputs [1]})
s24 = util . do_sql (conn , " SELECT
‚Äòpeople ‚Äò.* FROM ‚Äòpeople ‚Äò
341
WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1",
{‚Äôx0 ‚Äô: util . get_one_data (s0 ,
‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
else :
pass
else :
s14 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: inputs [1]})
s15 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE ‚Äò
people ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äò
people ‚Äò. ‚Äò project_id ‚Äò = :x1", {‚Äô
x0 ‚Äô: util . get_one_data (s0 , ‚Äô
users ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs [1]})
s16 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: inputs [1]})
s17 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE ‚Äò
people ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äò
people ‚Äò. ‚Äò project_id ‚Äò = :x1", {‚Äô
x0 ‚Äô: util . get_one_data (s0 , ‚Äô
users ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs [1]})
s18 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :
x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
342
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô),
‚Äôx1 ‚Äô: inputs [1]})
else :
pass
else :
pass
else :
pass
else :
pass
return util . add_warnings ( outputs )
D.1.6 Command get_projects_id_milestones_id
def get_projects_id_milestones_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s2 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.* FROM ‚Äòprojects ‚Äò
INNER JOIN ‚Äòpeople ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = ‚Äòpeople ‚Äò. ‚Äò
project_id ‚Äò WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ( projects
. completed_on IS NULL ) ORDER BY projects . priority ASC ,
projects . name ASC ", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s3 = util . do_sql (conn , " SELECT ‚Äò time_records ‚Äò.* FROM ‚Äò
time_records ‚Äò WHERE ‚Äò time_records ‚Äò. ‚Äò assigned_to_user_id
‚Äò = :x0 AND ( start_date IS NOT NULL AND done_date IS
NULL )", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s4 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.* FROM ‚Äòprojects
‚Äò WHERE ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs
343
[1]})
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
if util . has_rows (s4):
s5 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM ‚Äò
companies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {
‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô company_id ‚Äô)})
if util . has_rows (s5):
s6 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM
‚Äòcompanies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò IS NULL
LIMIT 1", {})
s7 = util . do_sql (conn , " SELECT ‚Äòmilestones ‚Äò.* FROM
‚Äòmilestones ‚Äò WHERE ‚Äòmilestones ‚Äò. ‚Äò project_id ‚Äò =
:x0 AND ‚Äòmilestones ‚Äò. ‚Äòid ‚Äò = :x1 LIMIT 1", {‚Äôx0 ‚Äô
: inputs [1] , ‚Äôx1 ‚Äô: inputs [2]})
outputs . extend ( util . get_data (s7 , ‚Äô milestones ‚Äô, ‚Äôid ‚Äô
))
outputs . extend ( util . get_data (s7 , ‚Äô milestones ‚Äô, ‚Äô
project_id ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äô milestones ‚Äô, ‚Äô
name ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äô milestones ‚Äô, ‚Äô
description ‚Äô))
if util . has_rows (s7):
s8 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò WHERE ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x0
LIMIT 1", {‚Äôx0 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s8 , ‚Äô projects ‚Äô, ‚Äô
id ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äô projects ‚Äô, ‚Äô
name ‚Äô))
s9 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.* FROM
‚Äòpeople ‚Äò WHERE ( user_id = :x0 AND
project_id = :x1) LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
344
outputs . extend ( util . get_data (s9 , ‚Äô people ‚Äô, ‚Äô
project_id ‚Äô))
outputs . extend ( util . get_data (s9 , ‚Äô people ‚Äô, ‚Äô
user_id ‚Äô))
s10 = util . do_sql (conn , " SELECT ‚Äòpeople ‚Äò.* FROM
‚Äòpeople ‚Äò WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò = :x0
AND ‚Äòpeople ‚Äò. ‚Äò project_id ‚Äò = :x1", {‚Äôx0 ‚Äô:
util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (s10 , ‚Äôpeople ‚Äô, ‚Äô
project_id ‚Äô))
outputs . extend ( util . get_data (s10 , ‚Äôpeople ‚Äô, ‚Äô
user_id ‚Äô))
if util . has_rows ( s10 ):
s11 = util . do_sql (conn , " SELECT ‚Äòcompanies
‚Äò.* FROM ‚Äòcompanies ‚Äò WHERE ‚Äòcompanies
‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s7 , ‚Äô milestones ‚Äô, ‚Äô
assigned_to_company_id ‚Äô)})
outputs . extend ( util . get_data (s11 , ‚Äô
companies ‚Äô, ‚Äôname ‚Äô))
if util . has_rows ( s11 ):
s19 = util . do_sql (conn , " SELECT ‚Äò
messages ‚Äò.* FROM ‚Äòmessages ‚Äò WHERE ‚Äò
messages ‚Äò. ‚Äò milestone_id ‚Äò = :x0", {‚Äô
x0 ‚Äô: inputs [2]})
outputs . extend ( util . get_data (s19 , ‚Äô
messages ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s19 , ‚Äô
messages ‚Äô, ‚Äô milestone_id ‚Äô))
outputs . extend ( util . get_data (s19 , ‚Äô
messages ‚Äô, ‚Äôtitle ‚Äô))
s19_all = s19
for s19 in s19_all :
s20 = util . do_sql (conn , " SELECT ‚Äò
users ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
345
users ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0
‚Äô: util . get_one_data (s19 , ‚Äô
messages ‚Äô, ‚Äô created_by_id ‚Äô)})
outputs . extend ( util . get_data (s20 , ‚Äô
users ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s20 , ‚Äô
users ‚Äô, ‚Äô display_name ‚Äô))
s19 = s19_all
s21 = util . do_sql (conn , " SELECT ‚Äò
task_lists ‚Äò.* FROM ‚Äòtask_lists ‚Äò
WHERE ‚Äòtask_lists ‚Äò. ‚Äò milestone_id ‚Äò =
:x0 ORDER BY ‚Äòorder ‚Äò DESC ", {‚Äôx0 ‚Äô:
inputs [2]})
outputs . extend ( util . get_data (s21 , ‚Äô
task_lists ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s21 , ‚Äô
task_lists ‚Äô, ‚Äô milestone_id ‚Äô))
outputs . extend ( util . get_data (s21 , ‚Äô
task_lists ‚Äô, ‚Äôname ‚Äô))
s22 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :x1)
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (
s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs
[1]})
outputs . extend ( util . get_data (s22 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s22 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
s23 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :x1)
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (
s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs
[1]})
346
outputs . extend ( util . get_data (s23 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s23 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
s24 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :x1)
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (
s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs
[1]})
outputs . extend ( util . get_data (s24 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s24 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
else :
s12 = util . do_sql (conn , " SELECT ‚Äòusers
‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò
= :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s7 , ‚Äô milestones ‚Äô, ‚Äô
assigned_to_user_id ‚Äô)})
outputs . extend ( util . get_data (s12 , ‚Äô
users ‚Äô, ‚Äô display_name ‚Äô))
s13 = util . do_sql (conn , " SELECT ‚Äò
messages ‚Äò.* FROM ‚Äòmessages ‚Äò WHERE ‚Äò
messages ‚Äò. ‚Äò milestone_id ‚Äò = :x0", {‚Äô
x0 ‚Äô: inputs [2]})
outputs . extend ( util . get_data (s13 , ‚Äô
messages ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s13 , ‚Äô
messages ‚Äô, ‚Äô milestone_id ‚Äô))
outputs . extend ( util . get_data (s13 , ‚Äô
messages ‚Äô, ‚Äôtitle ‚Äô))
s13_all = s13
for s13 in s13_all :
s14 = util . do_sql (conn , " SELECT ‚Äò
users ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
347
users ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0
‚Äô: util . get_one_data (s13 , ‚Äô
messages ‚Äô, ‚Äô created_by_id ‚Äô)})
outputs . extend ( util . get_data (s14 , ‚Äô
users ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s14 , ‚Äô
users ‚Äô, ‚Äô display_name ‚Äô))
s13 = s13_all
s15 = util . do_sql (conn , " SELECT ‚Äò
task_lists ‚Äò.* FROM ‚Äòtask_lists ‚Äò
WHERE ‚Äòtask_lists ‚Äò. ‚Äò milestone_id ‚Äò =
:x0 ORDER BY ‚Äòorder ‚Äò DESC ", {‚Äôx0 ‚Äô:
inputs [2]})
outputs . extend ( util . get_data (s15 , ‚Äô
task_lists ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s15 , ‚Äô
task_lists ‚Äô, ‚Äô milestone_id ‚Äô))
outputs . extend ( util . get_data (s15 , ‚Äô
task_lists ‚Äô, ‚Äôname ‚Äô))
s16 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :x1)
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (
s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs
[1]})
outputs . extend ( util . get_data (s16 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s16 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
s17 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :x1)
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (
s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs
[1]})
348
outputs . extend ( util . get_data (s17 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s17 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
s18 = util . do_sql (conn , " SELECT ‚Äò
people ‚Äò.* FROM ‚Äòpeople ‚Äò WHERE (
user_id = :x0 AND project_id = :x1)
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (
s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs
[1]})
outputs . extend ( util . get_data (s18 , ‚Äô
people ‚Äô, ‚Äô project_id ‚Äô))
outputs . extend ( util . get_data (s18 , ‚Äô
people ‚Äô, ‚Äô user_id ‚Äô))
else :
pass
else :
pass
else :
pass
else :
pass
else :
pass
return util . add_warnings ( outputs )
D.1.7 Command get_projects
def get_projects (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô company_id ‚Äô))
349
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô display_name ‚Äô))
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äô company_id ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äô display_name ‚Äô))
s2 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.* FROM ‚Äòprojects ‚Äò
INNER JOIN ‚Äòpeople ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = ‚Äòpeople ‚Äò. ‚Äò
project_id ‚Äò WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ( projects
. completed_on IS NULL ) ORDER BY projects . priority ASC ,
projects . name ASC ", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s3 = util . do_sql (conn , " SELECT ‚Äò time_records ‚Äò.* FROM ‚Äò
time_records ‚Äò WHERE ‚Äò time_records ‚Äò. ‚Äò assigned_to_user_id
‚Äò = :x0 AND ( start_date IS NOT NULL AND done_date IS
NULL )", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s4 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.* FROM ‚Äòprojects ‚Äò
", {})
s5 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM ‚Äò
companies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô company_id ‚Äô)})
outputs . extend ( util . get_data (s5 , ‚Äô companies ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äô companies ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äô companies ‚Äô, ‚Äô homepage ‚Äô))
if util . has_rows (s5):
s6 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM ‚Äò
companies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò IS NULL LIMIT 1",
{})
else :
pass
else :
pass
return util . add_warnings ( outputs )
350
D.1.8 Command get_companies_id
def get_companies_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s2 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.* FROM ‚Äòprojects ‚Äò
INNER JOIN ‚Äòpeople ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = ‚Äòpeople ‚Äò. ‚Äò
project_id ‚Äò WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ( projects
. completed_on IS NULL ) ORDER BY projects . priority ASC ,
projects . name ASC ", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s3 = util . do_sql (conn , " SELECT ‚Äò time_records ‚Äò.* FROM ‚Äò
time_records ‚Äò WHERE ‚Äò time_records ‚Äò. ‚Äò assigned_to_user_id
‚Äò = :x0 AND ( start_date IS NOT NULL AND done_date IS
NULL )", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s4 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM ‚Äò
companies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: inputs [1]})
outputs . extend ( util . get_data (s4 , ‚Äô companies ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô companies ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô companies ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô companies ‚Äô, ‚Äô homepage ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô companies ‚Äô, ‚Äô address ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô companies ‚Äô, ‚Äô address2 ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô companies ‚Äô, ‚Äôcity ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô companies ‚Äô, ‚Äôstate ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô companies ‚Äô, ‚Äô zipcode ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô companies ‚Äô, ‚Äô country ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô companies ‚Äô, ‚Äô phone_number
‚Äô))
351
outputs . extend ( util . get_data (s4 , ‚Äô companies ‚Äô, ‚Äô fax_number ‚Äô)
)
if util . has_rows (s4):
s5 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM ‚Äò
companies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò IS NULL LIMIT 1",
{})
else :
pass
else :
pass
return util . add_warnings ( outputs )
D.1.9 Command get_users_id
For this command we use a modified version of RailsCollab, where we fixed a 500 error
when a user‚Äôs IM type ID does not match any records in the database. Specifically,
we changed the statement ‚Äú<td><img src="<%= im_value.im_type.icon_url %>"
alt="<%= im_value.im_type.name %>" /></td>‚Äù into‚Äú<td><img src="<%= im_value.im_type.icon_url
rescue nil %>" alt="<%= im_value.im_type.name rescue nil %>" /></td>‚Äù in
the fileapp/views/users/_card.html.erb.
def get_users_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s2 = util . do_sql (conn , " SELECT ‚Äòprojects ‚Äò.* FROM ‚Äòprojects ‚Äò
INNER JOIN ‚Äòpeople ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = ‚Äòpeople ‚Äò. ‚Äò
project_id ‚Äò WHERE ‚Äòpeople ‚Äò. ‚Äò user_id ‚Äò = :x0 AND ( projects
. completed_on IS NULL ) ORDER BY projects . priority ASC ,
projects . name ASC ", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
352
, ‚Äôid ‚Äô)})
s3 = util . do_sql (conn , " SELECT ‚Äò time_records ‚Äò.* FROM ‚Äò
time_records ‚Äò WHERE ‚Äò time_records ‚Äò. ‚Äò assigned_to_user_id
‚Äò = :x0 AND ( start_date IS NOT NULL AND done_date IS
NULL )", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s4 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äô company_id ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äô display_name ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äô office_number ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äô fax_number ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äô mobile_number ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äô home_number ‚Äô))
if util . has_rows (s4):
s5 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM ‚Äò
companies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {
‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äô company_id ‚Äô)})
outputs . extend ( util . get_data (s5 , ‚Äô companies ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äô companies ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äô companies ‚Äô, ‚Äô homepage
‚Äô))
if util . has_rows (s5):
s6 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM
‚Äòcompanies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò IS NULL
LIMIT 1", {})
s7 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.* FROM
‚Äòcompanies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT
1", {‚Äôx0 ‚Äô: util . get_one_data (s4 , ‚Äôusers ‚Äô, ‚Äô
company_id ‚Äô)})
outputs . extend ( util . get_data (s7 , ‚Äô companies ‚Äô, ‚Äôid ‚Äô)
)
outputs . extend ( util . get_data (s7 , ‚Äô companies ‚Äô, ‚Äôname
‚Äô))
353
if util . has_rows (s7):
s8 = util . do_sql (conn , " SELECT ‚Äòcompanies ‚Äò.*
FROM ‚Äòcompanies ‚Äò WHERE ‚Äòcompanies ‚Äò. ‚Äòid ‚Äò IS
NULL LIMIT 1", {})
s9 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
user_im_values ‚Äò WHERE ‚Äò user_im_values ‚Äò. ‚Äò
user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: inputs [1]})
if util . has_rows (s9):
s10 = util . do_sql (conn , " SELECT ‚Äò
user_im_values ‚Äò.* FROM ‚Äò user_im_values ‚Äò
WHERE ‚Äò user_im_values ‚Äò. ‚Äò user_id ‚Äò = :x0
ORDER BY im_type_id DESC ", {‚Äôx0 ‚Äô: inputs
[1]})
outputs . extend ( util . get_data (s10 , ‚Äô
user_im_values ‚Äô, ‚Äô user_id ‚Äô))
outputs . extend ( util . get_data (s10 , ‚Äô
user_im_values ‚Äô, ‚Äôvalue ‚Äô))
s10_all = s10
for s10 in s10_all :
s11 = util . do_sql (conn , " SELECT ‚Äò
im_types ‚Äò.* FROM ‚Äòim_types ‚Äò WHERE ‚Äò
im_types ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s10 , ‚Äô
user_im_values ‚Äô, ‚Äô im_type_id ‚Äô)})
outputs . extend ( util . get_data (s11 , ‚Äô
im_types ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s11 , ‚Äô
im_types ‚Äô, ‚Äôicon ‚Äô))
s10 = s10_all
pass
else :
pass
else :
pass
else :
pass
354
else :
pass
else :
pass
return util . add_warnings ( outputs )
D.2 Regenerated Code for Kanban Task Manager
D.2.1 Command get_api_lists
def get_api_lists (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòlists ‚Äò.* FROM ‚Äòlists ‚Äò INNER
JOIN ‚Äòboards ‚Äò ON ‚Äòlists ‚Äò. ‚Äò board_id ‚Äò = ‚Äòboards ‚Äò. ‚Äòid ‚Äò
INNER JOIN ‚Äò board_members ‚Äò ON ‚Äòboards ‚Äò. ‚Äòid ‚Äò = ‚Äò
board_members ‚Äò. ‚Äò board_id ‚Äò WHERE ‚Äò board_members ‚Äò. ‚Äò
member_id ‚Äò = :x0 ORDER BY ‚Äòlists ‚Äò. ‚Äò position ‚Äò ASC ", {‚Äôx0
‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s1 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôlists ‚Äô, ‚Äô board_id ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôlists ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôlists ‚Äô, ‚Äô position ‚Äô))
s1_all = s1
for s1 in s1_all :
s2 = util . do_sql (conn , " SELECT ‚Äòboards ‚Äò.* FROM ‚Äòboards
‚Äò WHERE ‚Äòboards ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s1 , ‚Äôlists ‚Äô, ‚Äô board_id ‚Äô)})
outputs . extend ( util . get_data (s2 , ‚Äô boards ‚Äô, ‚Äôid ‚Äô))
s3 = util . do_sql (conn , " SELECT ‚Äòcards ‚Äò.* FROM ‚Äòcards ‚Äò
WHERE ‚Äòcards ‚Äò. ‚Äò list_id ‚Äò = :x0 ORDER BY ‚Äòcards ‚Äò. ‚Äò
355
position ‚Äò ASC ", {‚Äôx0 ‚Äô: util . get_one_data (s1 , ‚Äôlists ‚Äô
, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s3 , ‚Äôcards ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôcards ‚Äô, ‚Äô list_id ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôcards ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôcards ‚Äô, ‚Äô description ‚Äô
))
outputs . extend ( util . get_data (s3 , ‚Äôcards ‚Äô, ‚Äô due_date ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôcards ‚Äô, ‚Äô position ‚Äô))
s3_all = s3
for s3 in s3_all :
s4 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
card_comments ‚Äò WHERE ‚Äò card_comments ‚Äò. ‚Äò card_id ‚Äò =
:x0", {‚Äôx0 ‚Äô: util . get_one_data (s3 , ‚Äôcards ‚Äô, ‚Äôid
‚Äô)})
s5 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers
‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s3
, ‚Äôcards ‚Äô, ‚Äô assignee_id ‚Äô)})
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äôbio ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äô
full_name ‚Äô))
s6 = util . do_sql (conn , " SELECT ‚Äò card_comments ‚Äò.*
FROM ‚Äò card_comments ‚Äò WHERE ‚Äò card_comments ‚Äò. ‚Äò
card_id ‚Äò = :x0 ORDER BY ‚Äò card_comments ‚Äò. ‚Äò
created_at ‚Äò DESC ", {‚Äôx0 ‚Äô: util . get_one_data (s3 ,
‚Äôcards ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s6 , ‚Äô card_comments ‚Äô, ‚Äô
card_id ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äô card_comments ‚Äô, ‚Äô
content ‚Äô))
s6_all = s6
for s6 in s6_all :
356
s7 = util . do_sql (conn , " SELECT ‚Äòcards ‚Äò.* FROM
‚Äòcards ‚Äò WHERE ‚Äòcards ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äò
cards ‚Äò. ‚Äò position ‚Äò ASC LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s6 , ‚Äô card_comments ‚Äô, ‚Äô card_id ‚Äô)
})
outputs . extend ( util . get_data (s7 , ‚Äôcards ‚Äô, ‚Äôid ‚Äô)
)
outputs . extend ( util . get_data (s7 , ‚Äôcards ‚Äô, ‚Äô
list_id ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôcards ‚Äô, ‚Äô
title ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôcards ‚Äô, ‚Äô
description ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôcards ‚Äô, ‚Äô
due_date ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôcards ‚Äô, ‚Äô
position ‚Äô))
s8 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM
‚Äòusers ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äò
users ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s6 , ‚Äô card_comments ‚Äô, ‚Äô
commenter_id ‚Äô)})
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)
)
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äô
email ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äôbio ‚Äô
))
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äô
full_name ‚Äô))
s6 = s6_all
pass
s3 = s3_all
pass
s1 = s1_all
pass
357
else :
pass
return util . add_warnings ( outputs )
D.2.2 Command get_api_lists_id
def get_api_lists_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòlists ‚Äò.* FROM ‚Äòlists ‚Äò
INNER JOIN ‚Äòboards ‚Äò ON ‚Äòlists ‚Äò. ‚Äò board_id ‚Äò = ‚Äòboards ‚Äò. ‚Äòid
‚Äò INNER JOIN ‚Äò board_members ‚Äò ON ‚Äòboards ‚Äò. ‚Äòid ‚Äò = ‚Äò
board_members ‚Äò. ‚Äò board_id ‚Äò WHERE ‚Äò board_members ‚Äò. ‚Äò
member_id ‚Äò = :x0 AND ‚Äòlists ‚Äò. ‚Äòid ‚Äò = :x1 ORDER BY ‚Äòlists
‚Äò. ‚Äò position ‚Äò ASC LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 ,
‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s1 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôlists ‚Äô, ‚Äô board_id ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôlists ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôlists ‚Äô, ‚Äô position ‚Äô))
if util . has_rows (s1):
s2 = util . do_sql (conn , " SELECT ‚Äòboards ‚Äò.* FROM ‚Äòboards
‚Äò WHERE ‚Äòboards ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s1 , ‚Äôlists ‚Äô, ‚Äô board_id ‚Äô)})
outputs . extend ( util . get_data (s2 , ‚Äô boards ‚Äô, ‚Äôid ‚Äô))
s3 = util . do_sql (conn , " SELECT ‚Äòcards ‚Äò.* FROM ‚Äòcards ‚Äò
WHERE ‚Äòcards ‚Äò. ‚Äò list_id ‚Äò = :x0 ORDER BY ‚Äòcards ‚Äò. ‚Äò
position ‚Äò ASC ", {‚Äôx0 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s3 , ‚Äôcards ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôcards ‚Äô, ‚Äô list_id ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôcards ‚Äô, ‚Äôtitle ‚Äô))
358
outputs . extend ( util . get_data (s3 , ‚Äôcards ‚Äô, ‚Äô description ‚Äô
))
outputs . extend ( util . get_data (s3 , ‚Äôcards ‚Äô, ‚Äô due_date ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôcards ‚Äô, ‚Äô position ‚Äô))
s3_all = s3
for s3 in s3_all :
s4 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
card_comments ‚Äò WHERE ‚Äò card_comments ‚Äò. ‚Äò card_id ‚Äò =
:x0", {‚Äôx0 ‚Äô: util . get_one_data (s3 , ‚Äôcards ‚Äô, ‚Äôid
‚Äô)})
s5 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers
‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s3
, ‚Äôcards ‚Äô, ‚Äô assignee_id ‚Äô)})
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äôbio ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äô
full_name ‚Äô))
s6 = util . do_sql (conn , " SELECT ‚Äò card_comments ‚Äò.*
FROM ‚Äò card_comments ‚Äò WHERE ‚Äò card_comments ‚Äò. ‚Äò
card_id ‚Äò = :x0 ORDER BY ‚Äò card_comments ‚Äò. ‚Äò
created_at ‚Äò DESC ", {‚Äôx0 ‚Äô: util . get_one_data (s3 ,
‚Äôcards ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s6 , ‚Äô card_comments ‚Äô, ‚Äô
card_id ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äô card_comments ‚Äô, ‚Äô
content ‚Äô))
s6_all = s6
for s6 in s6_all :
s7 = util . do_sql (conn , " SELECT ‚Äòcards ‚Äò.* FROM
‚Äòcards ‚Äò WHERE ‚Äòcards ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äò
cards ‚Äò. ‚Äò position ‚Äò ASC LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s6 , ‚Äô card_comments ‚Äô, ‚Äô card_id ‚Äô)
})
359
outputs . extend ( util . get_data (s7 , ‚Äôcards ‚Äô, ‚Äôid ‚Äô)
)
outputs . extend ( util . get_data (s7 , ‚Äôcards ‚Äô, ‚Äô
list_id ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôcards ‚Äô, ‚Äô
title ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôcards ‚Äô, ‚Äô
description ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôcards ‚Äô, ‚Äô
due_date ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôcards ‚Äô, ‚Äô
position ‚Äô))
s8 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM
‚Äòusers ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äò
users ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s6 , ‚Äô card_comments ‚Äô, ‚Äô
commenter_id ‚Äô)})
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)
)
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äô
email ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äôbio ‚Äô
))
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äô
full_name ‚Äô))
s6 = s6_all
pass
s3 = s3_all
pass
else :
pass
else :
pass
return util . add_warnings ( outputs )
360
D.2.3 Command get_api_cards
def get_api_cards (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòcards ‚Äò.* FROM ‚Äòcards ‚Äò INNER
JOIN ‚Äòlists ‚Äò ON ‚Äòcards ‚Äò. ‚Äò list_id ‚Äò = ‚Äòlists ‚Äò. ‚Äòid ‚Äò INNER
JOIN ‚Äòboards ‚Äò ON ‚Äòlists ‚Äò. ‚Äò board_id ‚Äò = ‚Äòboards ‚Äò. ‚Äòid ‚Äò
INNER JOIN ‚Äò board_members ‚Äò ON ‚Äòboards ‚Äò. ‚Äòid ‚Äò = ‚Äò
board_members ‚Äò. ‚Äò board_id ‚Äò WHERE ‚Äò board_members ‚Äò. ‚Äò
member_id ‚Äò = :x0 ORDER BY ‚Äòcards ‚Äò. ‚Äò position ‚Äò ASC , ‚Äò
lists ‚Äò. ‚Äò position ‚Äò ASC ", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äô
users ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s1 , ‚Äôcards ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôcards ‚Äô, ‚Äô list_id ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôcards ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôcards ‚Äô, ‚Äô description ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôcards ‚Äô, ‚Äô due_date ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôcards ‚Äô, ‚Äô position ‚Äô))
s1_all = s1
for s1 in s1_all :
s2 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
card_comments ‚Äò WHERE ‚Äò card_comments ‚Äò. ‚Äò card_id ‚Äò = :x0
", {‚Äôx0 ‚Äô: util . get_one_data (s1 , ‚Äôcards ‚Äô, ‚Äôid ‚Äô)})
s3 = util . do_sql (conn , " SELECT ‚Äòlists ‚Äò.* FROM ‚Äòlists ‚Äò
WHERE ‚Äòlists ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòlists ‚Äò. ‚Äò position
‚Äò ASC LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s1 , ‚Äôcards ‚Äô
, ‚Äô list_id ‚Äô)})
outputs . extend ( util . get_data (s3 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô))
s4 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s1 , ‚Äôcards ‚Äô, ‚Äô
361
assignee_id ‚Äô)})
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äôbio ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äô full_name ‚Äô))
s5 = util . do_sql (conn , " SELECT ‚Äò card_comments ‚Äò.* FROM ‚Äò
card_comments ‚Äò WHERE ‚Äò card_comments ‚Äò. ‚Äò card_id ‚Äò = :x0
ORDER BY ‚Äò card_comments ‚Äò. ‚Äò created_at ‚Äò DESC ", {‚Äôx0 ‚Äô
: util . get_one_data (s1 , ‚Äôcards ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s5 , ‚Äô card_comments ‚Äô, ‚Äô
card_id ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äô card_comments ‚Äô, ‚Äô
content ‚Äô))
s5_all = s5
for s5 in s5_all :
s6 = util . do_sql (conn , " SELECT ‚Äòcards ‚Äò.* FROM ‚Äò
cards ‚Äò WHERE ‚Äòcards ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòcards
‚Äò. ‚Äò position ‚Äò ASC LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s5 , ‚Äô card_comments ‚Äô, ‚Äô card_id ‚Äô)})
outputs . extend ( util . get_data (s6 , ‚Äôcards ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äôcards ‚Äô, ‚Äô list_id ‚Äô
))
outputs . extend ( util . get_data (s6 , ‚Äôcards ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äôcards ‚Äô, ‚Äô
description ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äôcards ‚Äô, ‚Äô due_date
‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äôcards ‚Äô, ‚Äô position
‚Äô))
s7 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers
‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s5
, ‚Äô card_comments ‚Äô, ‚Äô commenter_id ‚Äô)})
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äôbio ‚Äô))
362
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äô
full_name ‚Äô))
s5 = s5_all
pass
s1 = s1_all
pass
else :
pass
return util . add_warnings ( outputs )
D.2.4 Command get_api_cards_id
def get_api_cards_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòcards ‚Äò.* FROM ‚Äòcards ‚Äò
INNER JOIN ‚Äòlists ‚Äò ON ‚Äòcards ‚Äò. ‚Äò list_id ‚Äò = ‚Äòlists ‚Äò. ‚Äòid ‚Äò
INNER JOIN ‚Äòboards ‚Äò ON ‚Äòlists ‚Äò. ‚Äò board_id ‚Äò = ‚Äòboards ‚Äò. ‚Äòid
‚Äò INNER JOIN ‚Äò board_members ‚Äò ON ‚Äòboards ‚Äò. ‚Äòid ‚Äò = ‚Äò
board_members ‚Äò. ‚Äò board_id ‚Äò WHERE ‚Äò board_members ‚Äò. ‚Äò
member_id ‚Äò = :x0 AND ‚Äòcards ‚Äò. ‚Äòid ‚Äò = :x1 ORDER BY ‚Äòcards
‚Äò. ‚Äò position ‚Äò ASC , ‚Äòlists ‚Äò. ‚Äò position ‚Äò ASC LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs
[1]})
outputs . extend ( util . get_data (s1 , ‚Äôcards ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôcards ‚Äô, ‚Äô list_id ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôcards ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôcards ‚Äô, ‚Äô description ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôcards ‚Äô, ‚Äô due_date ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôcards ‚Äô, ‚Äô position ‚Äô))
if util . has_rows (s1):
363
s2 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
card_comments ‚Äò WHERE ‚Äò card_comments ‚Äò. ‚Äò card_id ‚Äò = :x0
", {‚Äôx0 ‚Äô: inputs [1]})
s3 = util . do_sql (conn , " SELECT ‚Äòlists ‚Äò.* FROM ‚Äòlists ‚Äò
WHERE ‚Äòlists ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòlists ‚Äò. ‚Äò position
‚Äò ASC LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s1 , ‚Äôcards ‚Äô
, ‚Äô list_id ‚Äô)})
outputs . extend ( util . get_data (s3 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô))
s4 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s1 , ‚Äôcards ‚Äô, ‚Äô
assignee_id ‚Äô)})
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äôbio ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äô full_name ‚Äô))
s5 = util . do_sql (conn , " SELECT ‚Äò card_comments ‚Äò.* FROM ‚Äò
card_comments ‚Äò WHERE ‚Äò card_comments ‚Äò. ‚Äò card_id ‚Äò = :x0
ORDER BY ‚Äò card_comments ‚Äò. ‚Äò created_at ‚Äò DESC ", {‚Äôx0 ‚Äô
: inputs [1]})
outputs . extend ( util . get_data (s5 , ‚Äô card_comments ‚Äô, ‚Äô
card_id ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äô card_comments ‚Äô, ‚Äô
content ‚Äô))
s5_all = s5
for s5 in s5_all :
s6 = util . do_sql (conn , " SELECT ‚Äòcards ‚Äò.* FROM ‚Äò
cards ‚Äò WHERE ‚Äòcards ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòcards
‚Äò. ‚Äò position ‚Äò ASC LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s5 , ‚Äô card_comments ‚Äô, ‚Äô card_id ‚Äô)})
outputs . extend ( util . get_data (s6 , ‚Äôcards ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äôcards ‚Äô, ‚Äô list_id ‚Äô
))
outputs . extend ( util . get_data (s6 , ‚Äôcards ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äôcards ‚Äô, ‚Äô
description ‚Äô))
364
outputs . extend ( util . get_data (s6 , ‚Äôcards ‚Äô, ‚Äô due_date
‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äôcards ‚Äô, ‚Äô position
‚Äô))
s7 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers
‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s5
, ‚Äô card_comments ‚Äô, ‚Äô commenter_id ‚Äô)})
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äôbio ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äô
full_name ‚Äô))
s5 = s5_all
pass
else :
pass
else :
pass
return util . add_warnings ( outputs )
D.2.5 Command get_api_boards_id
def get_api_boards_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòboards ‚Äò.* FROM ‚Äòboards ‚Äò
INNER JOIN ‚Äò board_members ‚Äò ON ‚Äòboards ‚Äò. ‚Äòid ‚Äò = ‚Äò
board_members ‚Äò. ‚Äò board_id ‚Äò WHERE ‚Äò board_members ‚Äò. ‚Äò
member_id ‚Äò = :x0 AND ‚Äòboards ‚Äò. ‚Äòid ‚Äò = :x1 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs
365
[1]})
outputs . extend ( util . get_data (s1 , ‚Äô boards ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äô boards ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äô boards ‚Äô, ‚Äô description ‚Äô))
if util . has_rows (s1):
s2 = util . do_sql (conn , " SELECT ‚Äòlists ‚Äò.* FROM ‚Äòlists ‚Äò
WHERE ‚Äòlists ‚Äò. ‚Äò board_id ‚Äò = :x0 ORDER BY ‚Äòlists ‚Äò. ‚Äò
position ‚Äò ASC ", {‚Äôx0 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s2 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äôlists ‚Äô, ‚Äô board_id ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äôlists ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äôlists ‚Äô, ‚Äô position ‚Äô))
s2_all = s2
for s2 in s2_all :
s3 = util . do_sql (conn , " SELECT ‚Äòcards ‚Äò.* FROM ‚Äò
cards ‚Äò WHERE ‚Äòcards ‚Äò. ‚Äò list_id ‚Äò = :x0 ORDER BY ‚Äò
cards ‚Äò. ‚Äò position ‚Äò ASC ", {‚Äôx0 ‚Äô: util . get_one_data
(s2 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s3 , ‚Äôcards ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôcards ‚Äô, ‚Äô list_id ‚Äô
))
outputs . extend ( util . get_data (s3 , ‚Äôcards ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôcards ‚Äô, ‚Äô
description ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôcards ‚Äô, ‚Äô due_date
‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôcards ‚Äô, ‚Äô position
‚Äô))
s3_all = s3
for s3 in s3_all :
s4 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
card_comments ‚Äò WHERE ‚Äò card_comments ‚Äò. ‚Äò
card_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s3
, ‚Äôcards ‚Äô, ‚Äôid ‚Äô)})
s5 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM
‚Äòusers ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äò
366
users ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s3 , ‚Äôcards ‚Äô, ‚Äô assignee_id ‚Äô)})
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)
)
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äô
email ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äôbio ‚Äô
))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äô
full_name ‚Äô))
s6 = util . do_sql (conn , " SELECT ‚Äò card_comments
‚Äò.* FROM ‚Äò card_comments ‚Äò WHERE ‚Äò
card_comments ‚Äò. ‚Äò card_id ‚Äò = :x0 ORDER BY ‚Äò
card_comments ‚Äò. ‚Äò created_at ‚Äò DESC ", {‚Äôx0 ‚Äô:
util . get_one_data (s3 , ‚Äôcards ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s6 , ‚Äô card_comments
‚Äô, ‚Äô card_id ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äô card_comments
‚Äô, ‚Äô content ‚Äô))
s6_all = s6
for s6 in s6_all :
s7 = util . do_sql (conn , " SELECT ‚Äòcards ‚Äò.*
FROM ‚Äòcards ‚Äò WHERE ‚Äòcards ‚Äò. ‚Äòid ‚Äò = :x0
ORDER BY ‚Äòcards ‚Äò. ‚Äò position ‚Äò ASC LIMIT 1"
, {‚Äôx0 ‚Äô: util . get_one_data (s6 , ‚Äô
card_comments ‚Äô, ‚Äô card_id ‚Äô)})
outputs . extend ( util . get_data (s7 , ‚Äôcards ‚Äô, ‚Äô
id ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôcards ‚Äô, ‚Äô
list_id ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôcards ‚Äô, ‚Äô
title ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôcards ‚Äô, ‚Äô
description ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôcards ‚Äô, ‚Äô
due_date ‚Äô))
367
outputs . extend ( util . get_data (s7 , ‚Äôcards ‚Äô, ‚Äô
position ‚Äô))
s8 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.*
FROM ‚Äòusers ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0
ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äôx0
‚Äô: util . get_one_data (s6 , ‚Äô card_comments ‚Äô
, ‚Äô commenter_id ‚Äô)})
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äô
id ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äô
email ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äô
bio ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äô
full_name ‚Äô))
s6 = s6_all
pass
s3 = s3_all
pass
s2 = s2_all
s9 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
INNER JOIN ‚Äò board_members ‚Äò ON ‚Äòusers ‚Äò. ‚Äòid ‚Äò = ‚Äò
board_members ‚Äò. ‚Äò member_id ‚Äò WHERE ‚Äò board_members ‚Äò. ‚Äò
board_id ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC ", {‚Äôx0 ‚Äô:
inputs [1]})
outputs . extend ( util . get_data (s9 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s9 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s9 , ‚Äôusers ‚Äô, ‚Äôbio ‚Äô))
outputs . extend ( util . get_data (s9 , ‚Äôusers ‚Äô, ‚Äô full_name ‚Äô))
else :
pass
else :
pass
return util . add_warnings ( outputs )
368
D.2.6 Command get_api_users_current
def get_api_users_current (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôbio ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô full_name ‚Äô))
return util . add_warnings ( outputs )
D.2.7 Command get_api_users_id
def get_api_users_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôbio ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô full_name ‚Äô))
return util . add_warnings ( outputs )
D.3 Regenerated Code for Todo Task Manager
D.3.1 Command get_home
def get_home (conn , inputs ):
util . clear_warnings ()
369
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòlists ‚Äò.* FROM ‚Äòlists ‚Äò", {})
outputs . extend ( util . get_data (s0 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôlists ‚Äô, ‚Äôname ‚Äô))
s0_all = s0
for s0 in s0_all :
s1 = util . do_sql (conn , " SELECT 1 AS one FROM ‚Äòtasks ‚Äò WHERE
‚Äòtasks ‚Äò. ‚Äò list_id ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô)})
if util . has_rows (s1):
s3 = util . do_sql (conn , " SELECT ‚Äòtasks ‚Äò.* FROM ‚Äòtasks ‚Äò
WHERE ‚Äòtasks ‚Äò. ‚Äò list_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s3 , ‚Äôtasks ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôtasks ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôtasks ‚Äô, ‚Äô list_id ‚Äô))
s4 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äòtasks ‚Äò
WHERE ‚Äòtasks ‚Äò. ‚Äò list_id ‚Äò = :x0 AND ‚Äòtasks ‚Äò. ‚Äò done ‚Äò = 1
", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô)})
else :
s2 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äòtasks ‚Äò
WHERE ‚Äòtasks ‚Äò. ‚Äò list_id ‚Äò = :x0 AND ‚Äòtasks ‚Äò. ‚Äò done ‚Äò = 1
", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô)})
s0 = s0_all
pass
return util . add_warnings ( outputs )
D.3.2 Command get_lists_id_tasks
def get_lists_id_tasks (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòlists ‚Äò.* FROM ‚Äòlists ‚Äò", {})
s0_all = s0
for s0 in s0_all :
370
s1 = util . do_sql (conn , " SELECT 1 AS one FROM ‚Äòtasks ‚Äò WHERE
‚Äòtasks ‚Äò. ‚Äò list_id ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô)})
if util . has_rows (s1):
s3 = util . do_sql (conn , " SELECT ‚Äòtasks ‚Äò.* FROM ‚Äòtasks ‚Äò
WHERE ‚Äòtasks ‚Äò. ‚Äò list_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô)})
s4 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äòtasks ‚Äò
WHERE ‚Äòtasks ‚Äò. ‚Äò list_id ‚Äò = :x0 AND ‚Äòtasks ‚Äò. ‚Äò done ‚Äò = 1
", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô)})
else :
s2 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äòtasks ‚Äò
WHERE ‚Äòtasks ‚Äò. ‚Äò list_id ‚Äò = :x0 AND ‚Äòtasks ‚Äò. ‚Äò done ‚Äò = 1
", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô)})
s0 = s0_all
s5 = util . do_sql (conn , " SELECT ‚Äòlists ‚Äò.* FROM ‚Äòlists ‚Äò WHERE ‚Äò
lists ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s5 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôlists ‚Äô, ‚Äôname ‚Äô))
return util . add_warnings ( outputs )
D.3.3 Command get_lists_id_tasks
For this command we use a modified version of Todo, where we fixed a 404 error
when the provided list ID does not match any records in the database. Specifi-
cally, we changed the statement ‚Äúprevlist = List.find listid‚Äù into ‚Äúprevlist
= List.find listid rescue nil‚Äù in the fileapp/views/tasks/index.html.erb.
def get_lists_id_tasks (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòlists ‚Äò.* FROM ‚Äòlists ‚Äò", {})
outputs . extend ( util . get_data (s0 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôlists ‚Äô, ‚Äôname ‚Äô))
s0_all = s0
for s0 in s0_all :
371
s1 = util . do_sql (conn , " SELECT 1 AS one FROM ‚Äòtasks ‚Äò WHERE
‚Äòtasks ‚Äò. ‚Äò list_id ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô)})
if util . has_rows (s1):
s3 = util . do_sql (conn , " SELECT ‚Äòtasks ‚Äò.* FROM ‚Äòtasks ‚Äò
WHERE ‚Äòtasks ‚Äò. ‚Äò list_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s3 , ‚Äôtasks ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôtasks ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôtasks ‚Äô, ‚Äô list_id ‚Äô))
s4 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äòtasks ‚Äò
WHERE ‚Äòtasks ‚Äò. ‚Äò list_id ‚Äò = :x0 AND ‚Äòtasks ‚Äò. ‚Äò done ‚Äò = 1
", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô)})
else :
s2 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äòtasks ‚Äò
WHERE ‚Äòtasks ‚Äò. ‚Äò list_id ‚Äò = :x0 AND ‚Äòtasks ‚Äò. ‚Äò done ‚Äò = 1
", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôlists ‚Äô, ‚Äôid ‚Äô)})
s0 = s0_all
s5 = util . do_sql (conn , " SELECT ‚Äòlists ‚Äò.* FROM ‚Äòlists ‚Äò WHERE ‚Äò
lists ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
return util . add_warnings ( outputs )
D.4 Regenerated Code for Fulcrum Task Manager
D.4.1 Command get_home
def get_home (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
if util . has_rows (s0):
372
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
s2 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM ‚Äò
projects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s2 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äô projects ‚Äô, ‚Äô start_date ‚Äô))
s3 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s3 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
s4 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM ‚Äò
projects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äô start_date ‚Äô))
else :
pass
return util . add_warnings ( outputs )
D.4.2 Command get_projects
def get_projects (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
373
x0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
s2 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM ‚Äò
projects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s2 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äô projects ‚Äô, ‚Äô start_date ‚Äô))
s3 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s3 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
s4 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM ‚Äò
projects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äô start_date ‚Äô))
else :
pass
return util . add_warnings ( outputs )
D.4.3 Command get_projects_id
def get_projects_id (conn , inputs ):
util . clear_warnings ()
374
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s2 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM ‚Äò
projects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s3 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s4 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM
‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid
‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x1 LIMIT 1", {‚Äô
x0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs
[1]})
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
if util . has_rows (s4):
s6 = util . do_sql (conn , " SELECT DISTINCT ‚Äòusers ‚Äò.* FROM
‚Äòusers ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòusers ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò project_id ‚Äò = :x0", {‚Äôx0 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s6 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äôusers ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äôusers ‚Äô, ‚Äô initials ‚Äô))
s7 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äò
projects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE
375
‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s7 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
else :
s5 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äò
projects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE
‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
else :
pass
return util . add_warnings ( outputs )
D.4.4 Command get_projects_id_stories
def get_projects_id_stories (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s2 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM ‚Äò
projects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s3 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
376
s4 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM
‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid
‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x1 LIMIT 1", {‚Äô
x0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs
[1]})
if util . has_rows (s4):
s6 = util . do_sql (conn , " SELECT ‚Äòstories ‚Äò.* FROM ‚Äò
stories ‚Äò WHERE ‚Äòstories ‚Äò. ‚Äò project_id ‚Äò IN (: x0)", {‚Äô
x0 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s6 , ‚Äô stories ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äô stories ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äô stories ‚Äô, ‚Äô
description ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äô stories ‚Äô, ‚Äô estimate ‚Äô)
)
outputs . extend ( util . get_data (s6 , ‚Äô stories ‚Äô, ‚Äô
requested_by_id ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äô stories ‚Äô, ‚Äô
owned_by_id ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äô stories ‚Äô, ‚Äô project_id
‚Äô))
if util . has_rows (s6):
s7 = util . do_sql (conn , " SELECT ‚Äònotes ‚Äò.* FROM ‚Äò
notes ‚Äò WHERE ‚Äònotes ‚Äò. ‚Äò story_id ‚Äò IN :x0", {‚Äôx0 ‚Äô:
util . get_data (s6 , ‚Äô stories ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s7 , ‚Äônotes ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äônotes ‚Äô, ‚Äônote ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äônotes ‚Äô, ‚Äô user_id ‚Äô
))
outputs . extend ( util . get_data (s7 , ‚Äônotes ‚Äô, ‚Äô story_id
‚Äô))
else :
pass
else :
377
s5 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äò
projects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE
‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
else :
pass
return util . add_warnings ( outputs )
D.4.5 Command get_projects_id_stories_id
def get_projects_id_stories_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s2 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM ‚Äò
projects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s3 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s4 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM
‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid
‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x1 LIMIT 1", {‚Äô
x0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs
[1]})
378
if util . has_rows (s4):
s6 = util . do_sql (conn , " SELECT ‚Äòstories ‚Äò.* FROM ‚Äò
stories ‚Äò WHERE ‚Äòstories ‚Äò. ‚Äò project_id ‚Äò = :x0 AND ‚Äò
stories ‚Äò. ‚Äòid ‚Äò = :x1 LIMIT 1", {‚Äôx0 ‚Äô: inputs [1] , ‚Äôx1 ‚Äô
: inputs [2]})
outputs . extend ( util . get_data (s6 , ‚Äô stories ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äô stories ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äô stories ‚Äô, ‚Äô
description ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äô stories ‚Äô, ‚Äô estimate ‚Äô)
)
outputs . extend ( util . get_data (s6 , ‚Äô stories ‚Äô, ‚Äô
requested_by_id ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äô stories ‚Äô, ‚Äô
owned_by_id ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äô stories ‚Äô, ‚Äô project_id
‚Äô))
if util . has_rows (s6):
s8 = util . do_sql (conn , " SELECT ‚Äònotes ‚Äò.* FROM ‚Äò
notes ‚Äò WHERE ‚Äònotes ‚Äò. ‚Äò story_id ‚Äò = :x0", {‚Äôx0 ‚Äô:
inputs [2]})
outputs . extend ( util . get_data (s8 , ‚Äônotes ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äônotes ‚Äô, ‚Äônote ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äônotes ‚Äô, ‚Äô user_id ‚Äô
))
outputs . extend ( util . get_data (s8 , ‚Äônotes ‚Äô, ‚Äô story_id
‚Äô))
else :
s7 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects
‚Äò.* FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò
ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò
project_id ‚Äò WHERE ‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :
x0", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)
})
else :
379
s5 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äò
projects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE
‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
else :
pass
return util . add_warnings ( outputs )
D.4.6 Command get_projects_id_stories_id_notes
def get_projects_id_stories_id_notes (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s2 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM ‚Äò
projects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s3 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s4 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM
‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid
‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x1 LIMIT 1", {‚Äô
x0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs
[1]})
380
if util . has_rows (s4):
s6 = util . do_sql (conn , " SELECT ‚Äòstories ‚Äò.* FROM ‚Äò
stories ‚Äò WHERE ‚Äòstories ‚Äò. ‚Äò project_id ‚Äò = :x0 AND ‚Äò
stories ‚Äò. ‚Äòid ‚Äò = :x1 LIMIT 1", {‚Äôx0 ‚Äô: inputs [1] , ‚Äôx1 ‚Äô
: inputs [2]})
if util . has_rows (s6):
s8 = util . do_sql (conn , " SELECT ‚Äònotes ‚Äò.* FROM ‚Äò
notes ‚Äò WHERE ‚Äònotes ‚Äò. ‚Äò story_id ‚Äò = :x0", {‚Äôx0 ‚Äô:
inputs [2]})
outputs . extend ( util . get_data (s8 , ‚Äônotes ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äônotes ‚Äô, ‚Äônote ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äônotes ‚Äô, ‚Äô user_id ‚Äô
))
outputs . extend ( util . get_data (s8 , ‚Äônotes ‚Äô, ‚Äô story_id
‚Äô))
else :
s7 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects
‚Äò.* FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò
ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò
project_id ‚Äò WHERE ‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :
x0", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)
})
else :
s5 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äò
projects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE
‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
else :
pass
return util . add_warnings ( outputs )
D.4.7 Command get_projects_id_stories_id_notes_id
def get_projects_id_stories_id_notes_id (conn , inputs ):
381
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s2 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM ‚Äò
projects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s3 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s4 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM
‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid
‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x1 LIMIT 1", {‚Äô
x0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs
[1]})
if util . has_rows (s4):
s6 = util . do_sql (conn , " SELECT ‚Äòstories ‚Äò.* FROM ‚Äò
stories ‚Äò WHERE ‚Äòstories ‚Äò. ‚Äò project_id ‚Äò = :x0 AND ‚Äò
stories ‚Äò. ‚Äòid ‚Äò = :x1 LIMIT 1", {‚Äôx0 ‚Äô: inputs [1] , ‚Äôx1 ‚Äô
: inputs [2]})
if util . has_rows (s6):
s8 = util . do_sql (conn , " SELECT ‚Äònotes ‚Äò.* FROM ‚Äò
notes ‚Äò WHERE ‚Äònotes ‚Äò. ‚Äò story_id ‚Äò = :x0 AND ‚Äò
notes ‚Äò. ‚Äòid ‚Äò = :x1 LIMIT 1", {‚Äôx0 ‚Äô: inputs [2] , ‚Äô
x1 ‚Äô: inputs [3]})
outputs . extend ( util . get_data (s8 , ‚Äônotes ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äônotes ‚Äô, ‚Äônote ‚Äô))
382
outputs . extend ( util . get_data (s8 , ‚Äônotes ‚Äô, ‚Äô user_id ‚Äô
))
outputs . extend ( util . get_data (s8 , ‚Äônotes ‚Äô, ‚Äô story_id
‚Äô))
if util . has_rows (s8):
pass
else :
s9 = util . do_sql (conn , " SELECT DISTINCT ‚Äò
projects ‚Äò.* FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò
projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = ‚Äò
projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò
projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô:
util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
else :
s7 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects
‚Äò.* FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò
ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò
project_id ‚Äò WHERE ‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :
x0", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)
})
else :
s5 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äò
projects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE
‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
else :
pass
return util . add_warnings ( outputs )
D.4.8 Command get_projects_id_users
def get_projects_id_users (conn , inputs ):
util . clear_warnings ()
outputs = []
383
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò email ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC LIMIT 1", {‚Äô
x0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s2 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM ‚Äò
projects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô
, ‚Äôid ‚Äô)})
s3 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 ORDER BY ‚Äòusers ‚Äò. ‚Äòid ‚Äò ASC
LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s4 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.* FROM
‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòprojects ‚Äò. ‚Äòid
‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò user_id ‚Äò = :x0 AND ‚Äòprojects ‚Äò. ‚Äòid ‚Äò = :x1 LIMIT 1", {‚Äô
x0 ‚Äô: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô), ‚Äôx1 ‚Äô: inputs
[1]})
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
if util . has_rows (s4):
s6 = util . do_sql (conn , " SELECT DISTINCT ‚Äòusers ‚Äò.* FROM
‚Äòusers ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äòusers ‚Äò. ‚Äòid ‚Äò
= ‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò WHERE ‚Äò projects_users
‚Äò. ‚Äò project_id ‚Äò = :x0", {‚Äôx0 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s6 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äôusers ‚Äô, ‚Äôname ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äôusers ‚Äô, ‚Äô initials ‚Äô))
s7 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äò
projects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE
‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
384
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s7 , ‚Äô projects ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äô projects ‚Äô, ‚Äôname ‚Äô))
else :
s5 = util . do_sql (conn , " SELECT DISTINCT ‚Äòprojects ‚Äò.*
FROM ‚Äòprojects ‚Äò INNER JOIN ‚Äò projects_users ‚Äò ON ‚Äò
projects ‚Äò. ‚Äòid ‚Äò = ‚Äò projects_users ‚Äò. ‚Äò project_id ‚Äò WHERE
‚Äò projects_users ‚Äò. ‚Äò user_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
else :
pass
return util . add_warnings ( outputs )
D.5 Regenerated Code for Kandan Chat Room
D.5.1 Command get_channels
def get_channels (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s2 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äòchannels ‚Äò
", {})
if util . has_rows (s2):
s5 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.* FROM ‚Äò
activities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò channel_id ‚Äò IN :x0"
, {‚Äôx0 ‚Äô: util . get_data (s2 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô)})
if util . has_rows (s5):
s10 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò IN :x0", {‚Äôx0 ‚Äô: util .
385
get_data (s5 , ‚Äô activities ‚Äô, ‚Äô user_id ‚Äô)})
s11 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s12 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äò
channels ‚Äò", {})
outputs . extend ( util . get_data (s12 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô)
)
outputs . extend ( util . get_data (s12 , ‚Äô channels ‚Äô, ‚Äôname
‚Äô))
outputs . extend ( util . get_data (s12 , ‚Äô channels ‚Äô, ‚Äô
user_id ‚Äô))
s12_all = s12
for s12 in s12_all :
s13 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
activities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò channel_id ‚Äò
= :x0", {‚Äôx0 ‚Äô: util . get_one_data (s12 , ‚Äô
channels ‚Äô, ‚Äôid ‚Äô)})
s14 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.*
FROM ‚Äòactivities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò
channel_id ‚Äò = :x0 ORDER BY id DESC LIMIT 30
OFFSET 0", {‚Äôx0 ‚Äô: util . get_one_data (s12 , ‚Äô
channels ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s14 , ‚Äô activities ‚Äô,
‚Äôid ‚Äô))
outputs . extend ( util . get_data (s14 , ‚Äô activities ‚Äô,
‚Äô content ‚Äô))
outputs . extend ( util . get_data (s14 , ‚Äô activities ‚Äô,
‚Äô channel_id ‚Äô))
outputs . extend ( util . get_data (s14 , ‚Äô activities ‚Äô,
‚Äô user_id ‚Äô))
if util . has_rows ( s14 ):
s15 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.*
FROM ‚Äòusers ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò IN :x0"
, {‚Äôx0 ‚Äô: util . get_data (s14 , ‚Äô activities ‚Äô
, ‚Äô user_id ‚Äô)})
386
outputs . extend ( util . get_data (s15 , ‚Äôusers ‚Äô,
‚Äôid ‚Äô))
outputs . extend ( util . get_data (s15 , ‚Äôusers ‚Äô,
‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s15 , ‚Äôusers ‚Äô,
‚Äô first_name ‚Äô))
outputs . extend ( util . get_data (s15 , ‚Äôusers ‚Äô,
‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s15 , ‚Äôusers ‚Äô,
‚Äô username ‚Äô))
else :
pass
s12 = s12_all
pass
else :
s6 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s7 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äò
channels ‚Äò", {})
outputs . extend ( util . get_data (s7 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äô channels ‚Äô, ‚Äôname ‚Äô
))
outputs . extend ( util . get_data (s7 , ‚Äô channels ‚Äô, ‚Äô
user_id ‚Äô))
s7_all = s7
for s7 in s7_all :
s8 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äò
activities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò channel_id ‚Äò
= :x0", {‚Äôx0 ‚Äô: util . get_one_data (s7 , ‚Äô
channels ‚Äô, ‚Äôid ‚Äô)})
s9 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.*
FROM ‚Äòactivities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò
channel_id ‚Äò = :x0 ORDER BY id DESC LIMIT 30
OFFSET 0", {‚Äôx0 ‚Äô: util . get_one_data (s7 , ‚Äô
channels ‚Äô, ‚Äôid ‚Äô)})
387
s7 = s7_all
pass
else :
s3 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s4 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äò
channels ‚Äò", {})
else :
pass
return util . add_warnings ( outputs )
D.5.2 Command get_channels_id_activities
def get_channels_id_activities (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s2 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äòchannels ‚Äò
", {})
if util . has_rows (s2):
s5 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.* FROM ‚Äò
activities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò channel_id ‚Äò IN :x0"
, {‚Äôx0 ‚Äô: util . get_data (s2 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô)})
if util . has_rows (s5):
s10 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò IN :x0", {‚Äôx0 ‚Äô: util .
get_data (s5 , ‚Äô activities ‚Äô, ‚Äô user_id ‚Äô)})
s11 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
388
: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s12 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM
‚Äòchannels ‚Äò WHERE ‚Äòchannels ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1"
, {‚Äôx0 ‚Äô: inputs [1]})
if util . has_rows ( s12 ):
s13 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.*
FROM ‚Äòactivities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò
channel_id ‚Äò = :x0 ORDER BY id LIMIT 1", {‚Äôx0
‚Äô: inputs [1]})
outputs . extend ( util . get_data (s13 , ‚Äô activities ‚Äô,
‚Äôid ‚Äô))
outputs . extend ( util . get_data (s13 , ‚Äô activities ‚Äô,
‚Äô content ‚Äô))
outputs . extend ( util . get_data (s13 , ‚Äô activities ‚Äô,
‚Äô channel_id ‚Äô))
outputs . extend ( util . get_data (s13 , ‚Äô activities ‚Äô,
‚Äô user_id ‚Äô))
s14 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.*
FROM ‚Äòactivities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò
channel_id ‚Äò = :x0 ORDER BY id DESC LIMIT 30"
, {‚Äôx0 ‚Äô: inputs [1]})
outputs . extend ( util . get_data (s14 , ‚Äô activities ‚Äô,
‚Äôid ‚Äô))
outputs . extend ( util . get_data (s14 , ‚Äô activities ‚Äô,
‚Äô content ‚Äô))
outputs . extend ( util . get_data (s14 , ‚Äô activities ‚Äô,
‚Äô channel_id ‚Äô))
outputs . extend ( util . get_data (s14 , ‚Äô activities ‚Äô,
‚Äô user_id ‚Äô))
if util . has_rows ( s14 ):
s15 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.*
FROM ‚Äòusers ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò IN :x0"
, {‚Äôx0 ‚Äô: util . get_data (s14 , ‚Äô activities ‚Äô
, ‚Äô user_id ‚Äô)})
outputs . extend ( util . get_data (s15 , ‚Äôusers ‚Äô,
‚Äôid ‚Äô))
389
outputs . extend ( util . get_data (s15 , ‚Äôusers ‚Äô,
‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s15 , ‚Äôusers ‚Äô,
‚Äô first_name ‚Äô))
outputs . extend ( util . get_data (s15 , ‚Äôusers ‚Äô,
‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s15 , ‚Äôusers ‚Äô,
‚Äô username ‚Äô))
else :
pass
else :
pass
else :
s6 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s7 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äò
channels ‚Äò WHERE ‚Äòchannels ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1",
{‚Äôx0 ‚Äô: inputs [1]})
if util . has_rows (s7):
s8 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.*
FROM ‚Äòactivities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò
channel_id ‚Äò = :x0 ORDER BY id LIMIT 1", {‚Äôx0
‚Äô: inputs [1]})
s9 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.*
FROM ‚Äòactivities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò
channel_id ‚Äò = :x0 ORDER BY id DESC LIMIT 30"
, {‚Äôx0 ‚Äô: inputs [1]})
else :
pass
else :
s3 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s4 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äò
channels ‚Äò WHERE ‚Äòchannels ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äô
390
x0 ‚Äô: inputs [1]})
else :
pass
return util . add_warnings ( outputs )
D.5.3 Command get_channels_id_activities_id
def get_channels_id_activities_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s2 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äòchannels ‚Äò
", {})
if util . has_rows (s2):
s5 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.* FROM ‚Äò
activities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò channel_id ‚Äò IN :x0"
, {‚Äôx0 ‚Äô: util . get_data (s2 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô)})
if util . has_rows (s5):
s8 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò IN :x0", {‚Äôx0 ‚Äô: util .
get_data (s5 , ‚Äô activities ‚Äô, ‚Äô user_id ‚Äô)})
s9 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s10 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.*
FROM ‚Äòactivities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äòid ‚Äò = :x0
LIMIT 1", {‚Äôx0 ‚Äô: inputs [2]})
outputs . extend ( util . get_data (s10 , ‚Äô activities ‚Äô, ‚Äô
content ‚Äô))
else :
391
s6 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s7 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.* FROM
‚Äòactivities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äòid ‚Äò = :x0
LIMIT 1", {‚Äôx0 ‚Äô: inputs [2]})
outputs . extend ( util . get_data (s7 , ‚Äô activities ‚Äô, ‚Äô
content ‚Äô))
else :
s3 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
s4 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.* FROM ‚Äò
activities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1",
{‚Äôx0 ‚Äô: inputs [2]})
outputs . extend ( util . get_data (s4 , ‚Äô activities ‚Äô, ‚Äô content
‚Äô))
else :
pass
return util . add_warnings ( outputs )
D.5.4 Command get_me
def get_me (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
if util . has_rows (s0):
392
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
s2 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äòchannels ‚Äò
", {})
if util . has_rows (s2):
s4 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.* FROM ‚Äò
activities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò channel_id ‚Äò IN :x0"
, {‚Äôx0 ‚Äô: util . get_data (s2 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô)})
if util . has_rows (s4):
s6 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò IN :x0", {‚Äôx0 ‚Äô: util .
get_data (s4 , ‚Äô activities ‚Äô, ‚Äô user_id ‚Äô)})
s7 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äô username
‚Äô))
else :
s5 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
393
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äô username
‚Äô))
else :
s3 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s3 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô)
)
outputs . extend ( util . get_data (s3 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
else :
pass
return util . add_warnings ( outputs )
D.5.5 Command get_users
def get_users (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
394
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
s2 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äòchannels ‚Äò
", {})
if util . has_rows (s2):
s5 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.* FROM ‚Äò
activities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò channel_id ‚Äò IN :x0"
, {‚Äôx0 ‚Äô: util . get_data (s2 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô)})
if util . has_rows (s5):
s8 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò IN :x0", {‚Äôx0 ‚Äô: util .
get_data (s5 , ‚Äô activities ‚Äô, ‚Äô user_id ‚Äô)})
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
outputs . extend ( util . get_data (s8 , ‚Äôusers ‚Äô, ‚Äô username
‚Äô))
s9 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s9 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s9 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s9 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
outputs . extend ( util . get_data (s9 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
outputs . extend ( util . get_data (s9 , ‚Äôusers ‚Äô, ‚Äô username
‚Äô))
395
s10 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò", {})
outputs . extend ( util . get_data (s10 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s10 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô)
)
outputs . extend ( util . get_data (s10 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
outputs . extend ( util . get_data (s10 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
outputs . extend ( util . get_data (s10 , ‚Äôusers ‚Äô, ‚Äô
username ‚Äô))
else :
s6 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s6 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äôusers ‚Äô, ‚Äô username
‚Äô))
s7 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò", {})
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äô username
‚Äô))
else :
s3 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
396
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s3 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô)
)
outputs . extend ( util . get_data (s3 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
s4 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò",
{})
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô)
)
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
else :
pass
return util . add_warnings ( outputs )
D.5.6 Command get_users_id
def get_users_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò WHERE ‚Äò
users ‚Äò. ‚Äò username ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
397
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
s2 = util . do_sql (conn , " SELECT ‚Äòchannels ‚Äò.* FROM ‚Äòchannels ‚Äò
", {})
if util . has_rows (s2):
s4 = util . do_sql (conn , " SELECT ‚Äòactivities ‚Äò.* FROM ‚Äò
activities ‚Äò WHERE ‚Äòactivities ‚Äò. ‚Äò channel_id ‚Äò IN :x0"
, {‚Äôx0 ‚Äô: util . get_data (s2 , ‚Äô channels ‚Äô, ‚Äôid ‚Äô)})
if util . has_rows (s4):
s6 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò IN :x0", {‚Äôx0 ‚Äô: util .
get_data (s4 , ‚Äô activities ‚Äô, ‚Äô user_id ‚Äô)})
s7 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
outputs . extend ( util . get_data (s7 , ‚Äôusers ‚Äô, ‚Äô username
‚Äô))
else :
s5 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äò
users ‚Äò WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô
: util . get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äô
first_name ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äô
last_name ‚Äô))
398
outputs . extend ( util . get_data (s5 , ‚Äôusers ‚Äô, ‚Äô username
‚Äô))
else :
s3 = util . do_sql (conn , " SELECT ‚Äòusers ‚Äò.* FROM ‚Äòusers ‚Äò
WHERE ‚Äòusers ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: util .
get_one_data (s0 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s3 , ‚Äôusers ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôusers ‚Äô, ‚Äôemail ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôusers ‚Äô, ‚Äô first_name ‚Äô)
)
outputs . extend ( util . get_data (s3 , ‚Äôusers ‚Äô, ‚Äô last_name ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôusers ‚Äô, ‚Äô username ‚Äô))
else :
pass
return util . add_warnings ( outputs )
D.6 Regenerated Code for Enki Blogging Applica-
tion
D.6.1 Command get_home
For this command we use the original version of Enki, but disregard all queries on
the taggings table.
def get_home (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT COUNT ( count_column ) FROM ( SELECT
1 AS count_column FROM ‚Äòposts ‚Äò WHERE (1=1) LIMIT 15)
subquery_for_count ", {})
if util . has_rows (s0):
s4 = util . do_sql (conn , " SELECT ‚Äòposts ‚Äò.* FROM ‚Äòposts ‚Äò
WHERE (1=1) ORDER BY published_at DESC LIMIT 15", {})
outputs . extend ( util . get_data (s4 , ‚Äôposts ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôposts ‚Äô, ‚Äôtitle ‚Äô))
399
outputs . extend ( util . get_data (s4 , ‚Äôposts ‚Äô, ‚Äôslug ‚Äô))
outputs . extend ( util . get_data (s4 , ‚Äôposts ‚Äô, ‚Äô body_html ‚Äô))
s4_all = s4
for s4 in s4_all :
s5 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äòcomments ‚Äò
WHERE ‚Äòcomments ‚Äò. ‚Äò post_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s4 , ‚Äôposts ‚Äô, ‚Äôid ‚Äô)})
s4 = s4_all
s6 = util . do_sql (conn , " SELECT ‚Äòpages ‚Äò.* FROM ‚Äòpages ‚Äò
ORDER BY title ", {})
outputs . extend ( util . get_data (s6 , ‚Äôpages ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s6 , ‚Äôpages ‚Äô, ‚Äôslug ‚Äô))
s7 = util . do_sql (conn , " SELECT ‚Äòposts ‚Äò.* FROM ‚Äòposts ‚Äò WHERE
(‚Äò posts ‚Äò. ‚Äò published_at ‚Äò IS NOT NULL )", {})
s8 = util . do_sql (conn , " SELECT ‚Äòtags ‚Äò.* FROM ‚Äòtags ‚Äò WHERE ‚Äò
tags ‚Äò. ‚Äò name ‚Äò IS NULL ", {})
else :
s1 = util . do_sql (conn , " SELECT ‚Äòpages ‚Äò.* FROM ‚Äòpages ‚Äò
ORDER BY title ", {})
outputs . extend ( util . get_data (s1 , ‚Äôpages ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôpages ‚Äô, ‚Äôslug ‚Äô))
s2 = util . do_sql (conn , " SELECT ‚Äòposts ‚Äò.* FROM ‚Äòposts ‚Äò WHERE
(‚Äò posts ‚Äò. ‚Äò published_at ‚Äò IS NOT NULL )", {})
s3 = util . do_sql (conn , " SELECT ‚Äòtags ‚Äò.* FROM ‚Äòtags ‚Äò WHERE
1=0 ", {})
return util . add_warnings ( outputs )
D.6.2 Command get_archives
def get_archives (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòposts ‚Äò.* FROM ‚Äòposts ‚Äò WHERE
(1=1) ORDER BY published_at DESC ", {})
outputs . extend ( util . get_data (s0 , ‚Äôposts ‚Äô, ‚Äôtitle ‚Äô))
400
outputs . extend ( util . get_data (s0 , ‚Äôposts ‚Äô, ‚Äôslug ‚Äô))
s0_all = s0
for s0 in s0_all :
s1 = util . do_sql (conn , " SELECT 1 AS one FROM ‚Äòtags ‚Äò INNER
JOIN ‚Äòtaggings ‚Äò ON ‚Äòtags ‚Äò. ‚Äòid ‚Äò = ‚Äòtaggings ‚Äò. ‚Äò tag_id ‚Äò
WHERE ‚Äòtaggings ‚Äò. ‚Äò taggable_id ‚Äò = :x0 AND ‚Äòtaggings ‚Äò. ‚Äò
taggable_type ‚Äò = ‚ÄôPost ‚Äô AND ‚Äòtaggings ‚Äò. ‚Äò context ‚Äò = ‚Äôtags
‚Äô LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôposts ‚Äô, ‚Äôid ‚Äô)
})
if util . has_rows (s1):
s2 = util . do_sql (conn , " SELECT ‚Äòtags ‚Äò.* FROM ‚Äòtags ‚Äò
INNER JOIN ‚Äòtaggings ‚Äò ON ‚Äòtags ‚Äò. ‚Äòid ‚Äò = ‚Äòtaggings ‚Äò. ‚Äò
tag_id ‚Äò WHERE ‚Äòtaggings ‚Äò. ‚Äò taggable_id ‚Äò = :x0 AND ‚Äò
taggings ‚Äò. ‚Äò taggable_type ‚Äò = ‚ÄôPost ‚Äô AND ‚Äòtaggings ‚Äò. ‚Äò
context ‚Äò = ‚Äôtags ‚Äô", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äô
posts ‚Äô, ‚Äôid ‚Äô)})
outputs . extend ( util . get_data (s2 , ‚Äôtags ‚Äô, ‚Äôname ‚Äô))
else :
pass
s0 = s0_all
s3 = util . do_sql (conn , " SELECT ‚Äòpages ‚Äò.* FROM ‚Äòpages ‚Äò ORDER BY
title ", {})
outputs . extend ( util . get_data (s3 , ‚Äôpages ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s3 , ‚Äôpages ‚Äô, ‚Äôslug ‚Äô))
s4 = util . do_sql (conn , " SELECT ‚Äòposts ‚Äò.* FROM ‚Äòposts ‚Äò WHERE (‚Äò
posts ‚Äò. ‚Äò published_at ‚Äò IS NOT NULL )", {})
s5 = util . do_sql (conn , " SELECT ‚Äòtags ‚Äò.* FROM ‚Äòtags ‚Äò WHERE 1=0 ",
{})
return util . add_warnings ( outputs )
D.6.3 Command get_admin_comments_id
def get_admin_comments_id (conn , inputs ):
util . clear_warnings ()
outputs = []
401
s0 = util . do_sql (conn , " SELECT ‚Äòcomments ‚Äò.* FROM ‚Äòcomments ‚Äò
WHERE ‚Äòcomments ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äô comments ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äô comments ‚Äô, ‚Äô author ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äô comments ‚Äô, ‚Äô author_url ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äô comments ‚Äô, ‚Äô author_email ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äô comments ‚Äô, ‚Äôbody ‚Äô))
return util . add_warnings ( outputs )
D.6.4 Command get_admin_pages
def get_admin_pages (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äòpages ‚Äò", {})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòpages ‚Äò.* FROM ‚Äòpages ‚Äò
ORDER BY created_at DESC LIMIT 30 OFFSET 0", {})
outputs . extend ( util . get_data (s1 , ‚Äôpages ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôpages ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôpages ‚Äô, ‚Äôslug ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôpages ‚Äô, ‚Äôbody ‚Äô))
else :
pass
return util . add_warnings ( outputs )
D.6.5 Command get_admin_pages_id
def get_admin_pages_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòpages ‚Äò.* FROM ‚Äòpages ‚Äò WHERE ‚Äò
pages ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äôpages ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôpages ‚Äô, ‚Äôtitle ‚Äô))
402
outputs . extend ( util . get_data (s0 , ‚Äôpages ‚Äô, ‚Äôslug ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äôpages ‚Äô, ‚Äôbody ‚Äô))
return util . add_warnings ( outputs )
D.6.6 Command get_admin_posts
def get_admin_posts (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äòposts ‚Äò", {})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòposts ‚Äò.* FROM ‚Äòposts ‚Äò
ORDER BY coalesce ( published_at , updated_at ) DESC LIMIT
30 OFFSET 0", {})
outputs . extend ( util . get_data (s1 , ‚Äôposts ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôposts ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äôposts ‚Äô, ‚Äôbody ‚Äô))
s1_all = s1
for s1 in s1_all :
s2 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äòcomments ‚Äò
WHERE ‚Äòcomments ‚Äò. ‚Äò post_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s1 , ‚Äôposts ‚Äô, ‚Äôid ‚Äô)})
s1 = s1_all
pass
else :
pass
return util . add_warnings ( outputs )
D.6.7 Command get_admin
ForthiscommandweuseatrimmedversionofEnki, whereweremoveda <ul> element
thatdisplaysrecentcommentsinthefile app/views/admin/dashboard/show.html.erb.
def get_admin (conn , inputs ):
util . clear_warnings ()
403
outputs = []
s0 = util . do_sql (conn , " SELECT posts .* , max ( comments .
created_at ), comments . post_id FROM ‚Äòposts ‚Äò INNER JOIN
comments ON comments . post_id = posts .id GROUP BY comments .
post_id , posts .id , posts . title , posts .slug , posts .body ,
posts . body_html , posts . active , posts . approved_comments_count
, posts . cached_tag_list , posts . published_at , posts .
created_at , posts . updated_at , posts . edited_at ORDER BY max (
comments . created_at ) desc LIMIT 5", {})
s0_all = s0
for s0 in s0_all :
s1 = util . do_sql (conn , " SELECT ‚Äòcomments ‚Äò.* FROM ‚Äòcomments
‚Äò WHERE ‚Äòcomments ‚Äò. ‚Äò post_id ‚Äò = :x0 ORDER BY created_at
DESC LIMIT 1", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôposts ‚Äô, ‚Äôid
‚Äô)})
s0 = s0_all
s2 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äòposts ‚Äò", {})
s3 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äòcomments ‚Äò", {})
s4 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äòtags ‚Äò", {})
s5 = util . do_sql (conn , " SELECT ‚Äòposts ‚Äò.* FROM ‚Äòposts ‚Äò WHERE
(1=1) ORDER BY published_at DESC LIMIT 8", {})
outputs . extend ( util . get_data (s5 , ‚Äôposts ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôposts ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s5 , ‚Äôposts ‚Äô, ‚Äôslug ‚Äô))
s5_all = s5
for s5 in s5_all :
s6 = util . do_sql (conn , " SELECT COUNT (*) FROM ‚Äòcomments ‚Äò
WHERE ‚Äòcomments ‚Äò. ‚Äò post_id ‚Äò = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s5 , ‚Äôposts ‚Äô, ‚Äôid ‚Äô)})
s5 = s5_all
pass
return util . add_warnings ( outputs )
404
D.7 Regenerated Code for Blog
D.7.1 Command get_articles
def get_articles (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòarticles ‚Äò.* FROM ‚Äòarticles ‚Äò",
{})
outputs . extend ( util . get_data (s0 , ‚Äô articles ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äô articles ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äô articles ‚Äô, ‚Äôtext ‚Äô))
return util . add_warnings ( outputs )
D.7.2 Command get_article_id
def get_article_id (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT ‚Äòarticles ‚Äò.* FROM ‚Äòarticles ‚Äò
WHERE ‚Äòarticles ‚Äò. ‚Äòid ‚Äò = :x0 LIMIT 1", {‚Äôx0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äô articles ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äô articles ‚Äô, ‚Äôtitle ‚Äô))
outputs . extend ( util . get_data (s0 , ‚Äô articles ‚Äô, ‚Äôtext ‚Äô))
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT ‚Äòcomments ‚Äò.* FROM ‚Äòcomments ‚Äò
WHERE ‚Äòcomments ‚Äò. ‚Äò article_id ‚Äò = :x0", {‚Äôx0 ‚Äô: inputs
[0]})
outputs . extend ( util . get_data (s1 , ‚Äô comments ‚Äô, ‚Äô commenter ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äô comments ‚Äô, ‚Äôbody ‚Äô))
outputs . extend ( util . get_data (s1 , ‚Äô comments ‚Äô, ‚Äô article_id ‚Äô))
else :
pass
return util . add_warnings ( outputs )
405
D.8 RegeneratedCodeforStudentRegistrationSys-
tem
D.8.1 Command liststudentcourses
def liststudentcourses (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT * FROM student WHERE id = :x0",
{‚Äôx0 ‚Äô: inputs [0]})
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT * FROM student WHERE id =: x0
AND password =: x1", {‚Äôx0 ‚Äô: inputs [0] , ‚Äôx1 ‚Äô: inputs [1]})
if util . has_rows (s1):
s2 = util . do_sql (conn , " SELECT * FROM course c JOIN
registration r on r. course_id = c.id WHERE r.
student_id = :x0", {‚Äôx0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s2 , ‚Äô course ‚Äô, ‚Äôid ‚Äô))
outputs . extend ( util . get_data (s2 , ‚Äô course ‚Äô, ‚Äô teacher_id ‚Äô
))
outputs . extend ( util . get_data (s2 , ‚Äô registration ‚Äô, ‚Äô
course_id ‚Äô))
s2_all = s2
for s2 in s2_all :
s3 = util . do_sql (conn , " Select firstname , lastname
from teacher where id = :x0", {‚Äôx0 ‚Äô: util .
get_one_data (s2 , ‚Äô course ‚Äô, ‚Äô teacher_id ‚Äô)})
s4 = util . do_sql (conn , " SELECT count (*) FROM
registration WHERE course_id = :x0", {‚Äôx0 ‚Äô: util
. get_one_data (s2 , ‚Äô course ‚Äô, ‚Äôid ‚Äô)})
s2 = s2_all
pass
else :
pass
else :
406
pass
return util . add_warnings ( outputs )
D.9 Regenerated Code for Synthetic
D.9.1 Command repeat_2
def repeat_2 (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
return util . add_warnings ( outputs )
D.9.2 Command repeat_3
def repeat_3 (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
s3 = util . do_sql (conn , " SELECT * FROM t2", {})
return util . add_warnings ( outputs )
D.9.3 Command repeat_4
def repeat_4 (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t2", {})
407
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
s3 = util . do_sql (conn , " SELECT * FROM t2", {})
s4 = util . do_sql (conn , " SELECT * FROM t2", {})
return util . add_warnings ( outputs )
D.9.4 Command repeat_5
def repeat_5 (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT * FROM t1", {})
s1 = util . do_sql (conn , " SELECT * FROM t2", {})
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
s3 = util . do_sql (conn , " SELECT * FROM t2", {})
s4 = util . do_sql (conn , " SELECT * FROM t2", {})
s5 = util . do_sql (conn , " SELECT * FROM t2", {})
return util . add_warnings ( outputs )
D.9.5 Command nest
def nest_2 (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT * FROM t0", {})
s0_all = s0
for s0 in s0_all :
s1 = util . do_sql (conn , " SELECT * FROM t1", {})
s1_all = s1
for s1 in s1_all :
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
s1 = s1_all
pass
s0 = s0_all
pass
return util . add_warnings ( outputs )
408
D.9.6 Command after_2
def after_2 (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT * FROM t1", {})
s0_all = s0
for s0 in s0_all :
s1 = util . do_sql (conn , " SELECT * FROM t0", {})
s0 = s0_all
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
s2_all = s2
for s2 in s2_all :
s3 = util . do_sql (conn , " SELECT * FROM t0", {})
s2 = s2_all
pass
return util . add_warnings ( outputs )
D.9.7 Command after_3
def after_3 (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT * FROM t1", {})
s0_all = s0
for s0 in s0_all :
s1 = util . do_sql (conn , " SELECT * FROM t0", {})
s0 = s0_all
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
s2_all = s2
for s2 in s2_all :
s3 = util . do_sql (conn , " SELECT * FROM t0", {})
s2 = s2_all
s4 = util . do_sql (conn , " SELECT * FROM t3", {})
s4_all = s4
for s4 in s4_all :
409
s5 = util . do_sql (conn , " SELECT * FROM t0", {})
s4 = s4_all
pass
return util . add_warnings ( outputs )
D.9.8 Command after_4
def after_4 (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT * FROM t1", {})
s0_all = s0
for s0 in s0_all :
s1 = util . do_sql (conn , " SELECT * FROM t0", {})
s0 = s0_all
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
s2_all = s2
for s2 in s2_all :
s3 = util . do_sql (conn , " SELECT * FROM t0", {})
s2 = s2_all
s4 = util . do_sql (conn , " SELECT * FROM t3", {})
s4_all = s4
for s4 in s4_all :
s5 = util . do_sql (conn , " SELECT * FROM t0", {})
s4 = s4_all
s6 = util . do_sql (conn , " SELECT * FROM t4", {})
s6_all = s6
for s6 in s6_all :
s7 = util . do_sql (conn , " SELECT * FROM t0", {})
s6 = s6_all
pass
return util . add_warnings ( outputs )
D.9.9 Command after_5
410
def after_5 (conn , inputs ):
util . clear_warnings ()
outputs = []
s0 = util . do_sql (conn , " SELECT * FROM t1", {})
s0_all = s0
for s0 in s0_all :
s1 = util . do_sql (conn , " SELECT * FROM t0", {})
s0 = s0_all
s2 = util . do_sql (conn , " SELECT * FROM t2", {})
s2_all = s2
for s2 in s2_all :
s3 = util . do_sql (conn , " SELECT * FROM t0", {})
s2 = s2_all
s4 = util . do_sql (conn , " SELECT * FROM t3", {})
s4_all = s4
for s4 in s4_all :
s5 = util . do_sql (conn , " SELECT * FROM t0", {})
s4 = s4_all
s6 = util . do_sql (conn , " SELECT * FROM t4", {})
s6_all = s6
for s6 in s6_all :
s7 = util . do_sql (conn , " SELECT * FROM t0", {})
s6 = s6_all
s8 = util . do_sql (conn , " SELECT * FROM t5", {})
s8_all = s8
for s8 in s8_all :
s9 = util . do_sql (conn , " SELECT * FROM t0", {})
s8 = s8_all
pass
return util . add_warnings ( outputs )
D.9.10 Command example (Section 6.1)
def example_3 (conn , inputs ):
util . clear_warnings ()
411
outputs = []
s0 = util . do_sql (conn , " SELECT * FROM tasks WHERE id = :x0", {‚Äô
x0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s0 , ‚Äôtasks ‚Äô, ‚Äôtitle ‚Äô))
if util . has_rows (s0):
s1 = util . do_sql (conn , " SELECT * FROM comments WHERE
task_id = :x0", {‚Äôx0 ‚Äô: inputs [0]})
outputs . extend ( util . get_data (s1 , ‚Äô comments ‚Äô, ‚Äô content ‚Äô))
s1_all = s1
for s1 in s1_all :
s2 = util . do_sql (conn , " SELECT * FROM users WHERE id =
:x0", {‚Äôx0 ‚Äô: util . get_one_data (s1 , ‚Äô comments ‚Äô, ‚Äô
commenter_id ‚Äô)})
outputs . extend ( util . get_data (s2 , ‚Äôusers ‚Äô, ‚Äôname ‚Äô))
s3 = util . do_sql (conn , " SELECT * FROM tasks WHERE
creator_id = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s1 , ‚Äô
comments ‚Äô, ‚Äô commenter_id ‚Äô)})
outputs . extend ( util . get_data (s3 , ‚Äôtasks ‚Äô, ‚Äôtitle ‚Äô))
s1 = s1_all
s4 = util . do_sql (conn , " SELECT * FROM users WHERE id = :x0"
, {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôtasks ‚Äô, ‚Äô assignee_id ‚Äô)})
outputs . extend ( util . get_data (s4 , ‚Äôusers ‚Äô, ‚Äôname ‚Äô))
s5 = util . do_sql (conn , " SELECT * FROM tasks WHERE
creator_id = :x0", {‚Äôx0 ‚Äô: util . get_one_data (s0 , ‚Äôtasks ‚Äô,
‚Äô assignee_id ‚Äô)})
outputs . extend ( util . get_data (s5 , ‚Äôtasks ‚Äô, ‚Äôtitle ‚Äô))
else :
pass
return util . add_warnings ( outputs )
412
Bibliography
[1] Stack Overflow. http://stackoverflow.com/.
[2] Enki. https://github.com/xaviershay/enki, 2018. Git commit hash
e70af252596f4123761bf389d371fe1b73611b73.
[3] Fulcrum. https://github.com/fulcrum-agile/fulcrum, 2018. Git commit
hash dd4e59ec24c6f45d018fd2436c01836a04b15fef.
[4] Getting started with rails. http://guides.rubyonrails.org/getting_
started.html, 2018.
[5] Kandan ‚Äì modern open source chat.https://github.com/kandanapp/kandan,
2018. Git commit hash 380efafdf220fb7b14a097867a333b37d86e9c0b.
[6] Pldi 2019 konure code. http://people.csail.mit.edu/jiasi/pldi2019.
code/ and https://people.csail.mit.edu/rinard/paper/pldi2019.
code/, 2019.
[7] Software assurance reference dataset. https://samate.nist.gov/SARD/
testsuite.php, 2020.
[8] Railscollab: A project management and collaboration tool inspired by base-
camp. https://github.com/jamesu/railscollab/, 2021. Git commit hash
9f6c8c12c990e39411e060879589006bde086ace.
[9] Todo: Basic rails gtd app.https://github.com/engineyard/todo, 2021. Git
commit hash af9bc2f6e95452c23e9cb2cdb25f8427a41f998c.
[10] Benchmark application source code.http://people.csail.mit.edu/jiasi/
thesis2022.code/, 2022.
[11] Kanban. https://github.com/seanomlor/kanban, 2022. Git commit hash
0660e77aa3734210d06aa2c8e0a444798e8eb862.
[12] F. Aarts, J. De Ruiter, and E. Poll. Formal models of bank cards for free.
In 2013 IEEE Sixth International Conference on Software Testing, Verification
and Validation Workshops, pages 461‚Äì468, March 2013.
[13] Fides Aarts and Frits Vaandrager. Learning I/O Automata, pages 71‚Äì85.
Springer Berlin Heidelberg, Berlin, Heidelberg, 2010.
413
[14] Maaz Bin Safeer Ahmad and Alvin Cheung. Automatically leveraging mapre-
duce frameworks for data-intensive applications. InProceedings of the 2018 In-
ternational Conference on Management of Data, SIGMOD ‚Äô18, page 1205‚Äì1220,
New York, NY, USA, 2018. Association for Computing Machinery.
[15] Maaz Bin Safeer Ahmad, Jonathan Ragan-Kelley, Alvin Cheung, and Shoaib
Kamil. Automatically translating image processing libraries to halide. ACM
Trans. Graph., 38(6), nov 2019.
[16] Alfred V. Aho, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman.Compilers:
Principles, Techniques, and Tools (2nd Edition). Addison-Wesley Longman
Publishing Co., Inc., USA, 2006.
[17] M. H. Alalfi, J. R. Cordy, and T. R. Dean. Wafa: Fine-grained dynamic anal-
ysis of web applications. In2009 11th IEEE International Symposium on Web
Systems Evolution, pages 141‚Äì150, Sept 2009.
[18] Aws Albarghouthi, Sumit Gulwani, and Zachary Kincaid. Recursive program
synthesis. In Natasha Sharygina and Helmut Veith, editors,Computer Aided
Verification, pages 934‚Äì950, Berlin, Heidelberg, 2013. Springer Berlin Heidel-
berg.
[19] Manoli Albert, Jordi Cabot, Cristina G√≥mez, and Vicente Pelechano. Auto-
matic generation of basic behavior schemas from uml class diagrams.Software
& Systems Modeling, 9(1):47‚Äì67, 2010.
[20] Rajeev Alur, Rastislav Bod√≠k, Garvit Juniwal, Milo M. K. Martin, Mukund
Raghothaman, SanjitA.Seshia, RishabhSingh, ArmandoSolar-Lezama, Emina
Torlak, and Abhishek Udupa. Syntax-guided synthesis. InFormal Methods in
Computer-Aided Design, FMCAD 2013, Portland, OR, USA, October 20-23,
2013, pages 1‚Äì8, 2013.
[21] P. Amidon, E. Davis, S. Sidiroglou-Douskos, and M. Rinard. Program frac-
ture and recombination for efficient automatic code reuse. In2015 IEEE High
Performance Extreme Computing Conference (HPEC), pages 1‚Äì6, Sept 2015.
[22] Kijin An and Eli Tilevich.Client Insourcing: Bringing Ops In-House for Seam-
less Re-Engineering of Full-Stack JavaScript Applications, page 179‚Äì189. Asso-
ciation for Computing Machinery, New York, NY, USA, 2020.
[23] Dana Angluin. Learning regular sets from queries and counterexamples.Inf.
Comput., 75(2):87‚Äì106, November 1987.
[24] Dana Angluin and Carl H. Smith. Inductive inference: Theory and methods.
ACM Comput. Surv., 15(3):237‚Äì269, September 1983.
[25] Sruthi Bandhakavi, Prithvi Bisht, P. Madhusudan, and V. N. Venkatakrishnan.
Candid: Preventing sql injection attacks using dynamic candidate evaluations.
414
In Proceedings of the 14th ACM Conference on Computer and Communications
Security, CCS ‚Äô07, pages 12‚Äì24, New York, NY, USA, 2007. ACM.
[26] Gilles Barthe, Juan Manuel Crespo, Sumit Gulwani, Cesar Kunz, and Mark
Marron. From relational verification to simd loop synthesis. In Proceedings
of the 18th ACM SIGPLAN Symposium on Principles and Practice of Parallel
Programming, PPoPP ‚Äô13, pages 123‚Äì134, New York, NY, USA, 2013. ACM.
[27] Osbert Bastani, Rahul Sharma, Alex Aiken, and Percy Liang. Synthesizing pro-
gram input grammars. InProceedings of the 38th ACM SIGPLAN Conference
on Programming Language Design and Implementation, PLDI 2017, Barcelona,
Spain, June 18-23, 2017, pages 95‚Äì110, 2017.
[28] Osbert Bastani, Rahul Sharma, Alex Aiken, and Percy Liang. Active learning of
points-to specifications. InProceedings of the 39th ACM SIGPLAN Conference
on Programming Language Design and Implementation, PLDI 2018, pages 678‚Äì
692, New York, NY, USA, 2018. ACM.
[29] Michael Bayer. Sqlalchemy. In Amy Brown and Greg Wilson, editors, The
Architecture of Open Source Applications Volume II: Structure, Scale, and a
Few More Fearless Hacks. aosabook.org, 2012.
[30] L. A. Belady and M. M. Lehman. A model of large program development.IBM
Systems Journal, 15(3):225‚Äì252, 1976.
[31] Tewodros A. Beyene, Swarat Chaudhuri, Corneliu Popeea, and Andrey Ry-
balchenko. Recursive games for compositional program synthesis. InVerified
Software: Theories, Tools, and Experiments - 7th International Conference,
VSTTE 2015, San Francisco, CA, USA, July 18-19, 2015. Revised Selected
Papers, pages 19‚Äì39, 2015.
[32] A. W. Biermann, R. I. Baum, and F. E. Petry. Speeding up the synthesis of
programs from traces.IEEE Trans. Comput., 24(2):122‚Äì136, February 1975.
[33] Marina Billes, Anders M√∏ller, and Michael Pradel. Systematic black-box analy-
sis of collaborative web applications. InProceedings of the 38th ACM SIGPLAN
Conference on Programming Language Design and Implementation, PLDI 2017,
page 171‚Äì184, New York, NY, USA, 2017. Association for Computing Machin-
ery.
[34] Prithvi Bisht, P. Madhusudan, and V. N. Venkatakrishnan. Candid: Dynamic
candidate evaluations for automatic prevention of sql injection attacks.ACM
Trans. Inf. Syst. Secur., 13(2):14:1‚Äì14:39, March 2010.
[35] Angela Bonifati, Radu Ciucanu, and Slawek Staworko. Interactive join query
inference with jim.Proc. VLDB Endow., 7(13):1541‚Äì1544, August 2014.
415
[36] James F. Bowring, James M. Rehg, and Mary Jean Harrold. Active learning for
automatic classification of software behavior. InProceedings of the 2004 ACM
SIGSOFT International Symposium on Software Testing and Analysis, ISSTA
‚Äô04, pages 195‚Äì205, New York, NY, USA, 2004. ACM.
[37] Aaron R Bradley and Zohar Manna. The calculus of computation: decision
procedures with applications to verification. Springer Science & Business Media,
2007.
[38] Marco Brambilla, Jordi Cabot, and Manuel Wimmer. Model-driven software
engineering in practice.Synthesis Lectures on Software Engineering, 1(1):1‚Äì182,
2012.
[39] Cristian BuciluÀá a, Rich Caruana, and Alexandru Niculescu-Mizil. Model com-
pression. In Proceedings of the 12th ACM SIGKDD International Conference
on Knowledge Discovery and Data Mining, KDD ‚Äô06, pages 535‚Äì541, New York,
NY, USA, 2006. ACM.
[40] M. Burtscher, I. Ganusov, S. J. Jackson, J. Ke, P. Ratanaworabhan, and N. B.
Sam. The vpc trace-compression algorithms.IEEE Transactions on Computers,
54(11):1329‚Äì1344, Nov 2005.
[41] Juan Caballero, Pongsin Poosankam, Christian Kreibich, and Dawn Song. Dis-
patcher: Enabling active botnet infiltration using automatic protocol reverse-
engineering. In Proceedings of the 16th ACM Conference on Computer and
Communications Security, CCS ‚Äô09, pages 621‚Äì634, New York, NY, USA, 2009.
ACM.
[42] Juan Caballero and Dawn Song. Automatic protocol reverse-engineering: Mes-
sage format extraction and field semantics inference. Computer Networks,
57(2):451 ‚Äì 474, 2013. Botnet Activity: Analysis, Detection and Shutdown.
[43] Juan Caballero, Heng Yin, Zhenkai Liang, and Dawn Song. Polyglot: Auto-
matic extraction of protocol message format using dynamic binary analysis. In
Proceedings of the 14th ACM Conference on Computer and Communications
Security, CCS ‚Äô07, pages 317‚Äì329, New York, NY, USA, 2007. ACM.
[44] Cristian Cadar, Vijay Ganesh, Peter M. Pawlowski, David L. Dill, and Daw-
son R. Engler. Exe: Automatically generating inputs of death. InProceedings
of the 13th ACM Conference on Computer and Communications Security, CCS
‚Äô06, pages 322‚Äì335, New York, NY, USA, 2006. ACM.
[45] Jos√© P. Cambronero, Thurston H. Y. Dang, Nikos Vasilakis, Jiasi Shen, Jerry
Wu, and Martin C. Rinard. Active learning for software engineering. InPro-
ceedings of the 2019 ACM SIGPLAN International Symposium on New Ideas,
New Paradigms, and Reflections on Programming and Software, Onward! 2019,
page 62‚Äì78, New York, NY, USA, 2019. Association for Computing Machinery.
416
[46] JavierLuisC√°novasIzquierdoandJes√∫sGarc√≠aMolina. Extractingmodelsfrom
source code in software modernization.Softw. Syst. Model., 13(2):713‚Äì734, May
2014.
[47] Michael Carbin, Sasa Misailovic, Michael Kling, and Martin C. Rinard. De-
tecting and escaping infinite loops with jolt. InProceedings of the 25th Euro-
pean conference on Object-oriented programming, ECOOP‚Äô11, pages 609‚Äì633.
Springer-Verlag, 2011.
[48] Sofia Cassel, Falk Howar, Bengt Jonsson, and Bernhard Steffen. Active learning
for extended finite state machines.Formal Aspects of Computing, 28(2):233‚Äì
263, 2016.
[49] Geetam Chawla, Navneet Aman, Raghavan Komondoor, Ashish Bokil, and
Nilesh Kharat. Verification of orm-based controllers by summary inference.
In 2022 IEEE/ACM 44th International Conference on Software Engineering
(ICSE), pages 2340‚Äì2351, 2022.
[50] Qiaochu Chen, Aaron Lamoreaux, Xinyu Wang, Greg Durrett, Osbert Bastani,
and Isil Dillig. Web question answering with neurosymbolic program synthe-
sis. In Proceedings of the 42nd ACM SIGPLAN International Conference on
Programming Language Design and Implementation, PLDI 2021, page 328‚Äì343,
New York, NY, USA, 2021. Association for Computing Machinery.
[51] Qiaochu Chen, Xinyu Wang, Xi Ye, Greg Durrett, and Isil Dillig. Multi-modal
synthesis of regular expressions. In Proceedings of the 41st ACM SIGPLAN
Conference on Programming Language Design and Implementation, PLDI 2020,
page 487‚Äì502, New York, NY, USA, 2020. Association for Computing Machin-
ery.
[52] Alvin Cheung, Armando Solar-Lezama, and Samuel Madden. Optimizing
database-backed applications with query synthesis. InProceedings of the 34th
ACM SIGPLAN Conference on Programming Language Design and Implemen-
tation, PLDI ‚Äô13, pages 3‚Äì14, New York, NY, USA, 2013. ACM.
[53] T. S. Chow. Testing software design modeled by finite-state machines.IEEE
Trans. Softw. Eng., 4(3):178‚Äì187, May 1978.
[54] Shumo Chu, Chenglong Wang, Konstantin Weitz, and Alvin Cheung. Cosette:
An automated prover for SQL. In CIDR 2017, 8th Biennial Conference on
Innovative Data Systems Research, Chaminade, CA, USA, January 8-11, 2017,
Online Proceedings, 2017.
[55] J√ºrgen Cito, Jiasi Shen, and Martin Rinard. An empirical study on the impact
of deimplicitization on comprehension in programs using application frame-
works. InProceedings of the 17th International Conference on Mining Software
Repositories, MSR ‚Äô20, page 598‚Äì601, 2020. Registered report.
417
[56] Anthony Cleve, Nesrine Noughi, and Jean-Luc Hainaut. Dynamic program
analysis for database reverse engineering. InGenerative and Transformational
Techniques in Software Engineering IV, pages 297‚Äì321. Springer, 2013.
[57] Yossi Cohen and Yishai A. Feldman. Automatic high-quality reengineering of
database programs by abstraction, transformation and reimplementation.ACM
Trans. Softw. Eng. Methodol., 12(3):285‚Äì316, July 2003.
[58] Bas Cornelissen, Andy Zaidman, Arie van Deursen, Leon Moonen, and Rainer
Koschke. A systematic survey of program comprehension through dynamic
analysis. IEEE Trans. Softw. Eng., 35(5):684‚Äì702, September 2009.
[59] Mark W. Craven and Jude W. Shavlik. Extracting tree-structured representa-
tions of trained networks. InProceedings of the 8th International Conference
on Neural Information Processing Systems, NIPS‚Äô95, pages 24‚Äì30, Cambridge,
MA, USA, 1995. MIT Press.
[60] Kathi Hogshead Davis and Peter H. Aiken. Data reverse engineering: A his-
torical survey. In Proceedings of the Seventh Working Conference on Reverse
Engineering (WCRE‚Äô00), WCRE ‚Äô00, pages 70‚Äì, Washington, DC, USA, 2000.
IEEE Computer Society.
[61] Leonardo De Moura and Nikolaj Bj√∏rner. Z3: An efficient smt solver. In
Proceedings of the Theory and Practice of Software, 14th International Con-
ference on Tools and Algorithms for the Construction and Analysis of Sys-
tems, TACAS‚Äô08/ETAPS‚Äô08, page 337‚Äì340, Berlin, Heidelberg, 2008. Springer-
Verlag.
[62] Joeri De Ruiter and Erik Poll. Protocol state fuzzing of tls implementations. In
Proceedings of the 24th USENIX Conference on Security Symposium, SEC‚Äô15,
pages 193‚Äì206, Berkeley, CA, USA, 2015. USENIX Association.
[63] Django. The web framework for perfectionists with deadlines | django.
https://www.djangoproject.com/, 2018.
[64] Rui Dong, Zhicheng Huang, Ian Iong Lam, Yan Chen, and Xinyu Wang. We-
brobot: Web robotic process automation using interactive programming-by-
demonstration. InProceedings of the 43th ACM SIGPLAN Conference on Pro-
gramming Language Design and Implementation, PLDI 2022, 2022.
[65] Kevin Ellis, Armando Solar-Lezama, and Josh Tenenbaum. Sampling for
bayesian program learning. InAdvances in Neural Information Processing Sys-
tems 29: Annual Conference on Neural Information Processing Systems 2016,
December 5-10, 2016, Barcelona, Spain, pages 1289‚Äì1297, 2016.
[66] E. N. Elnozahy. Address trace compression through loop detection and reduc-
tion. InProceedings of the 1999 ACM SIGMETRICS International Conference
on Measurement and Modeling of Computer Systems, SIGMETRICS ‚Äô99, pages
214‚Äì215, New York, NY, USA, 1999. ACM.
418
[67] Yu Feng, Ruben Martins, Osbert Bastani, and Isil Dillig. Program synthesis
using conflict-driven learning. InProceedings of the 39th ACM SIGPLAN Con-
ference on Programming Language Design and Implementation, PLDI 2018,
Philadelphia, PA, USA, June 18-22, 2018, pages 420‚Äì435, 2018.
[68] Yu Feng, Ruben Martins, Jacob Van Geffen, Isil Dillig, and Swarat Chaud-
huri. Component-based synthesis of table consolidation and transformation
tasks from examples. In Proceedings of the 38th ACM SIGPLAN Conference
on Programming Language Design and Implementation, PLDI 2017, Barcelona,
Spain, June 18-23, 2017, pages 422‚Äì436, 2017.
[69] John K. Feser, Swarat Chaudhuri, and Isil Dillig. Synthesizing data structure
transformations from input-output examples. InProceedings of the 36th ACM
SIGPLAN Conference on Programming Language Design and Implementation,
Portland, OR, USA, June 15-17, 2015, pages 229‚Äì239, 2015.
[70] Paul FiterƒÉu-Bro≈ütean, Ramon Janssen, and Frits Vaandrager. Combining
Model Learning and Model Checking to Analyze TCP Implementations, pages
454‚Äì471. Springer International Publishing, Cham, 2016.
[71] X. Fu, X. Lu, B. Peltsverger, S. Chen, K. Qian, and L. Tao. A static analysis
framework for detecting sql injection vulnerabilities. InComputer Software and
Applications Conference, 2007. COMPSAC 2007. 31st Annual International,
volume 1 ofCOMPSAC 2007, pages 87‚Äì96, July 2007.
[72] Rub√©n Fuentes-Fern√°ndez, Juan Pav√≥n, and Francisco Garijo. A model-driven
process for the modernization of component-based systems.Sci. Comput. Pro-
gram., 77(3):247‚Äì269, March 2012.
[73] Vijay Ganesh, Tim Leek, and Martin Rinard. Taint-based directed whitebox
fuzzing. In Proceedings of the 31st International Conference on Software En-
gineering, ICSE ‚Äô09, pages 474‚Äì484, Washington, DC, USA, 2009. IEEE Com-
puter Society.
[74] TimonGehr, DimitarDimitrov, andMartinT.Vechev. Learningcommutativity
specifications. InComputer Aided Verification - 27th International Conference,
CAV 2015, San Francisco, CA, USA, July 18-24, 2015, Proceedings, Part I,
pages 307‚Äì323, 2015.
[75] Patrice Godefroid, Nils Klarlund, and Koushik Sen. Dart: Directed automated
random testing. In Proceedings of the 2005 ACM SIGPLAN Conference on
Programming Language Design and Implementation, PLDI ‚Äô05, pages 213‚Äì223,
New York, NY, USA, 2005. ACM.
[76] Patrice Godefroid, Michael Y. Levin, and David Molnar. Sage: Whitebox
fuzzing for security testing.Queue, 10(1):20:20‚Äì20:27, January 2012.
419
[77] Patrice Godefroid and Ankur Taly. Automated synthesis of symbolic instruc-
tion encodings from i/o samples. InProceedings of the 33rd ACM SIGPLAN
Conference on Programming Language Design and Implementation, PLDI ‚Äô12,
pages 441‚Äì452, New York, NY, USA, 2012. ACM.
[78] Olga Grinchtein, Bengt Jonsson, and Martin Leucker. Learning of event-
recording automata. Theor. Comput. Sci., 411(47):4029‚Äì4054, October 2010.
[79] Sumit Gulwani. Dimensions in program synthesis. InProceedings of the 12th
International ACM SIGPLAN Symposium on Principles and Practice of Declar-
ative Programming, PPDP ‚Äô10, page 13‚Äì24, New York, NY, USA, 2010. Asso-
ciation for Computing Machinery.
[80] Sumit Gulwani. Automating string processing in spreadsheets using input-
output examples. InProceedings of the 38th Annual ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages, POPL ‚Äô11, pages 317‚Äì
330, New York, NY, USA, 2011. ACM.
[81] Sumit Gulwani, Susmit Jha, Ashish Tiwari, and Ramarathnam Venkatesan.
Synthesis of loop-free programs. InProceedings of the 32Nd ACM SIGPLAN
Conference on Programming Language Design and Implementation, PLDI ‚Äô11,
pages 62‚Äì73, New York, NY, USA, 2011. ACM.
[82] Sumit Gulwani, Oleksandr Polozov, and Rishabh Singh. Program synthesis.
Foundations and Trends in Programming Languages, 4(1-2):1‚Äì119, 2017.
[83] B.P.Gupta, D.Vira, andS.Sudarshan. X-data: Generatingtestdataforkilling
sql mutants. In2010 IEEE 26th International Conference on Data Engineering
(ICDE 2010), pages 876‚Äì879, March 2010.
[84] Raju Halder and Agostino Cortesi. Obfuscation-based analysis of sql injec-
tion attacks. In Proceedings of the The IEEE Symposium on Computers and
Communications, ISCC ‚Äô10, pages 931‚Äì938, Washington, DC, USA, 2010. IEEE
Computer Society.
[85] William G. J. Halfond and Alessandro Orso. Amnesia: Analysis and monitoring
for neutralizing sql-injection attacks. In Proceedings of the 20th IEEE/ACM
International Conference on Automated Software Engineering, ASE ‚Äô05, pages
174‚Äì183, New York, NY, USA, 2005. ACM.
[86] Hiroshige Hayashizaki, Peng Wu, Hiroshi Inoue, Mauricio J. Serrano, and
Toshio Nakatani. Improving the performance of trace-based systems by false
loopfiltering. In Proceedings of the Sixteenth International Conference on Archi-
tectural Support for Programming Languages and Operating Systems, ASPLOS
XVI, pages 405‚Äì418, New York, NY, USA, 2011. ACM.
420
[87] Stefan Heule, Manu Sridharan, and Satish Chandra. Mimic: computing models
for opaque code. In Proceedings of the 2015 10th Joint Meeting on Founda-
tions of Software Engineering, ESEC/FSE 2015, Bergamo, Italy, August 30 -
September 4, 2015, pages 710‚Äì720, 2015.
[88] Geoffrey Hinton, Oriol Vinyals, and Jeff Dean. Distilling the knowledge in a
neural network.arXiv preprint arXiv:1503.02531, 2015.
[89] Malte Isberner, Falk Howar, and Bernhard Steffen. The TTT Algorithm:
A Redundancy-Free Approach to Active Automata Learning, pages 307‚Äì322.
Springer International Publishing, Cham, 2014.
[90] Jinseong Jeon, Xiaokang Qiu, Jonathan Fetter-Degges, Jeffrey S. Foster, and
ArmandoSolar-Lezama. Synthesizingframeworkmodelsforsymbolicexecution.
In Proceedings of the 38th International Conference on Software Engineering,
ICSE 2016, Austin, TX, USA, May 14-22, 2016, pages 156‚Äì167, 2016.
[91] Jinseong Jeon, Xiaokang Qiu, Jeffrey S. Foster, and Armando Solar-Lezama.
Jsketch: sketching for java. InProceedings of the 2015 10th Joint Meeting on
Foundations of Software Engineering, ESEC/FSE 2015, Bergamo, Italy, August
30 - September 4, 2015, pages 934‚Äì937, 2015.
[92] Susmit Jha, Sumit Gulwani, Sanjit A. Seshia, and Ashish Tiwari. Oracle-guided
component-based program synthesis. InProceedings of the 32Nd ACM/IEEE
International Conference on Software Engineering - Volume 1, ICSE ‚Äô10, pages
215‚Äì224, New York, NY, USA, 2010. ACM.
[93] Ruyi Ji, Yican Sun, Yingfei Xiong, and Zhenjiang Hu. Guiding dynamic pro-
graming via structural probability for accelerating programming by example.
Proc. ACM Program. Lang., 4(OOPSLA), November 2020.
[94] Rajeev Joshi, Greg Nelson, and Keith Randall. Denali: A goal-directed super-
optimizer. InProceedings of the ACM SIGPLAN 2002 Conference on Program-
ming Language Design and Implementation, PLDI ‚Äô02, pages 304‚Äì314, New
York, NY, USA, 2002. ACM.
[95] Nenad Jovanovic, Christopher Kruegel, and Engin Kirda. Pixy: A static anal-
ysis tool for detecting web application vulnerabilities (short paper). InPro-
ceedings of the 2006 IEEE Symposium on Security and Privacy, SP ‚Äô06, pages
258‚Äì263, Washington, DC, USA, 2006. IEEE Computer Society.
[96] Shoaib Kamil, Alvin Cheung, Shachar Itzhaky, and Armando Solar-Lezama.
Verified lifting of stencil computations. In Proceedings of the 37th ACM
SIGPLAN Conference on Programming Language Design and Implementation,
PLDI ‚Äô16, page 711‚Äì726, New York, NY, USA, 2016. Association for Computing
Machinery.
421
[97] Alain Ketterlin and Philippe Clauss. Prediction and trace compression of data
access addresses through nested loop recognition. In Proceedings of the 6th
Annual IEEE/ACM International Symposium on Code Generation and Opti-
mization, CGO ‚Äô08, pages 94‚Äì103, New York, NY, USA, 2008. ACM.
[98] Michael Kling, Sasa Misailovic, Michael Carbin, and Martin Rinard. Bolt: on-
demand infinite loop escape in unmodified binaries. InProceedings of the ACM
international conference on Object oriented programming systems languages and
applications, OOPSLA ‚Äô12‚Äô, pages 431‚Äì450. ACM, 2012.
[99] M. Kobayashi. Dynamic characteristics of loops. IEEE Trans. Comput.,
33(2):125‚Äì132, February 1984.
[100] Paul Krogmeier, Umang Mathur, Adithya Murali, P. Madhusudan, and Mahesh
Viswanathan. Decidable synthesis of programs with uninterpreted functions.
In Shuvendu K. Lahiri and Chao Wang, editors,Computer Aided Verification,
pages 634‚Äì657, Cham, 2020. Springer International Publishing.
[101] Sumith Kulal, Panupong Pasupat, Kartik Chandra, Mina Lee, Oded Padon,
Alex Aiken, and Percy S Liang. Spoc: Search-based pseudocode to code. In
H. Wallach, H. Larochelle, A. Beygelzimer, F. d'Alch√©-Buc, E. Fox, and R. Gar-
nett, editors, Advances in Neural Information Processing Systems, volume 32.
Curran Associates, Inc., 2019.
[102] Mina Lee, Sunbeom So, and Hakjoo Oh. Synthesizing regular expressions from
examples for introductory automata assignments. InProceedings of the 2016
ACM SIGPLAN International Conference on Generative Programming: Con-
cepts and Experiences, GPCE 2016, page 70‚Äì80, New York, NY, USA, 2016.
Association for Computing Machinery.
[103] Woosuk Lee, Kihong Heo, Rajeev Alur, and Mayur Naik. Accelerating search-
based program synthesis using learned probabilistic models.SIGPLAN Not.,
53(4):436‚Äì449, June 2018.
[104] V. Benjamin Livshits and Monica S. Lam. Finding security vulnerabilities in
java applications with static analysis. InProceedings of the 14th Conference on
USENIX Security Symposium - Volume 14, SSYM‚Äô05, pages 18‚Äì18, Berkeley,
CA, USA, 2005. USENIX Association.
[105] Fan Long, Vijay Ganesh, Michael Carbin, Stelios Sidiroglou, and Martin Ri-
nard. Automatic input rectification. In Proceedings of the 34th International
Conference on Software Engineering, ICSE ‚Äô12, pages 80‚Äì90, Piscataway, NJ,
USA, 2012. IEEE Press.
[106] Lucia, David Lo, Lingxiao Jiang, and Aditya Budi. Active refinement of clone
anomaly reports. InProceedings of the 34th International Conference on Soft-
ware Engineering, ICSE ‚Äô12, page 397‚Äì407. IEEE Press, 2012.
422
[107] Charith Mendis, Jeffrey Bosboom, Kevin Wu, Shoaib Kamil, Jonathan Ragan-
Kelley, SylvainParis, QinZhao, andSamanAmarasinghe. Helium: Liftinghigh-
performance stencil kernels from stripped x86 binaries to halide dsl code. In
Proceedings of the 36th ACM SIGPLAN Conference on Programming Language
Design and Implementation, PLDI ‚Äô15, pages 391‚Äì402, New York, NY, USA,
2015. ACM.
[108] Edward F Moore. Gedanken-experiments on sequential machines. Automata
studies, 34:129‚Äì153, 1956.
[109] Tipp Moseley, Daniel A. Connors, Dirk Grunwald, and Ramesh Peri. Identi-
fying potential parallelism via loop-centric profiling. InProceedings of the 4th
International Conference on Computing Frontiers, CF ‚Äô07, pages 143‚Äì152, New
York, NY, USA, 2007. ACM.
[110] NesrineNoughi, MarcoMori, LoupMeurice, andAnthonyCleve. Understanding
the database manipulation behavior of programs. InProceedings of the 22Nd
International Conference on Program Comprehension, ICPC 2014, pages 64‚Äì67,
New York, NY, USA, 2014. ACM.
[111] Peter-Michael Osera and Steve Zdancewic. Type-and-example-directed pro-
gram synthesis. In Proceedings of the 36th ACM SIGPLAN Conference on
Programming Language Design and Implementation, PLDI ‚Äô15, page 619‚Äì630,
New York, NY, USA, 2015. Association for Computing Machinery.
[112] Shankara Pailoor, Yuepeng Wang, Xinyu Wang, and Isil Dillig. Synthesizing
data structure refinements from integrity constraints. InProceedings of the 42nd
ACM SIGPLAN International Conference on Programming Language Design
and Implementation, PLDI 2021, page 574‚Äì587, New York, NY, USA, 2021.
Association for Computing Machinery.
[113] Daniel Perelman, Sumit Gulwani, Dan Grossman, and Peter Provost. Test-
driven synthesis. In Proceedings of the 35th ACM SIGPLAN Conference on
Programming Language Design and Implementation, PLDI ‚Äô14, pages 408‚Äì418,
New York, NY, USA, 2014. ACM.
[114] Jeff Perkins, Jordan Eikenberry, Alessandro Coglio, Daniel Willenson, Stelios
Sidiroglou-Douskos, and Martin Rinard. Autorand: Automatic keyword ran-
domization to prevent injection attacks. InProceedings of the 13th International
Conference on Detection of Intrusions and Malware, and Vulnerability Assess-
ment - Volume 9721, DIMVA 2016, pages 37‚Äì57, New York, NY, USA, 2016.
Springer-Verlag New York, Inc.
[115] Long H. Pham, Ly Ly Tran Thi, and Jun Sun. Assertion generation through
active learning. InProceedings of the 39th International Conference on Software
Engineering Companion, ICSE-C ‚Äô17, pages 155‚Äì157, Piscataway, NJ, USA,
2017. IEEE Press.
423
[116] Nadia Polikarpova, Ivan Kuraj, and Armando Solar-Lezama. Program synthesis
from polymorphic refinement types. InProceedings of the 37th ACM SIGPLAN
Conference on Programming Language Design and Implementation, PLDI 2016,
Santa Barbara, CA, USA, June 13-17, 2016, pages 522‚Äì538, 2016.
[117] Yewen Pu, Zachery Miranda, Armando Solar-Lezama, and Leslie Kaelbling.
Selecting representative examples for program synthesis. InProceedings of the
35th International Conference on Machine Learning, volume 80 ofProceedings
of Machine Learning Research, pages 4161‚Äì4170. PMLR, 10‚Äì15 Jul 2018.
[118] D. Qi, W. N. Sumner, F. Qin, M. Zheng, X. Zhang, and A. Roychoudhury.
Modeling software execution environment. In2012 19th Working Conference
on Reverse Engineering, pages 415‚Äì424, Oct 2012.
[119] Arjun Radhakrishna, Nicholas V. Lewchenko, Shawn Meier, Sergio Mover, Kr-
ishna Chaitanya Sripada, Damien Zufferey, Bor-Yuh Evan Chang, and Pavol
ƒåern√Ω. Droidstar: Callback typestates for android classes. In Proceedings of
the 40th International Conference on Software Engineering, ICSE ‚Äô18, pages
1160‚Äì1170, New York, NY, USA, 2018. ACM.
[120] Harald Raffelt, Bernhard Steffen, and Therese Berg. Learnlib: A library for au-
tomata learning and experimentation. InProceedings of the 10th International
Workshop on Formal Methods for Industrial Critical Systems, FMICS ‚Äô05, pages
62‚Äì71, New York, NY, USA, 2005. ACM.
[121] Jonathan Ragan-Kelley, Connelly Barnes, Andrew Adams, Sylvain Paris, Fr√©do
Durand, and Saman Amarasinghe. Halide: A language and compiler for opti-
mizing parallelism, locality, and recomputation in image processing pipelines.
In Proceedings of the 34th ACM SIGPLAN Conference on Programming Lan-
guage Design and Implementation, PLDI ‚Äô13, pages 519‚Äì530, New York, NY,
USA, 2013. ACM.
[122] Ruby On Rails. Ruby on rails | a web-application framework that includes
everything needed to create database-backed web applications according to the
model-view-controller (mvc) pattern. https://rubyonrails.org/, 2018.
[123] George Reese. Database Programming with JDBC and JAVA. O‚ÄôReilly Media,
Inc., 2000.
[124] Alex Renda, Yi Ding, and Michael Carbin. Programming with neural surrogates
of programs. In Proceedings of the 2021 ACM SIGPLAN International Sym-
posium on New Ideas, New Paradigms, and Reflections on Programming and
Software, Onward! 2021, page 18‚Äì38, New York, NY, USA, 2021. Association
for Computing Machinery.
[125] Martin C. Rinard. Living in the comfort zone. InProceedings of the 22nd An-
nual ACM SIGPLAN Conference on Object-Oriented Programming, Systems,
424
Languages, and Applications, OOPSLA 2007, October 21-25, 2007, Montreal,
Quebec, Canada, pages 611‚Äì622, 2007.
[126] Martin C. Rinard, Jiasi Shen, and Varun Mangalick. Active learning for in-
ference and regeneration of computer programs that store and retrieve data.
In Proceedings of the 2018 ACM SIGPLAN International Symposium on New
Ideas, New Paradigms, and Reflections on Programming and Software, Onward!
2018, pages 12‚Äì28, New York, NY, USA, 2018. ACM.
[127] Gabriel Rodr√≠guez, Jos√© M. Andi√≥n, Mahmut T. Kandemir, and Juan Touri√±o.
Trace-based affine reconstruction of codes. In Proceedings of the 2016 Inter-
national Symposium on Code Generation and Optimization, CGO ‚Äô16, pages
139‚Äì149, New York, NY, USA, 2016. ACM.
[128] √ìscar S√°nchez Ram√≥n, Jes√∫s S√°nchez Cuadrado, and Jes√∫s Garc√≠a Molina.
Model-driven reverse engineering of legacy graphical user interfaces.Automated
Software Engg., 21(2):147‚Äì186, April 2014.
[129] Yukinori Sato, Yasushi Inoguchi, and Tadao Nakamura. On-the-fly detection of
precise loop nests across procedures on a dynamic binary translation system. In
Proceedings of the 8th ACM International Conference on Computing Frontiers,
CF ‚Äô11, pages 25:1‚Äì25:10, New York, NY, USA, 2011. ACM.
[130] Stephen R. Schach. Object-Oriented and Classical Software Engineering.
McGraw-Hill, Inc., New York, NY, USA, 7 edition, 2007.
[131] Douglas C Schmidt. Model-driven engineering. 2006.
[132] Koushik Sen, Darko Marinov, and Gul Agha. Cute: A concolic unit testing en-
gine for c. InProceedings of the 10th European Software Engineering Conference
Held Jointly with 13th ACM SIGSOFT International Symposium on Founda-
tions of Software Engineering, ESEC/FSE-13, pages 263‚Äì272, New York, NY,
USA, 2005. ACM.
[133] Burr Settles. Active learning literature survey. Computer Sciences Technical
Report 1648, University of Wisconsin‚ÄìMadison, 2009.
[134] Jiasi Shen and Martin Rinard. Using dynamic monitoring to synthesize mod-
els of applications that access databases. Technical report, September 2018.
http://hdl.handle.net/1721.1/118184.
[135] Jiasi Shen and Martin Rinard. Using active learning to synthesize models of
applications that access databases. InProceedings of the 40th ACM SIGPLAN
Conference on Programming Language Design and Implementation, PLDI ‚Äô19.
ACM, 2019.
[136] Jiasi Shen and Martin Rinard. Active loop detection for appli-
cations that access databases. Technical report, November 2021.
https://hdl.handle.net/1721.1/138144.
425
[137] Jiasi Shen, Martin Rinard, and Nikos Vasilakis. Automatic synthesis of par-
allel unix commands and pipelines with kumquat. InProceedings of the 27th
ACM SIGPLAN Symposium on Principles and Practice of Parallel Program-
ming, PPoPP ‚Äô22, page 431‚Äì432, New York, NY, USA, 2022. Association for
Computing Machinery.
[138] Jiasi Shen and Martin C. Rinard. Active learning for inference and regeneration
of applications that access databases.ACM Trans. Program. Lang. Syst., 42(4),
January 2021.
[139] Xujie Si, Woosuk Lee, Richard Zhang, Aws Albarghouthi, Paraschos Koutris,
and Mayur Naik. Syntax-guided synthesis of datalog programs. InProceedings
of the 2018 26th ACM Joint Meeting on European Software Engineering Confer-
ence and Symposium on the Foundations of Software Engineering, ESEC/FSE
2018, page 515‚Äì527, New York, NY, USA, 2018. Association for Computing
Machinery.
[140] Stelios Sidiroglou-Douskos, Eric Lahtinen, Nathan Rittenhouse, Paolo Piselli,
Fan Long, Deokhwan Kim, and Martin Rinard. Targeted automatic integer
overflow discovery using goal-directed conditional branch enforcement. InPro-
ceedings of the Twentieth International Conference on Architectural Support for
Programming Languages and Operating Systems, ASPLOS ‚Äô15, pages 473‚Äì486,
New York, NY, USA, 2015. ACM.
[141] Rishabh Singh and Armando Solar-Lezama. Synthesizing data structure ma-
nipulations from storyboards. InProceedings of the 19th ACM SIGSOFT Sym-
posium and the 13th European Conference on Foundations of Software Engi-
neering, ESEC/FSE ‚Äô11, pages 289‚Äì299, New York, NY, USA, 2011. ACM.
[142] Calvin Smith and Aws Albarghouthi. Mapreduce program synthesis. InPro-
ceedings of the 37th ACM SIGPLAN Conference on Programming Language
Design and Implementation, PLDI ‚Äô16, page 326‚Äì340, New York, NY, USA,
2016. Association for Computing Machinery.
[143] Sunbeom So and Hakjoo Oh. Synthesizing imperative programs from examples
guided by static analysis. In Francesco Ranzato, editor,Static Analysis, pages
364‚Äì381, Cham, 2017. Springer International Publishing.
[144] Sunbeom So and Hakjoo Oh. Synthesizing pattern programs from examples. In
Proceedings of the 27th International Joint Conference on Artificial Intelligence,
IJCAI‚Äô18, page 1618‚Äì1624. AAAI Press, 2018.
[145] Armando Solar-Lezama, Liviu Tancau, Rastislav Bodik, Sanjit Seshia, and Vi-
jay Saraswat. Combinatorial sketching for finite programs. InProceedings of
the 12th International Conference on Architectural Support for Programming
Languages and Operating Systems, ASPLOS XII, pages 404‚Äì415, New York,
NY, USA, 2006. ACM.
426
[146] Saurabh Srivastava, Sumit Gulwani, and Jeffrey S. Foster. From program verifi-
cationtoprogramsynthesis. In Proceedings of the 37th Annual ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages, POPL ‚Äô10, page
313‚Äì326, New York, NY, USA, 2010. Association for Computing Machinery.
[147] Saurabh Srivastava, Sumit Gulwani, and Jeffrey S. Foster. Template-based
program verification and program synthesis.International Journal on Software
Tools for Technology Transfer, 15(5):497‚Äì518, 2013.
[148] Ankur Taly, Sumit Gulwani, and Ashish Tiwari. Synthesizing switching logic
usingconstraintsolving. International Journal on Software Tools for Technology
Transfer, 13(6):519‚Äì535, 2011.
[149] H. Tanno, X. Zhang, T. Hoshino, and K. Sen. Tesma and catg: Automated
test generation tools for models of enterprise applications. In2015 IEEE/ACM
37th IEEE International Conference on Software Engineering, volume 2, pages
717‚Äì720, May 2015.
[150] Geoffrey G. Towell and Jude W. Shavlik. Extracting refined rules from
knowledge-based neural networks.Mach. Learn., 13(1):71‚Äì101, October 1993.
[151] Florian Tram√®r, Fan Zhang, Ari Juels, Michael K. Reiter, and Thomas Risten-
part. Stealing machine learning models via prediction apis. In25th USENIX
Security Symposium (USENIX Security 16), pages 601‚Äì618, Austin, TX, 2016.
USENIX Association.
[152] J. Tubella and A. Gonzalez. Control speculation in multithreaded processors
through dynamic loop detection. InProceedings 1998 Fourth International Sym-
posium on High-Performance Computer Architecture, pages 14‚Äì23, Feb 1998.
[153] Frits Vaandrager. Model learning.Commun. ACM, 60(2):86‚Äì95, January 2017.
[154] Nikos Vasilakis, Achilles Benetopoulos, Shivam Handa, Alizee Schoen, Jiasi
Shen, and Martin Rinard. Supply-chain vulnerability elimination via active
learning and regeneration. 2021. ACM Conference on Computer and Commu-
nications Security.
[155] Margus Veanes, Pavel Grigorenko, Peli de Halleux, and Nikolai Tillmann. Sym-
bolic query exploration. In Karin Breitman and Ana Cavalcanti, editors,For-
mal Methods and Software Engineering, pages 49‚Äì68, Berlin, Heidelberg, 2009.
Springer Berlin Heidelberg.
[156] Margus Veanes, Nikolai Tillmann, and Jonathan de Halleux. Qex: Symbolic
sql query explorer. In Edmund M. Clarke and Andrei Voronkov, editors,Logic
for Programming, Artificial Intelligence, and Reasoning, pages 425‚Äì446, Berlin,
Heidelberg, 2010. Springer Berlin Heidelberg.
427
[157] Michele Volpato and Jan Tretmans. Approximate active learning of nondeter-
ministic input output transition systems. Electronic Communications of the
EASST, 72, 2015.
[158] Chenglong Wang, Alvin Cheung, and Rastislav Bodik. Synthesizing highly ex-
pressive sql queries from input-output examples. In Proceedings of the 38th
ACM SIGPLAN Conference on Programming Language Design and Implemen-
tation, PLDI 2017, pages 452‚Äì466, New York, NY, USA, 2017. ACM.
[159] Chenglong Wang, Alvin Cheung, and Rastislav Bodik. Synthesizing highly ex-
pressive sql queries from input-output examples. In Proceedings of the 38th
ACM SIGPLAN Conference on Programming Language Design and Implemen-
tation, PLDI 2017, page 452‚Äì466, New York, NY, USA, 2017. Association for
Computing Machinery.
[160] Chenglong Wang, Alvin Cheung, and Rastislav Bodik. Speeding up
symbolic reasoning for relational queries. Proc. ACM Program. Lang. ,
2(OOPSLA):157:1‚Äì157:25, October 2018.
[161] Shaowei Wang, David Lo, and Lingxiao Jiang. Active code search: Incor-
porating user feedback to improve code search relevance. In Proceedings of
the 29th ACM/IEEE International Conference on Automated Software Engi-
neering, ASE ‚Äô14, page 677‚Äì682, New York, NY, USA, 2014. Association for
Computing Machinery.
[162] Xinyu Wang, Isil Dillig, and Rishabh Singh. Program synthesis using abstrac-
tion refinement.Proc. ACM Program. Lang., 2(POPL), December 2017.
[163] XinyuWang, IsilDillig, andRishabhSingh. Synthesisofdatacompletionscripts
using finite tree automata.Proc. ACM Program. Lang., 1(OOPSLA), October
2017.
[164] Xinyu Wang, Isil Dillig, and Rishabh Singh. Program synthesis using abstrac-
tion refinement.PACMPL, 2(POPL):63:1‚Äì63:30, 2018.
[165] Michael Widenius and Davis Axmark. Mysql Reference Manual. O‚ÄôReilly &
Associates, Inc., Sebastopol, CA, USA, 1st edition, 2002.
[166] Niklaus Wirth. Program development by stepwise refinement.Commun. ACM,
14(4):221‚Äì227, April 1971.
[167] Jerry Wu. Using dynamic analysis to infer python programs and convert them
into database programs. Master‚Äôs thesis, Massachusetts Institute of Technology,
Cambridge, MA, USA, 2018.
[168] Jerry Wu. Using dynamic analysis to infer python programs and convert them
into database programs. Master‚Äôs thesis, Massachusetts Institute of Technology,
2018. https://hdl.handle.net/1721.1/121643.
428
[169] Wenfei Wu, Ying Zhang, and Sujata Banerjee. Automatic synthesis of nf models
by program analysis. InProceedings of the 15th ACM Workshop on Hot Topics
in Networks, HotNets ‚Äô16, pages 29‚Äì35, New York, NY, USA, 2016. ACM.
[170] Navid Yaghmazadeh, Christian Klinger, Isil Dillig, and Swarat Chaudhuri. Syn-
thesizing transformations on hierarchically structured data. InProceedings of
the 37th ACM SIGPLAN Conference on Programming Language Design and
Implementation, PLDI 2016, Santa Barbara, CA, USA, June 13-17, 2016 ,
pages 508‚Äì521, 2016.
[171] Navid Yaghmazadeh, Xinyu Wang, and Isil Dillig. Automated migration of
hierarchical data to relational tables using programming-by-example. Proc.
VLDB Endow., 11(5):580‚Äì593, January 2018.
[172] Navid Yaghmazadeh, Yuepeng Wang, Isil Dillig, and Thomas Dillig. Sql-
izer: Query synthesis from natural language. Proc. ACM Program. Lang.,
1(OOPSLA):63:1‚Äì63:26, October 2017.
[173] Cong Yan, Alvin Cheung, Junwen Yang, and Shan Lu. Understanding database
performance inefficiencies in real-world web applications. InProceedings of the
2017 ACM on Conference on Information and Knowledge Management, CIKM
‚Äô17, pages 1299‚Äì1308, New York, NY, USA, 2017. ACM.
[174] Hong Yan, David Garlan, Bradley Schmerl, Jonathan Aldrich, and Rick Kaz-
man. Discotect: A system for discovering architectures from running systems.
In Proceedings of the 26th International Conference on Software Engineering,
ICSE ‚Äô04, pages 470‚Äì479, Washington, DC, USA, 2004. IEEE Computer Soci-
ety.
[175] Xi Ye, Qiaochu Chen, Xinyu Wang, Isil Dillig, and Greg Durrett. Sketch-
Driven Regular Expression Generation from Natural Language and Examples.
Transactions of the Association for Computational Linguistics, 8:679‚Äì694, 11
2020.
429